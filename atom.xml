<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mqray&#39;s blog</title>
  
  
  <link href="https://mqrayblog.cn/atom.xml" rel="self"/>
  
  <link href="https://mqrayblog.cn/"/>
  <updated>2023-10-24T04:46:09.800Z</updated>
  <id>https://mqrayblog.cn/</id>
  
  <author>
    <name>mqray</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>github + hexo建站[待补充]</title>
    <link href="https://mqrayblog.cn/2023/10/24/%E5%BB%BA%E7%AB%99/"/>
    <id>https://mqrayblog.cn/2023/10/24/%E5%BB%BA%E7%AB%99/</id>
    <published>2023-10-24T04:46:09.800Z</published>
    <updated>2023-10-24T04:46:09.800Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h4 id="排障"><a href="#排障" class="headerlink" title="排障"></a>排障</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO  Deleted database.</span><br><span class="line">FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html</span><br><span class="line">Error: EBUSY: resource busy or locked, rmdir &#x27;D:\blog\public&#x27;</span><br></pre></td></tr></table></figure><p>说来可笑，重启解决</p><h4 id="图片挂载"><a href="#图片挂载" class="headerlink" title="图片挂载"></a>图片挂载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save </span><br></pre></td></tr></table></figure><h4 id="切换action部署"><a href="#切换action部署" class="headerlink" title="切换action部署"></a>切换action部署</h4><p><a href="https://blog.csdn.net/lovedingd/article/details/119041379">https://blog.csdn.net/lovedingd/article/details/119041379</a></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.suyuanblog.xyz/2021/10/14/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/">1. 预部署文件渲染失败解决方案</a><br><a href="https://butterfly.js.org/posts/4aa8abbe/#%E4%BB%A3%E7%A2%BC%E9%AB%98%E5%BA%A6%E9%99%90%E5%88%B6">2. hexo butteryfly设置</a><br><a href="https://segmentfault.com/a/1190000042183952">3. 配置友链</a><br><a href="https://blog.csdn.net/qq_33384402/article/details/107200465">4. 接入博客</a><br><a href="https://blog.csdn.net/weixin_45649612/article/details/122777623">5. gitalk 未找到相关的Issues进行评论解决方法</a><br><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">6. 切换action部署1</a><br><a href="https://blog.zhanganzhi.com/zh-CN/2022/06/0800d76d306e/">7. 切换action部署2</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>springboot源码之启动流程3</title>
    <link href="https://mqrayblog.cn/2023/10/17/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B3/"/>
    <id>https://mqrayblog.cn/2023/10/17/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B3/</id>
    <published>2023-10-17T00:54:15.000Z</published>
    <updated>2023-10-24T04:46:09.796Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>这个部分提出问题，引发思考</p></blockquote><ol><li>单例bean和原型bean的区别以及创建过程的差别？</li></ol><p>上文<a href="https://mqrayblog.cn/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/">springboot源码之启动流程2</a>中几乎已经走完<code>spring启动流程</code>，但是遗留了两处逻辑 </p><p>todo 回顾启动流程！</p><ol><li>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</li><li>ServletWebServerApplicationContext#finishBeanFactoryInitialization</li></ol><p>现在来看<code>bean的创建流程</code>：</p><h3 id="ServletWebServerApplicationContext-finishBeanFactoryInitialization"><a href="#ServletWebServerApplicationContext-finishBeanFactoryInitialization" class="headerlink" title="ServletWebServerApplicationContext#finishBeanFactoryInitialization"></a>ServletWebServerApplicationContext#finishBeanFactoryInitialization</h3><p>完成bean factory的上下文初始化，初始化所有非懒加载的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// 初始化 上下文转换服务</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有BeanFactoryPostProcessor，则注入一个默认的值解析器</span></span><br><span class="line"><span class="comment">// 主要用于解析注解注入的属性值</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">       <span class="comment">// 初始化 LoadTimeWeaverAware 以提前注册 转化器</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不再使用临时的类加载器做类型匹配</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止修改所有bean definition，不允许再修改</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化所有非懒加载的单例</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultListableBeanFactory-preInstantiateSingletons"><a href="#DefaultListableBeanFactory-preInstantiateSingletons" class="headerlink" title="DefaultListableBeanFactory#preInstantiateSingletons"></a>DefaultListableBeanFactory#preInstantiateSingletons</h4><p>确保所有(包含<code>FactoryBeans</code>)非懒加载的单例被初始化</p><p>1.<br>2.<br>3. 获取<code>bean</code>，针对beanfactory是否是<code>SmartFactoryBean</code>接口的实现类进行判断。最后会调用<code>getBean</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对副本进行迭代以允许init方法注册新的bean定义</span></span><br><span class="line"><span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 非懒加载的bean的初始化</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="type">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged(</span><br><span class="line">(PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发后置初始化回调函数</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">先来看比较常见的方法<code>getMergedLocalBeanDefinition</code>，bean定义的抽象类是<code>AbstractBeanDefinition</code>， 普通的 bean在spring加载bean定义的时候是<code>GenericBeanDefinition</code>，而<code>spring</code>上下文实例化所有bean使用的则是<code>RootBeanDefinition，</code>整个过程由<code>getMergedLocalBeanDefinition</code>完成，将非<code>RootBeanDefinition</code>转化为<code>RootBeanDefinition</code>以供后续操作</font></p><p>遍历所有bean，获取其<code>beanDefinition</code>，如果没有就找其父类的<code>beanDefinition</code>。</p><p><code>preInstantiateSingletons</code>方法完成所有非懒加载的实例的创建。实例化bean过程需要满足如下三个条件：</p><ul><li>不是抽象类</li><li>是单例对象</li><li>非懒加载</li></ul><p>后续逻辑，先判断一下该<code>bean</code>是否是<code>FacctoryBean</code>的实现，然后进一步判断是否是 <code>SmartFactoryBean</code>实现，其中<code>SmartFactoryBean</code>定义了<code>isEagerInit</code>方法，如果为<code>True</code>则立即实例化该<code>bean</code>。如果该<code>bean</code>不是<code>BeanFactory</code>的实现，也会实例化该<code>bean</code>。</p><h5 id="AbstractBeanFactory-isFactoryBean"><a href="#AbstractBeanFactory-isFactoryBean" class="headerlink" title="AbstractBeanFactory#isFactoryBean"></a>AbstractBeanFactory#isFactoryBean</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFactoryBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException &#123;</span><br><span class="line">       <span class="comment">// 获取bean的真实名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">       <span class="comment">// 获取 工厂bean 单例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (beanInstance != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (beanInstance <span class="keyword">instanceof</span> FactoryBean);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No singleton instance found -&gt; check bean definition.</span></span><br><span class="line"><span class="keyword">if</span> (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line"><span class="comment">// No bean definition found in this factory -&gt; delegate to parent.</span></span><br><span class="line"><span class="keyword">return</span> ((ConfigurableBeanFactory) getParentBeanFactory()).isFactoryBean(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> isFactoryBean(beanName, getMergedLocalBeanDefinition(beanName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DefaultSingletonBeanRegistry-getSingleton"><a href="#DefaultSingletonBeanRegistry-getSingleton" class="headerlink" title="DefaultSingletonBeanRegistry#getSingleton"></a>DefaultSingletonBeanRegistry#getSingleton</h5><p><code>SingletonBeanRegistry</code>是<code>SingletonBeanRegistry</code>接口定义的方法，如下是<code>DefaultSingletonBeanRegistry</code>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the (raw) singleton object registered under the given name.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Checks already instantiated singletons and also allows for an early</span></span><br><span class="line"><span class="comment"> * reference to a currently created singleton (resolving a circular reference).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean to look for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allowEarlyReference whether early references should be created or not</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the registered singleton object, or &#123;<span class="doctag">@code</span> null&#125; if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractBeanFactory-doGetBean"><a href="#AbstractBeanFactory-doGetBean" class="headerlink" title="AbstractBeanFactory#doGetBean"></a>AbstractBeanFactory#doGetBean</h4><p><code>doGetBean</code>方法由<code>AbstractBeanFactory</code>定义，有不同的实现，用以获取<code>bean</code>，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requiredType the required type of the bean to retrieve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span></span><br><span class="line"><span class="comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span></span><br><span class="line"><span class="comment"> * not for actual use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException if the bean could not be created</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">Object bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">            <span class="comment">// 如果已经创建过这个bean实例，那假设处在循环引用 </span></span><br><span class="line">            <span class="comment">// 如果 beanName 正在被通过 原型模式创建，则抛出异常，无法应对循环依赖问题</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查beanfactory中是否已经存在该 bean definition， 如果该 bean factory中没有该bean definition ，</span></span><br><span class="line">            <span class="comment">// 则查找其parent bean factory中是否有该 bean definition</span></span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line"><span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                <span class="comment">// 再次检查该 bean definition 是否是 抽象类，如果是，则抛出异常</span></span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 确保 实例化该bean对象所依赖的bean 都已经被注册</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                        <span class="comment">// 确认指定的依赖bean是否已经注册给该bean，或者任何其可传递项</span></span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">                        <span class="comment">// 如果没有注册过，则注册依赖的bean</span></span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 bean 实例， 有两种典型模式</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他场景，目前没有实现</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No scope name defined for bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line"><span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="comment">// 在bean创建失败后，对缓存的元数据执行适当的清理。</span></span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 期望的类型 和 当前bean实例的类型是否匹配</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">T</span> <span class="variable">convertedBean</span> <span class="operator">=</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line"><span class="keyword">if</span> (convertedBean == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> convertedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第9行中通过调用<code>getSingleton</code>检查本地的单例缓存是否已经加载过<code>bean</code>，没有则检查<code>earlySingletonObjects</code>中是否已经加载过<code>bean</code>。如果该<code>bean</code>对象不为null则调用<code>getObjectForBeanInstance</code>方法获取bean。否则执行如下逻辑：</p><ol><li>调用<code> mbd.getDependsOn()</code>保证当前bean 依赖的bean会优先于当前bean被加载。</li><li>根据<code>beandefinition</code>的定义，按照单例&#x2F;原型模式来创建bean。单例bean和原型bean的创建过程如下。</li></ol><h4 id="单例bean的创建过程"><a href="#单例bean的创建过程" class="headerlink" title="单例bean的创建过程"></a>单例bean的创建过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类<code>AbstractBeanFactory</code>中定义了抽象方法<code>createBean</code>，由子类<code>AbstractAutowireCapableBeanFactory</code>进行重写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">mbdToUse</span> <span class="operator">=</span> mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="literal">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line"><span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line"><span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中会再次调用<code>doCreateBean</code>的重载方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 允许后置处理器修改合并后的bean definition</span></span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 bdf是单例且允许循环引用且当前该bean处于创建过程中，则使用三级缓存，预先将该bean创建所使用的beanfactory存入三级缓存中</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 填充field属性</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="comment">// 初始化该bean，包含bean的注入等</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean as disposable.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据<code>beandefinition</code>是否是单例，如果是则从<code>factoryBeanInstanceCache</code>移除该<code>instanceWrapper</code>，如果<code>instanceWrapper</code>为空，则调用<code>createBeanInstance</code>创建bean实例并包装为<code>beanwrapper</code>。<code>createBeanInstance</code>函数代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="literal">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">resolved</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">autowireNecessary</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="literal">null</span>) &#123;</span><br><span class="line">resolved = <span class="literal">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="literal">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">ctors = mbd.getPreferredConstructors();</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看，<code>instantiateBean</code>函数通过调用<code>instantiate</code>函数根据<code>beanName</code>和<code>beanDefinition</code>创建<code>bean</code>实例并调用<code>initBeanWrapper</code>将该bean包装为为<code>BeanWrapper</code>返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate the given bean using its default constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a BeanWrapper for the new instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> BeanWrapper <span class="title function_">instantiateBean</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">beanInstance = AccessController.doPrivileged(</span><br><span class="line">(PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, <span class="built_in">this</span>),</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SimpleInstantiationStrategy#instantiate  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">instantiate</span><span class="params">(RootBeanDefinition bd, <span class="meta">@Nullable</span> String beanName, BeanFactory owner)</span> &#123;</span><br><span class="line"><span class="comment">// Don&#x27;t override the class with CGLIB if no overrides.</span></span><br><span class="line"><span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">constructorToUse = AccessController.doPrivileged(</span><br><span class="line">(PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">&#125;</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该<code>beandefinition</code>没有被重写过，则在调用<code>BeanUtils.instantiateClass</code>创建bean实例之前选择一个构造方法；否则抛出异常。</p><p>BeanUtils#instantiateClass </p><p>该方法通过反射创建bean实例，通过调用<code>ReflectionUtils.makeAccessible(ctor)</code>，即使该bean的构造方法是私有的也可以用来创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convenience method to instantiate a class using the given constructor.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that this method tries to set the constructor accessible if given a</span></span><br><span class="line"><span class="comment"> * non-accessible (that is, non-public) constructor, and supports Kotlin classes</span></span><br><span class="line"><span class="comment"> * with optional parameters and default values.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctor the constructor to instantiate</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args the constructor arguments to apply (use &#123;<span class="doctag">@code</span> null&#125; for an unspecified</span></span><br><span class="line"><span class="comment"> * parameter, Kotlin optional parameters and Java primitive types are supported)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanInstantiationException if the bean cannot be instantiated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Constructor#newInstance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException &#123;</span><br><span class="line">Assert.notNull(ctor, <span class="string">&quot;Constructor must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ReflectionUtils.makeAccessible(ctor);</span><br><span class="line"><span class="keyword">if</span> (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) &#123;</span><br><span class="line"><span class="keyword">return</span> KotlinDelegate.instantiateClass(ctor, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Class&lt;?&gt;[] parameterTypes = ctor.getParameterTypes();</span><br><span class="line">Assert.isTrue(args.length &lt;= parameterTypes.length, <span class="string">&quot;Can&#x27;t specify more arguments than constructor parameters&quot;</span>);</span><br><span class="line">Object[] argsWithDefaultValues = <span class="keyword">new</span> <span class="title class_">Object</span>[args.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; args.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (args[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; parameterType = parameterTypes[i];</span><br><span class="line">argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">argsWithDefaultValues[i] = args[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ctor.newInstance(argsWithDefaultValues);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(ctor, <span class="string">&quot;Is it an abstract class?&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(ctor, <span class="string">&quot;Is the constructor accessible?&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(ctor, <span class="string">&quot;Illegal arguments for constructor&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInstantiationException</span>(ctor, <span class="string">&quot;Constructor threw exception&quot;</span>, ex.getTargetException());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原型bean的创建"><a href="#原型bean的创建" class="headerlink" title="原型bean的创建"></a>原型bean的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">       <span class="comment">// 如果是原型模式，则创建一个新对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.jianshu.com/p/577906fa2cc2">1. SpringBoot深入学习（一）– refresh()</a>   </p><p><a href="https://lucumt.info/post/spring/spring-core/difference-between-factorybean-and-beanfactory/">2. Spring中BeanFactory和FactoryBean的区别以及使用场景</a>  </p><p><a href="https://blog.csdn.net/weixin_43944305/article/details/108526186">3. Spring的单例bean与原型bean的区别和创建过程</a>  </p><p><a href="https://www.cnblogs.com/xrq730/p/6361578.html">4. <a href="https://www.cnblogs.com/xrq730/p/6361578.html">【Spring源码分析】非懒加载的单例Bean初始化过程（上篇）</a></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这个部分提出问题，引发思考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;单例bean和原型bean的区别</summary>
      
    
    
    
    
    <category term="java" scheme="https://mqrayblog.cn/tags/java/"/>
    
    <category term="spring" scheme="https://mqrayblog.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>springboot源码之启动流程2</title>
    <link href="https://mqrayblog.cn/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/"/>
    <id>https://mqrayblog.cn/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/</id>
    <published>2023-10-12T00:12:15.000Z</published>
    <updated>2023-10-24T04:46:09.796Z</updated>
    
    <content type="html"><![CDATA[<p><code>spring</code>启动流程比较长，接上回<a href="https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">springboot源码之启动流程1</a>，接下来继续看<code>refreshContext</code></p><h2 id="SpringApplication-refreshContext"><a href="#SpringApplication-refreshContext" class="headerlink" title="SpringApplication#refreshContext"></a>SpringApplication#refreshContext</h2><ol><li>创建并初始化 BeanFactory：首先，它会创建一个 BeanFactory 对象，用于管理和创建应用程序中的 Bean。</li><li>加载 Bean 定义：接下来，它会加载应用程序中定义的 Bean，包括通过注解、XML 配置文件等方式定义的 Bean。</li><li>实例化和初始化 Bean：然后，它会实例化和初始化所有的 Bean，包括依赖注入、AOP 代理等操作。</li><li>处理 Bean 生命周期回调：在 Bean 实例化和初始化完成后，<code>refresh</code> 方法会调用各个 Bean 的生命周期回调方法，例如 <code>@PostConstruct</code> 注解标注的方法。</li><li>注册 Bean 后置处理器：<code>refresh</code> 方法还会注册 Bean 后置处理器，用于在 Bean 初始化前后进行一些额外的处理操作。</li></ol><p>通过调用 <code>SpringApplication#refresh</code> 方法，应用程序上下文将完成初始化和刷新，所有的 Bean 将被正确创建和配置，应用程序将进入可用状态，可以响应外部请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    refresh((ApplicationContext) context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册 关闭 钩子</span></span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">            <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-refresh"><a href="#SpringApplication-refresh" class="headerlink" title="SpringApplication#refresh"></a>SpringApplication#refresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);</span><br><span class="line">    refresh((ConfigurableApplicationContext) applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    applicationContext.refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);</span><br><span class="line">    refresh((ConfigurableApplicationContext) applicationContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>refresh</code>是<code>ConfigurableApplicationContext</code>中定义的接口，默认有如下实现</p><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697068082459.png" alt="1697068082459"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/SpringApplication_refresh.png">  <h4 id="AbstractApplicationContext-refresh"><a href="#AbstractApplicationContext-refresh" class="headerlink" title="AbstractApplicationContext#refresh"></a>AbstractApplicationContext#refresh</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 为刷新上下文做准备工作</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">//  通知子类刷新内部的 bean factory</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">           <span class="comment">// 准备 bean factory</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">               <span class="comment">// </span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line"><span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-prepareRefresh"><a href="#AbstractApplicationContext-prepareRefresh" class="headerlink" title="AbstractApplicationContext#prepareRefresh"></a>AbstractApplicationContext#prepareRefresh</h3><p>在<code>refresh</code>前做准备工作：</p><ol><li>设置spring启动事件，开启活跃状态</li><li>初始化属性源信息</li><li>保存<code>earlyApplicationListeners</code></li><li>验证必要的属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 设置激活状态</span></span><br><span class="line"><span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 初始化 上下文环境中的 所有 PropertySources 调用 initServletPropertySources</span></span><br><span class="line">initPropertySources();</span><br><span class="line">       <span class="comment">// 校验所有被标识为required 的properties都可以被解析</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationListeners == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.earlyApplicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.applicationListeners);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line"><span class="built_in">this</span>.applicationListeners.clear();</span><br><span class="line"><span class="built_in">this</span>.applicationListeners.addAll(<span class="built_in">this</span>.earlyApplicationListeners);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存储 应用启动前的 事件 ，在 multicaster可用时发布</span></span><br><span class="line"><span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-obtainFreshBeanFactory"><a href="#AbstractApplicationContext-obtainFreshBeanFactory" class="headerlink" title="AbstractApplicationContext#obtainFreshBeanFactory"></a>AbstractApplicationContext#obtainFreshBeanFactory</h3><ol><li>通知子类刷新内在的 bean factory</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractRefreshableApplicationContext-refreshBeanFactory"><a href="#AbstractRefreshableApplicationContext-refreshBeanFactory" class="headerlink" title="AbstractRefreshableApplicationContext#refreshBeanFactory"></a>AbstractRefreshableApplicationContext#refreshBeanFactory</h4><p>负责刷新<code>beanfactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">       <span class="comment">// 如果已经存在 beanfactory，销毁并关闭beanfactory</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 创建 DefaultListableBeanFactory 类型的 beanfactory。 初始化容器，注册并加载bean基本容器</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line">           <span class="comment">// 设置 beanfactory 属性，比如是否bean名字重复时可否重写、是否允许循环引用</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">           <span class="comment">// 将 beandefinition 注册到 beanfactory</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697111817207.png" alt="1697111817207"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/createBeanFactory.png">  <p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697073372826.png" alt="1697073372826"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/AbstractRefreshableApplicationContext_arch.png">   <h5 id="AbstractRefreshableApplicationContext-loadBeanDefinitions"><a href="#AbstractRefreshableApplicationContext-loadBeanDefinitions" class="headerlink" title="AbstractRefreshableApplicationContext#loadBeanDefinitions"></a>AbstractRefreshableApplicationContext#loadBeanDefinitions</h5><p>有如下四个实现 还要继续看</p><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697111477191.png" alt="1697111477191"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/abstractRefreshableApplicationContext_loadBeanDefinitions.png">   <h5 id="AbstractApplicationContext-prepareBeanFactory"><a href="#AbstractApplicationContext-prepareBeanFactory" class="headerlink" title="AbstractApplicationContext#prepareBeanFactory"></a>AbstractApplicationContext#prepareBeanFactory</h5><p>上一步获取到新的<code>BeanFactory</code>后，<code>prepareBeanFactory</code>设置其属性。</p><ol><li>配置<code>BeanClassLoader</code>；</li><li>设置<code>BeanExpressionResolver</code> bean名称解析器，主要用来解析<code>EL</code>表达式，在bean初始化完成之后属性填充时会用到；</li><li>设置<code>PropertyEditorRegistrar</code>属性解析器</li><li>设置<code>BeanPostProcessor</code>, <code>ApplicationContextAwareProcessor</code> 用来处理并回调实现各种<code>Aware</code>接口的bean</li><li><code>ignoreDependencyInterface</code>忽略如下类的自动装配  <code>EnvironmentAware| EmbeddedValueResolverAware| ResourceLoaderAware|ApplicationEventPublisherAware|MessageSourceAware|ApplicationContextAware</code> 。</li><li><code>registerResolvableDependency</code>设置自动装配规则。</li><li>配置<code>ApplicationListenerDetector</code>的<code>BeanPostProcessor</code>;</li><li>如果 <code>beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)</code>如果当前的<code>beanFactory</code>包含<code>loadTimeWeaver</code>，则将当前<code>beanFactory</code>交给类加载器<code>BeanPostProcessor</code>的实现类<code>LoadTimeWeaverAwareProcessor</code>处理。从而实现类加载器植入<code>AspectJ</code>的目的。</li><li><code>registerSingleton</code> 注册环境相关的 bean</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line"><span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-postProcessBeanFactory"><a href="#AbstractApplicationContext-postProcessBeanFactory" class="headerlink" title="AbstractApplicationContext#postProcessBeanFactory"></a>AbstractApplicationContext#postProcessBeanFactory</h3><ul><li>在所有<code>beandefinition</code>加载完之后，<code>bean实例化</code>之前执行；可以理解为<code>prepareBeanFactory</code>的补充或者扩展；<code>spring</code>中不同的子类有不同的实现。</li><li>但是不允许在重写的<code>prepareBeanFactory</code>方法中对<code>bean</code>进行实例化操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 所有 beandefinition加载后，实例化之前执行</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697114653991.png" alt="1697114653991"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/AbstractApplicationContext_postProcessBeanFactory.png">   <h4 id="AbstractRefreshableWebApplicationContext-postProcessBeanFactory"><a href="#AbstractRefreshableWebApplicationContext-postProcessBeanFactory" class="headerlink" title="AbstractRefreshableWebApplicationContext#postProcessBeanFactory#"></a>AbstractRefreshableWebApplicationContext#postProcessBeanFactory#</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">       beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ServletContextAwareProcessor</span>(<span class="built_in">this</span>.servletContext, <span class="built_in">this</span>.servletConfig));</span><br><span class="line">       beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">       beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class="line">       WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="built_in">this</span>.servletContext);</span><br><span class="line">       WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="built_in">this</span>.servletContext, <span class="built_in">this</span>.servletConfig);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-invokeBeanFactoryPostProcessors"><a href="#AbstractApplicationContext-invokeBeanFactoryPostProcessors" class="headerlink" title="AbstractApplicationContext#invokeBeanFactoryPostProcessors"></a>AbstractApplicationContext#invokeBeanFactoryPostProcessors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"><span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors"></a>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这段代码也太长了，可以单独起一篇了</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-registerBeanPostProcessors"><a href="#AbstractApplicationContext-registerBeanPostProcessors" class="headerlink" title="AbstractApplicationContext#registerBeanPostProcessors"></a>AbstractApplicationContext#registerBeanPostProcessors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注册拦截bean创建的bean处理器。如果给定顺序则遵循顺序。它必须在 bean 实例化 之前调用</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PostProcessorRegistrationDelegate-registerBeanPostProcessors"><a href="#PostProcessorRegistrationDelegate-registerBeanPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate#registerBeanPostProcessors"></a>PostProcessorRegistrationDelegate#registerBeanPostProcessors</h4><ol><li>获取所有<code>BeanPostProcessor</code>名称</li><li>添加后置处理器<code>BeanPostProcessorChecker</code></li><li>遍历<code>BeanPostProcessorName</code>，分如下三种情况：<code>PriorityOrdered</code>、<code>Ordered</code>、<code>其他</code>。</li><li>注册<code>priorityOrderedPostProcessors</code>，注册之前按照优先级升序排列</li><li>注册<code>orderedPostProcessors。</code>先根据 <code>orderedPostProcessorNames</code>从beanFactory中获取 <code>BeanPostProcessor</code>，然后注册到 <code>orderedPostProcessors</code>  中，如果该processor的类型是 <code>MergedBeanDefinitionPostProcessor</code>  则同时加入到<code>internalPostProcessors</code>中。</li><li>和第5步类似，注册<code>nonOrderedPostProcessors</code>。也有加入<code>internalPostProcessors</code>逻辑。</li><li>注册<code>internalPostProcessors</code></li><li>注册<code>ApplicationListenerDetector</code>处理器，同时将它移动到处理器链的最后。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line"><span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line"><span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line"><span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">priorityOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line"><span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">orderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line"><span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">nonOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line"><span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-initMessageSource"><a href="#AbstractApplicationContext-initMessageSource" class="headerlink" title="AbstractApplicationContext#initMessageSource"></a>AbstractApplicationContext#initMessageSource</h3><ol><li>初始化消息源。如果上下文中未定义，则使用父类的实现。</li><li>判断<code>beanFactory</code>中是否有名为<code>messageSource</code>的bean</li><li>如果有，获取到之后，判断其类型是否为<code>HierarchicalMessageSource</code>则填充其父类的消息源</li><li>否则，新建<code>DelegatingMessageSource</code>作为消息源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent&#x27;s if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"><span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line"><span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line"><span class="type">HierarchicalMessageSource</span> <span class="variable">hms</span> <span class="operator">=</span> (HierarchicalMessageSource) <span class="built_in">this</span>.messageSource;</span><br><span class="line"><span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line"><span class="comment">// registered already.</span></span><br><span class="line">hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line"><span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line"><span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-initApplicationEventMulticaster"><a href="#AbstractApplicationContext-initApplicationEventMulticaster" class="headerlink" title="AbstractApplicationContext#initApplicationEventMulticaster"></a>AbstractApplicationContext#initApplicationEventMulticaster</h3><ol><li>初始化应用事件广播器，如果未定义则默认使用<code>SimpleApplicationEventMulticaster</code></li><li>检查<code>beanFactory</code>中是否有名为<code>applicationEventMulticaster</code>的bean对象，如果有，则将其设置为应用上下文的<code>applicationEventMulticaster</code></li><li>否则，使用<code>SimpleApplicationEventMulticaster</code>作为应用上下文的<code>applicationEventMulticaster</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="built_in">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line"><span class="string">&quot;[&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-onRefresh"><a href="#AbstractApplicationContext-onRefresh" class="headerlink" title="AbstractApplicationContext#onRefresh"></a>AbstractApplicationContext#onRefresh</h3><p>可以重写以添加特定于上下文的刷新工作的模板方法。在初始化特殊bean时调用，然后再实例化singleton。</p><p>空实现，由子类重写。</p><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697158204211.png" alt="1697158204211"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/AbstractApplicationContext_onRefresh.png">   <p>如上五个子类实现中，<code>ServletWebServerApplicationContext</code>和<code>ReactiveWebServerApplicationContext</code>的实现如下。</p><h4 id="ServletWebServerApplicationContext-onRefresh"><a href="#ServletWebServerApplicationContext-onRefresh" class="headerlink" title="ServletWebServerApplicationContext#onRefresh#"></a>ServletWebServerApplicationContext#onRefresh#</h4><ol><li>调用父类的onRefresh实现，其实是空</li><li>调用<code>createWebServer</code>创建web服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.onRefresh();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">createWebServer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start reactive web server&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ServletWebServerApplicationContext-createWebServer"><a href="#ServletWebServerApplicationContext-createWebServer" class="headerlink" title="ServletWebServerApplicationContext#createWebServer"></a>ServletWebServerApplicationContext#createWebServer</h5><ol><li>获取 <code>getServletContext</code></li><li>判断<code>webServer</code>和<code>servletContext</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> <span class="built_in">this</span>.webServer;</span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="keyword">if</span> (webServer == <span class="literal">null</span> &amp;&amp; servletContext == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line"><span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">getBeanFactory().registerSingleton(<span class="string">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WebServerGracefulShutdownLifecycle</span>(<span class="built_in">this</span>.webServer));</span><br><span class="line">getBeanFactory().registerSingleton(<span class="string">&quot;webServerStartStop&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WebServerStartStopLifecycle</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.webServer));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getSelfInitializer().onStartup(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余三个子类实现则比较简单，仅对主题园做了配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.themeSource = UiApplicationContextUtils.initThemeSource(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.jianshu.com/p/577906fa2cc2">1. SpringBoot深入学习（一）– refresh()</a>  </p><p><a href="https://lucumt.info/post/spring/spring-core/difference-between-factorybean-and-beanfactory/">2. Spring中BeanFactory和FactoryBean的区别以及使用场景</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;spring&lt;/code&gt;启动流程比较长，接上回&lt;a href=&quot;https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E</summary>
      
    
    
    
    
    <category term="java" scheme="https://mqrayblog.cn/tags/java/"/>
    
    <category term="spring" scheme="https://mqrayblog.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>springboot源码之启动流程2</title>
    <link href="https://mqrayblog.cn/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/"/>
    <id>https://mqrayblog.cn/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/</id>
    <published>2023-10-12T00:12:15.000Z</published>
    <updated>2023-10-24T04:46:09.796Z</updated>
    
    <content type="html"><![CDATA[<p><code>spring</code>启动流程比较长，接上回<a href="https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">springboot源码之启动流程1</a>，接下来继续看<code>refreshContext</code></p><h2 id="SpringApplication-refreshContext"><a href="#SpringApplication-refreshContext" class="headerlink" title="SpringApplication#refreshContext"></a>SpringApplication#refreshContext</h2><ol><li>创建并初始化 BeanFactory：首先，它会创建一个 BeanFactory 对象，用于管理和创建应用程序中的 Bean。</li><li>加载 Bean 定义：接下来，它会加载应用程序中定义的 Bean，包括通过注解、XML 配置文件等方式定义的 Bean。</li><li>实例化和初始化 Bean：然后，它会实例化和初始化所有的 Bean，包括依赖注入、AOP 代理等操作。</li><li>处理 Bean 生命周期回调：在 Bean 实例化和初始化完成后，<code>refresh</code> 方法会调用各个 Bean 的生命周期回调方法，例如 <code>@PostConstruct</code> 注解标注的方法。</li><li>注册 Bean 后置处理器：<code>refresh</code> 方法还会注册 Bean 后置处理器，用于在 Bean 初始化前后进行一些额外的处理操作。</li></ol><p>通过调用 <code>SpringApplication#refresh</code> 方法，应用程序上下文将完成初始化和刷新，所有的 Bean 将被正确创建和配置，应用程序将进入可用状态，可以响应外部请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    refresh((ApplicationContext) context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册 关闭 钩子</span></span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">            <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-refresh"><a href="#SpringApplication-refresh" class="headerlink" title="SpringApplication#refresh"></a>SpringApplication#refresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);</span><br><span class="line">    refresh((ConfigurableApplicationContext) applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    applicationContext.refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);</span><br><span class="line">    refresh((ConfigurableApplicationContext) applicationContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>refresh</code>是<code>ConfigurableApplicationContext</code>中定义的接口，默认有如下实现</p><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697068082459.png" alt="1697068082459"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/SpringApplication_refresh.png">  <h4 id="AbstractApplicationContext-refresh"><a href="#AbstractApplicationContext-refresh" class="headerlink" title="AbstractApplicationContext#refresh"></a>AbstractApplicationContext#refresh</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 为刷新上下文做准备工作</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">//  通知子类刷新内部的 bean factory</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">           <span class="comment">// 准备 bean factory</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">               <span class="comment">// </span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line"><span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-prepareRefresh"><a href="#AbstractApplicationContext-prepareRefresh" class="headerlink" title="AbstractApplicationContext#prepareRefresh"></a>AbstractApplicationContext#prepareRefresh</h3><p>在<code>refresh</code>前做准备工作：</p><ol><li>设置spring启动事件，开启活跃状态</li><li>初始化属性源信息</li><li>保存<code>earlyApplicationListeners</code></li><li>验证必要的属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prepare this context for refreshing, setting its startup date and</span></span><br><span class="line"><span class="comment"> * active flag as well as performing any initialization of property sources.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 设置激活状态</span></span><br><span class="line"><span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line"><span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Refreshing &quot;</span> + getDisplayName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 初始化 上下文环境中的 所有 PropertySources 调用 initServletPropertySources</span></span><br><span class="line">initPropertySources();</span><br><span class="line">       <span class="comment">// 校验所有被标识为required 的properties都可以被解析</span></span><br><span class="line">getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationListeners == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.earlyApplicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.applicationListeners);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line"><span class="built_in">this</span>.applicationListeners.clear();</span><br><span class="line"><span class="built_in">this</span>.applicationListeners.addAll(<span class="built_in">this</span>.earlyApplicationListeners);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存储 应用启动前的 事件 ，在 multicaster可用时发布</span></span><br><span class="line"><span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-obtainFreshBeanFactory"><a href="#AbstractApplicationContext-obtainFreshBeanFactory" class="headerlink" title="AbstractApplicationContext#obtainFreshBeanFactory"></a>AbstractApplicationContext#obtainFreshBeanFactory</h3><ol><li>通知子类刷新内在的 bean factory</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the fresh BeanFactory instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #refreshBeanFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getBeanFactory()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">refreshBeanFactory();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractRefreshableApplicationContext-refreshBeanFactory"><a href="#AbstractRefreshableApplicationContext-refreshBeanFactory" class="headerlink" title="AbstractRefreshableApplicationContext#refreshBeanFactory"></a>AbstractRefreshableApplicationContext#refreshBeanFactory</h4><p>负责刷新<code>beanfactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">       <span class="comment">// 如果已经存在 beanfactory，销毁并关闭beanfactory</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">destroyBeans();</span><br><span class="line">closeBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 创建 DefaultListableBeanFactory 类型的 beanfactory。 初始化容器，注册并加载bean基本容器</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> createBeanFactory();</span><br><span class="line">beanFactory.setSerializationId(getId());</span><br><span class="line">           <span class="comment">// 设置 beanfactory 属性，比如是否bean名字重复时可否重写、是否允许循环引用</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">           <span class="comment">// 将 beandefinition 注册到 beanfactory</span></span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br><span class="line"><span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697111817207.png" alt="1697111817207"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/createBeanFactory.png">  <p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697073372826.png" alt="1697073372826"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/AbstractRefreshableApplicationContext_arch.png">   <h5 id="AbstractRefreshableApplicationContext-loadBeanDefinitions"><a href="#AbstractRefreshableApplicationContext-loadBeanDefinitions" class="headerlink" title="AbstractRefreshableApplicationContext#loadBeanDefinitions"></a>AbstractRefreshableApplicationContext#loadBeanDefinitions</h5><p>有如下四个实现 还要继续看</p><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697111477191.png" alt="1697111477191"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/abstractRefreshableApplicationContext_loadBeanDefinitions.png">   <h5 id="AbstractApplicationContext-prepareBeanFactory"><a href="#AbstractApplicationContext-prepareBeanFactory" class="headerlink" title="AbstractApplicationContext#prepareBeanFactory"></a>AbstractApplicationContext#prepareBeanFactory</h5><p>上一步获取到新的<code>BeanFactory</code>后，<code>prepareBeanFactory</code>设置其属性。</p><ol><li>配置<code>BeanClassLoader</code>；</li><li>设置<code>BeanExpressionResolver</code> bean名称解析器，主要用来解析<code>EL</code>表达式，在bean初始化完成之后属性填充时会用到；</li><li>设置<code>PropertyEditorRegistrar</code>属性解析器</li><li>设置<code>BeanPostProcessor</code>, <code>ApplicationContextAwareProcessor</code> 用来处理并回调实现各种<code>Aware</code>接口的bean</li><li><code>ignoreDependencyInterface</code>忽略如下类的自动装配  <code>EnvironmentAware| EmbeddedValueResolverAware| ResourceLoaderAware|ApplicationEventPublisherAware|MessageSourceAware|ApplicationContextAware</code> 。</li><li><code>registerResolvableDependency</code>设置自动装配规则。</li><li>配置<code>ApplicationListenerDetector</code>的<code>BeanPostProcessor</code>;</li><li>如果 <code>beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)</code>如果当前的<code>beanFactory</code>包含<code>loadTimeWeaver</code>，则将当前<code>beanFactory</code>交给类加载器<code>BeanPostProcessor</code>的实现类<code>LoadTimeWeaverAwareProcessor</code>处理。从而实现类加载器植入<code>AspectJ</code>的目的。</li><li><code>registerSingleton</code> 注册环境相关的 bean</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line"><span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line"><span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register default environment beans.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-postProcessBeanFactory"><a href="#AbstractApplicationContext-postProcessBeanFactory" class="headerlink" title="AbstractApplicationContext#postProcessBeanFactory"></a>AbstractApplicationContext#postProcessBeanFactory</h3><ul><li>在所有<code>beandefinition</code>加载完之后，<code>bean实例化</code>之前执行；可以理解为<code>prepareBeanFactory</code>的补充或者扩展；<code>spring</code>中不同的子类有不同的实现。</li><li>但是不允许在重写的<code>prepareBeanFactory</code>方法中对<code>bean</code>进行实例化操作。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Modify the application context&#x27;s internal bean factory after its standard</span></span><br><span class="line"><span class="comment"> * initialization. All bean definitions will have been loaded, but no beans</span></span><br><span class="line"><span class="comment"> * will have been instantiated yet. This allows for registering special</span></span><br><span class="line"><span class="comment"> * BeanPostProcessors etc in certain ApplicationContext implementations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the bean factory used by the application context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 所有 beandefinition加载后，实例化之前执行</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697114653991.png" alt="1697114653991"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/AbstractApplicationContext_postProcessBeanFactory.png">   <h4 id="AbstractRefreshableWebApplicationContext-postProcessBeanFactory"><a href="#AbstractRefreshableWebApplicationContext-postProcessBeanFactory" class="headerlink" title="AbstractRefreshableWebApplicationContext#postProcessBeanFactory#"></a>AbstractRefreshableWebApplicationContext#postProcessBeanFactory#</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">       beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ServletContextAwareProcessor</span>(<span class="built_in">this</span>.servletContext, <span class="built_in">this</span>.servletConfig));</span><br><span class="line">       beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">       beanFactory.ignoreDependencyInterface(ServletConfigAware.class);</span><br><span class="line">       WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="built_in">this</span>.servletContext);</span><br><span class="line">       WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="built_in">this</span>.servletContext, <span class="built_in">this</span>.servletConfig);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-invokeBeanFactoryPostProcessors"><a href="#AbstractApplicationContext-invokeBeanFactoryPostProcessors" class="headerlink" title="AbstractApplicationContext#invokeBeanFactoryPostProcessors"></a>AbstractApplicationContext#invokeBeanFactoryPostProcessors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and invoke all registered BeanFactoryPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before singleton instantiation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line"><span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors"></a>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这段代码也太长了，可以单独起一篇了</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-registerBeanPostProcessors"><a href="#AbstractApplicationContext-registerBeanPostProcessors" class="headerlink" title="AbstractApplicationContext#registerBeanPostProcessors"></a>AbstractApplicationContext#registerBeanPostProcessors</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">注册拦截bean创建的bean处理器。如果给定顺序则遵循顺序。它必须在 bean 实例化 之前调用</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate and register all BeanPostProcessor beans,</span></span><br><span class="line"><span class="comment"> * respecting explicit order if given.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Must be called before any instantiation of application beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PostProcessorRegistrationDelegate-registerBeanPostProcessors"><a href="#PostProcessorRegistrationDelegate-registerBeanPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate#registerBeanPostProcessors"></a>PostProcessorRegistrationDelegate#registerBeanPostProcessors</h4><ol><li>获取所有<code>BeanPostProcessor</code>名称</li><li>添加后置处理器<code>BeanPostProcessorChecker</code></li><li>遍历<code>BeanPostProcessorName</code>，分如下三种情况：<code>PriorityOrdered</code>、<code>Ordered</code>、<code>其他</code>。</li><li>注册<code>priorityOrderedPostProcessors</code>，注册之前按照优先级升序排列</li><li>注册<code>orderedPostProcessors。</code>先根据 <code>orderedPostProcessorNames</code>从beanFactory中获取 <code>BeanPostProcessor</code>，然后注册到 <code>orderedPostProcessors</code>  中，如果该processor的类型是 <code>MergedBeanDefinitionPostProcessor</code>  则同时加入到<code>internalPostProcessors</code>中。</li><li>和第5步类似，注册<code>nonOrderedPostProcessors</code>。也有加入<code>internalPostProcessors</code>逻辑。</li><li>注册<code>internalPostProcessors</code></li><li>注册<code>ApplicationListenerDetector</code>处理器，同时将它移动到处理器链的最后。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line"><span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line"><span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line"><span class="comment">// Ordered, and the rest.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line"><span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">priorityOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">orderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line"><span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">orderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line"><span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line"><span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">nonOrderedPostProcessors.add(pp);</span><br><span class="line"><span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">internalPostProcessors.add(pp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line"><span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-initMessageSource"><a href="#AbstractApplicationContext-initMessageSource" class="headerlink" title="AbstractApplicationContext#initMessageSource"></a>AbstractApplicationContext#initMessageSource</h3><ol><li>初始化消息源。如果上下文中未定义，则使用父类的实现。</li><li>判断<code>beanFactory</code>中是否有名为<code>messageSource</code>的bean</li><li>如果有，获取到之后，判断其类型是否为<code>HierarchicalMessageSource</code>则填充其父类的消息源</li><li>否则，新建<code>DelegatingMessageSource</code>作为消息源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the MessageSource.</span></span><br><span class="line"><span class="comment"> * Use parent&#x27;s if none defined in this context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"><span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line"><span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line"><span class="type">HierarchicalMessageSource</span> <span class="variable">hms</span> <span class="operator">=</span> (HierarchicalMessageSource) <span class="built_in">this</span>.messageSource;</span><br><span class="line"><span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line"><span class="comment">// registered already.</span></span><br><span class="line">hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line"><span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line"><span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-initApplicationEventMulticaster"><a href="#AbstractApplicationContext-initApplicationEventMulticaster" class="headerlink" title="AbstractApplicationContext#initApplicationEventMulticaster"></a>AbstractApplicationContext#initApplicationEventMulticaster</h3><ol><li>初始化应用事件广播器，如果未定义则默认使用<code>SimpleApplicationEventMulticaster</code></li><li>检查<code>beanFactory</code>中是否有名为<code>applicationEventMulticaster</code>的bean对象，如果有，则将其设置为应用上下文的<code>applicationEventMulticaster</code></li><li>否则，使用<code>SimpleApplicationEventMulticaster</code>作为应用上下文的<code>applicationEventMulticaster</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the ApplicationEventMulticaster.</span></span><br><span class="line"><span class="comment"> * Uses SimpleApplicationEventMulticaster if none defined in the context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.SimpleApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"><span class="built_in">this</span>.applicationEventMulticaster =</span><br><span class="line">beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + <span class="string">&quot;&#x27; bean, using &quot;</span> +</span><br><span class="line"><span class="string">&quot;[&quot;</span> + <span class="built_in">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AbstractApplicationContext-onRefresh"><a href="#AbstractApplicationContext-onRefresh" class="headerlink" title="AbstractApplicationContext#onRefresh"></a>AbstractApplicationContext#onRefresh</h3><p>可以重写以添加特定于上下文的刷新工作的模板方法。在初始化特殊bean时调用，然后再实例化singleton。</p><p>空实现，由子类重写。</p><p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/Users\User\AppData\Local\Temp\1697158204211.png" alt="1697158204211"></p><img src="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/AbstractApplicationContext_onRefresh.png">   <p>如上五个子类实现中，<code>ServletWebServerApplicationContext</code>和<code>ReactiveWebServerApplicationContext</code>的实现如下。</p><h4 id="ServletWebServerApplicationContext-onRefresh"><a href="#ServletWebServerApplicationContext-onRefresh" class="headerlink" title="ServletWebServerApplicationContext#onRefresh#"></a>ServletWebServerApplicationContext#onRefresh#</h4><ol><li>调用父类的onRefresh实现，其实是空</li><li>调用<code>createWebServer</code>创建web服务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>.onRefresh();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">createWebServer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Unable to start reactive web server&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ServletWebServerApplicationContext-createWebServer"><a href="#ServletWebServerApplicationContext-createWebServer" class="headerlink" title="ServletWebServerApplicationContext#createWebServer"></a>ServletWebServerApplicationContext#createWebServer</h5><ol><li>获取 <code>getServletContext</code></li><li>判断<code>webServer</code>和<code>servletContext</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createWebServer</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">WebServer</span> <span class="variable">webServer</span> <span class="operator">=</span> <span class="built_in">this</span>.webServer;</span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="keyword">if</span> (webServer == <span class="literal">null</span> &amp;&amp; servletContext == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="type">ServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> getWebServerFactory();</span><br><span class="line"><span class="built_in">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">getBeanFactory().registerSingleton(<span class="string">&quot;webServerGracefulShutdown&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WebServerGracefulShutdownLifecycle</span>(<span class="built_in">this</span>.webServer));</span><br><span class="line">getBeanFactory().registerSingleton(<span class="string">&quot;webServerStartStop&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">WebServerStartStopLifecycle</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.webServer));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getSelfInitializer().onStartup(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(<span class="string">&quot;Cannot initialize servlet context&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">initPropertySources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余三个子类实现则比较简单，仅对主题源做了配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.themeSource = UiApplicationContextUtils.initThemeSource(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="ServletWebServerApplicationContext-registerListeners"><a href="#ServletWebServerApplicationContext-registerListeners" class="headerlink" title="ServletWebServerApplicationContext#registerListeners"></a>ServletWebServerApplicationContext#registerListeners</h3><ol><li>注册指定的静态监听器。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add beans that implement ApplicationListener as listeners.</span></span><br><span class="line"><span class="comment"> * Doesn&#x27;t affect other listeners, which can be added without being beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 获取手动注册的监听器，添加到广播器中</span></span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取监听器名称，配置到广播器中</span></span><br><span class="line">        <span class="comment">// 注意， 此处不进行初始化 </span></span><br><span class="line"><span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line"><span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 earlyApplicationEvents 中保存的事件 广播到 各监听器</span></span><br><span class="line">Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line"><span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line"><span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServletWebServerApplicationContext-finishBeanFactoryInitialization"><a href="#ServletWebServerApplicationContext-finishBeanFactoryInitialization" class="headerlink" title="ServletWebServerApplicationContext#finishBeanFactoryInitialization"></a>ServletWebServerApplicationContext#finishBeanFactoryInitialization</h3><p>完成bean factory的上下文初始化，初始化所有非懒加载的单例</p><p>这部分逻辑很长，单独放在另外一篇文章中： <a href>springboot源码之启动流程3</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the initialization of this context&#x27;s bean factory,</span></span><br><span class="line"><span class="comment"> * initializing all remaining singleton beans.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// 初始化 上下文转换服务</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有BeanFactoryPostProcessor，则注入一个默认的值解析器</span></span><br><span class="line"><span class="comment">// 主要用于解析注解注入的属性值</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">       <span class="comment">// 初始化 LoadTimeWeaverAware 以提前注册 转化器</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不再使用临时的类加载器做类型匹配</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止修改所有bean definition，不允许再修改</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化所有非懒加载的单例</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultListableBeanFactory-preInstantiateSingletons"><a href="#DefaultListableBeanFactory-preInstantiateSingletons" class="headerlink" title="DefaultListableBeanFactory#preInstantiateSingletons"></a>DefaultListableBeanFactory#preInstantiateSingletons</h4><p>确保所有(包含<code>FactoryBeans</code>)非懒加载的单例被初始化</p><ol><li>遍历所有bean，获取其<code>beanDefinition</code>，如果没有就找其父类的<code>beanDefinition</code>。</li><li>针对于<code>beandefinition</code>，其初始化需要保证如下三个条件：<ul><li>不是抽象类</li><li>是单例对象</li><li>非懒加载</li></ul></li><li>获取<code>bean</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对副本进行迭代以允许init方法注册新的bean定义</span></span><br><span class="line"><span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 非懒加载的bean的初始化</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="type">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged(</span><br><span class="line">(PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发后置初始化回调函数</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ServletWebServerApplicationContext-finishRefresh"><a href="#ServletWebServerApplicationContext-finishRefresh" class="headerlink" title="ServletWebServerApplicationContext#finishRefresh"></a>ServletWebServerApplicationContext#finishRefresh</h3><p>调用<code>LifecycleProcessor#onRefresh</code>刷新上下文，同时广播<code>ContextRefreshedEvent</code>事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Finish the refresh of this context, invoking the LifecycleProcessor&#x27;s</span></span><br><span class="line"><span class="comment"> * onRefresh() method and publishing the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> org.springframework.context.event.ContextRefreshedEvent&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 清除上下文级别的资源缓存(比如扫描的ASM元数据)</span></span><br><span class="line">clearResourceCaches();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 LifecycleProcessor</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 `LifecycleProcessor.onRefresh</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播 ContextRefreshedEvent事件</span></span><br><span class="line">publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.jianshu.com/p/577906fa2cc2">1. SpringBoot深入学习（一）– refresh()</a>  </p><p><a href="https://lucumt.info/post/spring/spring-core/difference-between-factorybean-and-beanfactory/">2. Spring中BeanFactory和FactoryBean的区别以及使用场景</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;spring&lt;/code&gt;启动流程比较长，接上回&lt;a href=&quot;https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E</summary>
      
    
    
    
    
    <category term="java" scheme="https://mqrayblog.cn/tags/java/"/>
    
    <category term="spring" scheme="https://mqrayblog.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>springboot源码之启动流程(1)</title>
    <link href="https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2023-10-10T08:05:35.000Z</published>
    <updated>2023-10-24T04:46:09.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主程序入口"><a href="#主程序入口" class="headerlink" title="主程序入口"></a>主程序入口</h3><blockquote><p>这里补充 入口 携带的注解说明</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(NotificationApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.SpringApplication</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WebApplicationType-deduceFromClasspath"><a href="#WebApplicationType-deduceFromClasspath" class="headerlink" title="WebApplicationType#deduceFromClasspath"></a>WebApplicationType#deduceFromClasspath</h5><p>这段代码是用于从类路径中推断出静态的Web应用程序类型的。它通过检查类路径中是否存在特定的类来确定应用程序类型。</p><p>首先，它检查是否存在<code>WEBFLUX_INDICATOR_CLASS</code>类，并且不存在<code>WEBMVC_INDICATOR_CLASS</code>和<code>JERSEY_INDICATOR_CLASS</code>类。如果满足这个条件，那么应用程序类型被判断为<code>WebApplicationType.REACTIVE</code>，表示是一个基于响应式编程模型的Web应用程序。</p><p>接下来，它遍历<code>SERVLET_INDICATOR_CLASSES</code>列表中的类名。如果在类路径中找不到其中任何一个类，那么应用程序类型被判断为<code>WebApplicationType.NONE</code>，表示不是一个基于Servlet的Web应用程序。</p><p>如果以上两个条件都不满足，那么应用程序类型被判断为<code>WebApplicationType.SERVLET</code>，表示是一个基于Servlet的Web应用程序。</p><p><code>WebApplicationType</code>是一个枚举类型，用于表示Web应用程序的类型，包括<code>NONE</code>、<code>SERVLET</code>和<code>REACTIVE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> WebApplicationType <span class="title function_">deduceFromClasspath</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="literal">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="literal">null</span>)</span><br><span class="line">&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication#run"></a>SpringApplication#run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.SpringApplication</span><br><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="comment">// 创建应用上下文</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 异常收集，报告启动异常</span></span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 设置为headless模式</span></span><br><span class="line">        <span class="built_in">this</span>.configureHeadlessProperty();</span><br><span class="line">        <span class="comment">// 获取事件监听器，负责产生事件</span></span><br><span class="line">        <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args);</span><br><span class="line">        <span class="comment">//  发布一个启动事件 ApplicationStartingEvent 告知上述所有监听器 </span></span><br><span class="line">        listeners.starting();</span><br><span class="line"></span><br><span class="line">        Collection exceptionReporters;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//  配置应用参数</span></span><br><span class="line">            <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">            <span class="comment">// 准备应用程序的环境</span></span><br><span class="line">            <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">            <span class="comment">// 配置禁用BeanInfo</span></span><br><span class="line">            <span class="built_in">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">            <span class="comment">// 打印 banner</span></span><br><span class="line">            <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment);</span><br><span class="line">            <span class="comment">// 使用策略模式创建应用上下文</span></span><br><span class="line">            context = <span class="built_in">this</span>.createApplicationContext();</span><br><span class="line">            <span class="comment">// 获取所有实现了 SpringBootExceptionReporter 接口的实例，并注册到 应用上下文中</span></span><br><span class="line">            exceptionReporters = <span class="built_in">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">            <span class="comment">// 准备程序上下文</span></span><br><span class="line">            <span class="built_in">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            <span class="comment">// 刷新应用程序上下文</span></span><br><span class="line">            <span class="built_in">this</span>.refreshContext(context);</span><br><span class="line">            <span class="comment">// 空实现</span></span><br><span class="line">            <span class="built_in">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            <span class="comment">// 记录启动消耗的时间</span></span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">                (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)).logStarted(<span class="built_in">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 发布 ApplicationStartedEvent 事件</span></span><br><span class="line">            listeners.started(context);</span><br><span class="line">            <span class="built_in">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">            <span class="built_in">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发布一个 ApplicationReadyEvent 事件</span></span><br><span class="line">            listeners.running(context);</span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">            <span class="built_in">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="SpringApplication-getRunListeners"><a href="#SpringApplication-getRunListeners" class="headerlink" title="SpringApplication#getRunListeners"></a>SpringApplication#getRunListeners</h5><p><code>springAllicationRunListener</code>是<code>SpringApplication</code>的<code>run</code>方法的监听器。<code>springAllicationRunListener</code>通过<code>springFactoriesLoader</code>加载，且必须声明一个公共的构造函数，接收<code>SpringApplication</code>实例和<code>string[]</code>参数，每次运行时都会创建一个实例。</p><p><code>SpringApplicationRunListener</code>提供了一系列方法，用户可以通过回调这些方法，在各个启动流程时，加入指定的处理逻辑：<br><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/springapplicationRunlistener-exp.png">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title function_">getRunListeners</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造clazz数组</span></span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="comment">// 调用SpringApplicationRunListeners构造方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationRunListeners</span>(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="built_in">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners(Log log, Collection&lt;? <span class="keyword">extends</span> <span class="title class_">SpringApplicationRunListener</span>&gt; listeners) &#123;</span><br><span class="line"><span class="built_in">this</span>.log = log;</span><br><span class="line"><span class="built_in">this</span>.listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(listeners);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpringApplicationRunListeners</code>构造方法的第二个参数是集合类型的<code>listeners</code>，通过调用<code>getSpringFactoriesInstances</code>获取。</p><h5 id="SpringApplicationRunListeners-getSpringFactoriesInstances"><a href="#SpringApplicationRunListeners-getSpringFactoriesInstances" class="headerlink" title="SpringApplicationRunListeners#getSpringFactoriesInstances"></a>SpringApplicationRunListeners#getSpringFactoriesInstances</h5><p><code>getSpringFactoriesInstances</code>是用来获取<code>factories</code>配置文件中的注册类，并进行实例化操作。</p><p><code>SpringApplicationRunListeners</code>通过<code>SpringFactoriesLoader</code>进行加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">    <span class="comment">//  获取 META-INF/spring.factories 中对应的配置</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    <span class="comment">// 创建 springFactory 实例</span></span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SpringApplicationRunListeners-createSpringFactoriesInstances"><a href="#SpringApplicationRunListeners-createSpringFactoriesInstances" class="headerlink" title="SpringApplicationRunListeners#createSpringFactoriesInstances"></a>SpringApplicationRunListeners#createSpringFactoriesInstances</h5><p>创建springFactories实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> &#123;</span><br><span class="line">List&lt;T&gt; instances = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(names.size());</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">Assert.isAssignable(type, instanceClass);</span><br><span class="line">                <span class="comment">// 获取有参构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">                <span class="comment">// 实例化 springFactory实例</span></span><br><span class="line"><span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">instances.add(instance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot instantiate &quot;</span> + type + <span class="string">&quot; : &quot;</span> + name, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EventPublishingRunListener"><a href="#EventPublishingRunListener" class="headerlink" title="EventPublishingRunListener"></a>EventPublishingRunListener</h4><p><code>EventPublishingRunListener</code>是<code>springboot</code>针对<code>springAllicationRunListener</code>接口内置的唯一实现。</p><p>它使用内置的<code>SimpleApplicationEventMulticaster </code>来广播在上下文刷新之前触发的事件。</p><p>默认情况下，<code>Spring Boot</code>在初始化过程中触发的事件也是交由<code>EventPublishingRunListener</code>来代理实现的。 其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EventPublishingRunListener</span><span class="params">(SpringApplication application, String[] args)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.application = application;</span><br><span class="line"><span class="built_in">this</span>.args = args;</span><br><span class="line"><span class="built_in">this</span>.initialMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line"><span class="built_in">this</span>.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>springboot</code>完成基本初始化之后，会遍历<code>springapplication</code>的所有<code>applicationListener</code>实例，并将它们与<code>SimpleApplicationEventMulticaster </code>进行关联，方便启动过程中将时间传递给所有监听器。</p><h4 id="spring事件推送原理"><a href="#spring事件推送原理" class="headerlink" title="spring事件推送原理"></a>spring事件推送原理</h4><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/springboot事件推送机制.png">  <h3 id="SpringApplication-prepareEnvironment"><a href="#SpringApplication-prepareEnvironment" class="headerlink" title="SpringApplication#prepareEnvironment"></a>SpringApplication#prepareEnvironment</h3><ol><li>加载并解析配置文件：在启动过程中，Spring会加载应用程序的配置文件，如application.properties或application.yml。prepareEnvironment方法负责加载这些配置文件，并将其解析为Spring框架内部可以理解的数据结构。</li><li>配置环境属性：prepareEnvironment方法还负责配置应用程序的环境属性。这些属性可以通过Environment对象访问，用于在应用程序的不同部分共享配置信息。例如，可以通过环境属性指定数据库连接的URL、用户名和密码等。</li><li>配置配置源：prepareEnvironment方法还负责配置Spring框架的配置源。配置源是指Spring框架用于获取配置信息的来源，可以是XML配置文件、注解或Java配置类等。通过配置源，Spring可以了解应用程序的组件定义、依赖关系和其他配置信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">ApplicationArguments applicationArguments)</span> &#123;</span><br><span class="line"><span class="comment">// // 按照主程序中定义的 应用类型 设置 应用环境</span></span><br><span class="line"><span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> getOrCreateEnvironment();</span><br><span class="line">    <span class="comment">// 将配置参数设置到 应用环境中</span></span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">    <span class="comment">// 发布 ApplicationEnvironmentPreparedEvent 事件，通知 ConfigFileApplicationListener.onApplicationEvent -&gt; postProcessEnvironment</span></span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">    <span class="comment">// 将 当前环境配置 与spring应用 相绑定</span></span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">    <span class="comment">// 检查是否需要转换环境 </span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">environment = <span class="keyword">new</span> <span class="title class_">EnvironmentConverter</span>(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将 environment中的属性源 赋给 springboot的配置属性源</span></span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConfigFileApplicationListener.onApplicationEvent -&gt; postProcessEnvironment</code>中加载<code>application.yml </code>配置 <code>addPropertySources</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigFileApplicationListener.onApplicationEvent -&gt; postProcessEnvironment</span><br></pre></td></tr></table></figure><h4 id="SpringApplication-deduceEnvironmentClass"><a href="#SpringApplication-deduceEnvironmentClass" class="headerlink" title="SpringApplication#deduceEnvironmentClass"></a>SpringApplication#deduceEnvironmentClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">StandardEnvironment</span>&gt; deduceEnvironmentClass() &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line"><span class="keyword">return</span> StandardServletEnvironment.class;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line"><span class="keyword">return</span> StandardReactiveWebEnvironment.class;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> StandardEnvironment.class;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SpringApplication-getSpringFactoriesInstances"><a href="#SpringApplication-getSpringFactoriesInstances" class="headerlink" title="SpringApplication#getSpringFactoriesInstances"></a>SpringApplication#getSpringFactoriesInstances</h4><p>用于从META-INF&#x2F;spring.factories文件中获取指定类型的所有实现类。在这里，它会获取所有实现了SpringBootExceptionReporter接口的类的实例。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-prepareContext"><a href="#SpringApplication-prepareContext" class="headerlink" title="SpringApplication#prepareContext"></a>SpringApplication#prepareContext</h3><ol><li>加载应用程序配置文件，包括 <code>application.properties</code> 和 <code>application.yml</code>。</li><li>注册应用程序事件监听器。</li><li>解析命令行参数并将其存储在应用程序参数对象中。</li><li>打印应用程序启动横幅信息。</li></ol><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/springApplication#prepareContext.png">  <p><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Users\User\AppData\Local\Temp\1696985455028.png" alt="1696985455028"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><br><span class="line"><span class="params">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;</span><br><span class="line">    </span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">    <span class="comment">// 调用ApplicationContextInitializer#initialize</span></span><br><span class="line">applyInitializers(context);</span><br><span class="line">    <span class="comment">// 发布 ApplicationContextInitializedEvent 事件</span></span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 ConfigurableListableBeanFactory 并注册一个 springApplicationArguments bean</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) &#123;</span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// bean 重名时是否允许重写</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//  根据配置确定是否要填充懒加载的 BeanFactoryPostProcessor</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">LazyInitializationBeanFactoryPostProcessor</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取启动类</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// 发布 ApplicationPreparedEvent 事件</span></span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SpringApplication-load"><a href="#SpringApplication-load" class="headerlink" title="SpringApplication#load"></a>SpringApplication#load</h4><p>加载<code>beans</code>到应用上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load beans into the application context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the context to load beans into</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources the sources to load</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 初始化 BeanDefinitionLoader </span></span><br><span class="line"><span class="type">BeanDefinitionLoader</span> <span class="variable">loader</span> <span class="operator">=</span> createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">        <span class="comment">// 为潜在的 reader/scanner 配置 BeanNameGenerator</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanNameGenerator != <span class="literal">null</span>) &#123;</span><br><span class="line">loader.setBeanNameGenerator(<span class="built_in">this</span>.beanNameGenerator);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 为潜在的 reader/scanner 配置 ResourceLoader</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">loader.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 为 BeanDefinitionLoader （潜在的 reader/scanner）配置 环境</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;</span><br><span class="line">loader.setEnvironment(<span class="built_in">this</span>.environment);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 加载启动类，将启动类注入到容器中， [可以继续往下挖]</span></span><br><span class="line">loader.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Users\User\AppData\Local\Temp\1696984777872.png" alt="1696984777872"></p><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/ConfigurableListableBeanFactory类图.png">  <h5 id="BeanDefinitionLoader-loader-load"><a href="#BeanDefinitionLoader-loader-load" class="headerlink" title="BeanDefinitionLoader#loader.load#"></a>BeanDefinitionLoader#loader.load#</h5><p>根据不同的源类型加载配置文件 </p><ul><li>如果源对象是 Class 类型，则调用 load(Class&lt;?&gt; clazz) 方法加载配置文件。</li><li>如果源对象是 Resource 类型，则调用 load(Resource resource) 方法加载配置文件。</li><li>如果源对象是 Package 类型，则调用 load(Package pkg) 方法加载配置文件。</li><li>如果源对象是 CharSequence 类型，则调用 load(CharSequence content) 方法加载配置文件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">load</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Class&lt;?&gt;) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Resource) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Resource) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Package) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Package) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line"><span class="keyword">return</span> load((CharSequence) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid source type &quot;</span> + source.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">load</span><span class="params">(Class&lt;?&gt; source)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) &#123;</span><br><span class="line"><span class="comment">// Any GroovyLoaders added in beans&#123;&#125; DSL can contribute beans here</span></span><br><span class="line"><span class="type">GroovyBeanDefinitionSource</span> <span class="variable">loader</span> <span class="operator">=</span> BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</span><br><span class="line">load(loader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEligible(source)) &#123;</span><br><span class="line"><span class="built_in">this</span>.annotatedReader.register(source);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register one or more component classes to be processed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Calls to &#123;<span class="doctag">@code</span> register&#125; are idempotent; adding the same</span></span><br><span class="line"><span class="comment"> * component class more than once has no additional effect.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> componentClasses one or more component classes,</span></span><br><span class="line"><span class="comment"> * e.g. &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">registerBean(componentClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AnnotatedBeanDefinitionReader-doRegisterBean"><a href="#AnnotatedBeanDefinitionReader-doRegisterBean" class="headerlink" title="AnnotatedBeanDefinitionReader#doRegisterBean#"></a>AnnotatedBeanDefinitionReader#doRegisterBean#</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; void doRegisterBean(Class&lt;T&gt; beanClass, @Nullable String name,</span><br><span class="line">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span><br><span class="line">@Nullable BeanDefinitionCustomizer[] customizers) &#123;</span><br><span class="line"></span><br><span class="line">AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abd.setInstanceSupplier(supplier);</span><br><span class="line">ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">if (qualifiers != null) &#123;</span><br><span class="line">for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">if (Primary.class == qualifier) &#123;</span><br><span class="line">abd.setPrimary(true);</span><br><span class="line">&#125;</span><br><span class="line">else if (Lazy.class == qualifier) &#123;</span><br><span class="line">abd.setLazyInit(true);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (customizers != null) &#123;</span><br><span class="line">for (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">customizer.customize(abd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-refreshContext"><a href="#SpringApplication-refreshContext" class="headerlink" title="SpringApplication#refreshContext"></a>SpringApplication#refreshContext</h3><p>重新加载所有的配置类，并重新注册所有的组件，从而使得应用程序上下文中的组件状态与最新的代码保持一致 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    refresh((ApplicationContext) context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册 关闭 钩子</span></span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">            <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SpringApplication-refresh"><a href="#SpringApplication-refresh" class="headerlink" title="SpringApplication#refresh#"></a>SpringApplication#refresh#</h4><ol><li>创建并初始化 BeanFactory：首先，它会创建一个 BeanFactory 对象，用于管理和创建应用程序中的 Bean。</li><li>加载 Bean 定义：接下来，它会加载应用程序中定义的 Bean，包括通过注解、XML 配置文件等方式定义的 Bean。</li><li>实例化和初始化 Bean：然后，它会实例化和初始化所有的 Bean，包括依赖注入、AOP 代理等操作。</li><li>处理 Bean 生命周期回调：在 Bean 实例化和初始化完成后，<code>refresh</code> 方法会调用各个 Bean 的生命周期回调方法，例如 <code>@PostConstruct</code> 注解标注的方法。</li><li>注册 Bean 后置处理器：<code>refresh</code> 方法还会注册 Bean 后置处理器，用于在 Bean 初始化前后进行一些额外的处理操作。</li></ol><p>通过调用 <code>SpringApplication#refresh</code> 方法，应用程序上下文将完成初始化和刷新，所有的 Bean 将被正确创建和配置，应用程序将进入可用状态，可以响应外部请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);</span><br><span class="line">    refresh((ConfigurableApplicationContext) applicationContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    applicationContext.refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);</span><br><span class="line">refresh((ConfigurableApplicationContext) applicationContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>refresh</code>是<code>ConfigurableApplicationContext</code>中定义的接口，默认有如下实现</p><p><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/Users\User\AppData\Local\Temp\1697068082459.png" alt="1697068082459"></p><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/SpringApplication_refresh.png">  <h4 id="AbstractApplicationContext-refresh"><a href="#AbstractApplicationContext-refresh" class="headerlink" title="AbstractApplicationContext#refresh"></a>AbstractApplicationContext#refresh</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line"><span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="SpringApplication-callRunners"><a href="#SpringApplication-callRunners" class="headerlink" title="SpringApplication#callRunners"></a>SpringApplication#callRunners</h5><p><code>spring callRunners(context, applicationArguments)</code> 是 Spring Boot 中的一个方法，用于执行在应用程序启动时需要运行的 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 接口的实现类。</p><p>在 Spring Boot 应用程序启动时，可以通过实现 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口来定义一些需要在应用程序启动后立即执行的逻辑。这些逻辑可以包括初始化数据、加载配置、启动定时任务等。</p><p><code>callRunners(context, applicationArguments)</code> 方法会在 Spring Boot 应用程序启动时被调用，它会获取所有实现了 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 接口的 Bean，并按照优先级顺序依次执行它们的 <code>run</code> 方法。通过调用这些方法，可以在应用程序启动时执行一些自定义的逻辑。</p><p><code>context</code> 参数是 Spring 应用程序的上下文，它包含了应用程序中所有的 Bean。<code>applicationArguments</code> 参数是应用程序的命令行参数，可以通过它获取命令行传递的参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> &#123;</span><br><span class="line">List&lt;Object&gt; runners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line"><span class="keyword">for</span> (Object runner : <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(runners)) &#123;</span><br><span class="line"><span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">callRunner((ApplicationRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">callRunner((CommandLineRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="environment的区别"><a href="#environment的区别" class="headerlink" title="environment的区别"></a>environment的区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">getOrCreateEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.environment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardServletEnvironment</span>();</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardReactiveWebEnvironment</span>();</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.kancloud.cn/luoyoub/spring-note/2243936">1. spring三级缓存</a><br><a href="https://www.cnblogs.com/ZhuChangwu/p/11755973.html">2. springbean装配过程</a><br><a href="https://gorden5566.com/post/1047.html">3. Spring 的 InstantiationAware 后处理器</a><br><a href="https://blog.csdn.net/lx1315998513/article/details/120641124">4. 为什么JDK动态代理只能代理接口，不能直接代理类？CGlib为什么可以代理类？</a><br><a href="https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter11/springboot.html">5. SpringBoot的启动流程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;主程序入口&quot;&gt;&lt;a href=&quot;#主程序入口&quot; class=&quot;headerlink&quot; title=&quot;主程序入口&quot;&gt;&lt;/a&gt;主程序入口&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这里补充 入口 携带的注解说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure cla</summary>
      
    
    
    
    
    <category term="java" scheme="https://mqrayblog.cn/tags/java/"/>
    
    <category term="spring" scheme="https://mqrayblog.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>springboot源码之启动流程1</title>
    <link href="https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/"/>
    <id>https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/</id>
    <published>2023-10-10T08:05:35.000Z</published>
    <updated>2023-10-24T04:46:09.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主程序入口"><a href="#主程序入口" class="headerlink" title="主程序入口"></a>主程序入口</h3><blockquote><p>这里补充 入口 携带的注解说明</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotificationApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(NotificationApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.SpringApplication</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line"><span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line"><span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WebApplicationType-deduceFromClasspath"><a href="#WebApplicationType-deduceFromClasspath" class="headerlink" title="WebApplicationType#deduceFromClasspath"></a>WebApplicationType#deduceFromClasspath</h5><p>这段代码是用于从类路径中推断出静态的Web应用程序类型的。它通过检查类路径中是否存在特定的类来确定应用程序类型。</p><p>首先，它检查是否存在<code>WEBFLUX_INDICATOR_CLASS</code>类，并且不存在<code>WEBMVC_INDICATOR_CLASS</code>和<code>JERSEY_INDICATOR_CLASS</code>类。如果满足这个条件，那么应用程序类型被判断为<code>WebApplicationType.REACTIVE</code>，表示是一个基于响应式编程模型的Web应用程序。</p><p>接下来，它遍历<code>SERVLET_INDICATOR_CLASSES</code>列表中的类名。如果在类路径中找不到其中任何一个类，那么应用程序类型被判断为<code>WebApplicationType.NONE</code>，表示不是一个基于Servlet的Web应用程序。</p><p>如果以上两个条件都不满足，那么应用程序类型被判断为<code>WebApplicationType.SERVLET</code>，表示是一个基于Servlet的Web应用程序。</p><p><code>WebApplicationType</code>是一个枚举类型，用于表示Web应用程序的类型，包括<code>NONE</code>、<code>SERVLET</code>和<code>REACTIVE</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> WebApplicationType <span class="title function_">deduceFromClasspath</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="literal">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="literal">null</span>)</span><br><span class="line">&amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication#run"></a>SpringApplication#run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.SpringApplication</span><br><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="comment">// 创建应用上下文</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 异常收集，报告启动异常</span></span><br><span class="line">        Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// 设置为headless模式</span></span><br><span class="line">        <span class="built_in">this</span>.configureHeadlessProperty();</span><br><span class="line">        <span class="comment">// 获取事件监听器，负责产生事件</span></span><br><span class="line">        <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args);</span><br><span class="line">        <span class="comment">//  发布一个启动事件 ApplicationStartingEvent 告知上述所有监听器 </span></span><br><span class="line">        listeners.starting();</span><br><span class="line"></span><br><span class="line">        Collection exceptionReporters;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//  配置应用参数</span></span><br><span class="line">            <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">            <span class="comment">// 准备应用程序的环境</span></span><br><span class="line">            <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">            <span class="comment">// 配置禁用BeanInfo</span></span><br><span class="line">            <span class="built_in">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">            <span class="comment">// 打印 banner</span></span><br><span class="line">            <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment);</span><br><span class="line">            <span class="comment">// 使用策略模式创建应用上下文</span></span><br><span class="line">            context = <span class="built_in">this</span>.createApplicationContext();</span><br><span class="line">            <span class="comment">// 获取所有实现了 SpringBootExceptionReporter 接口的实例，并注册到 应用上下文中</span></span><br><span class="line">            exceptionReporters = <span class="built_in">this</span>.getSpringFactoriesInstances(SpringBootExceptionReporter.class, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">            <span class="comment">// 准备程序上下文</span></span><br><span class="line">            <span class="built_in">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">            <span class="comment">// 刷新应用程序上下文</span></span><br><span class="line">            <span class="built_in">this</span>.refreshContext(context);</span><br><span class="line">            <span class="comment">// 空实现</span></span><br><span class="line">            <span class="built_in">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">            <span class="comment">// 记录启动消耗的时间</span></span><br><span class="line">            stopWatch.stop();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">                (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)).logStarted(<span class="built_in">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 发布 ApplicationStartedEvent 事件</span></span><br><span class="line">            listeners.started(context);</span><br><span class="line">            <span class="built_in">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">            <span class="built_in">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发布一个 ApplicationReadyEvent 事件</span></span><br><span class="line">            listeners.running(context);</span><br><span class="line">            <span class="keyword">return</span> context;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">            <span class="built_in">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="SpringApplication-getRunListeners"><a href="#SpringApplication-getRunListeners" class="headerlink" title="SpringApplication#getRunListeners"></a>SpringApplication#getRunListeners</h5><p><code>springAllicationRunListener</code>是<code>SpringApplication</code>的<code>run</code>方法的监听器。<code>springAllicationRunListener</code>通过<code>springFactoriesLoader</code>加载，且必须声明一个公共的构造函数，接收<code>SpringApplication</code>实例和<code>string[]</code>参数，每次运行时都会创建一个实例。</p><p><code>SpringApplicationRunListener</code>提供了一系列方法，用户可以通过回调这些方法，在各个启动流程时，加入指定的处理逻辑：<br><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/springapplicationRunlistener-exp.png">  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title function_">getRunListeners</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造clazz数组</span></span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="comment">// 调用SpringApplicationRunListeners构造方法</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationRunListeners</span>(logger,</span><br><span class="line">getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="built_in">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringApplicationRunListeners(Log log, Collection&lt;? <span class="keyword">extends</span> <span class="title class_">SpringApplicationRunListener</span>&gt; listeners) &#123;</span><br><span class="line"><span class="built_in">this</span>.log = log;</span><br><span class="line"><span class="built_in">this</span>.listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(listeners);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpringApplicationRunListeners</code>构造方法的第二个参数是集合类型的<code>listeners</code>，通过调用<code>getSpringFactoriesInstances</code>获取。</p><h5 id="SpringApplicationRunListeners-getSpringFactoriesInstances"><a href="#SpringApplicationRunListeners-getSpringFactoriesInstances" class="headerlink" title="SpringApplicationRunListeners#getSpringFactoriesInstances"></a>SpringApplicationRunListeners#getSpringFactoriesInstances</h5><p><code>getSpringFactoriesInstances</code>是用来获取<code>factories</code>配置文件中的注册类，并进行实例化操作。</p><p><code>SpringApplicationRunListeners</code>通过<code>SpringFactoriesLoader</code>进行加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">    <span class="comment">//  获取 META-INF/spring.factories 中对应的配置</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    <span class="comment">// 创建 springFactory 实例</span></span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SpringApplicationRunListeners-createSpringFactoriesInstances"><a href="#SpringApplicationRunListeners-createSpringFactoriesInstances" class="headerlink" title="SpringApplicationRunListeners#createSpringFactoriesInstances"></a>SpringApplicationRunListeners#createSpringFactoriesInstances</h5><p>创建springFactories实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes,</span></span><br><span class="line"><span class="params">ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</span> &#123;</span><br><span class="line">List&lt;T&gt; instances = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(names.size());</span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">Assert.isAssignable(type, instanceClass);</span><br><span class="line">                <span class="comment">// 获取有参构造器</span></span><br><span class="line">Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">                <span class="comment">// 实例化 springFactory实例</span></span><br><span class="line"><span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">instances.add(instance);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Cannot instantiate &quot;</span> + type + <span class="string">&quot; : &quot;</span> + name, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EventPublishingRunListener"><a href="#EventPublishingRunListener" class="headerlink" title="EventPublishingRunListener"></a>EventPublishingRunListener</h4><p><code>EventPublishingRunListener</code>是<code>springboot</code>针对<code>springAllicationRunListener</code>接口内置的唯一实现。</p><p>它使用内置的<code>SimpleApplicationEventMulticaster </code>来广播在上下文刷新之前触发的事件。</p><p>默认情况下，<code>Spring Boot</code>在初始化过程中触发的事件也是交由<code>EventPublishingRunListener</code>来代理实现的。 其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EventPublishingRunListener</span><span class="params">(SpringApplication application, String[] args)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.application = application;</span><br><span class="line"><span class="built_in">this</span>.args = args;</span><br><span class="line"><span class="built_in">this</span>.initialMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line"><span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line"><span class="built_in">this</span>.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>springboot</code>完成基本初始化之后，会遍历<code>springapplication</code>的所有<code>applicationListener</code>实例，并将它们与<code>SimpleApplicationEventMulticaster </code>进行关联，方便启动过程中将时间传递给所有监听器。</p><h4 id="spring事件推送原理"><a href="#spring事件推送原理" class="headerlink" title="spring事件推送原理"></a>spring事件推送原理</h4><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/springboot事件推送机制.png">  <h3 id="SpringApplication-prepareEnvironment"><a href="#SpringApplication-prepareEnvironment" class="headerlink" title="SpringApplication#prepareEnvironment"></a>SpringApplication#prepareEnvironment</h3><ol><li>加载并解析配置文件：在启动过程中，Spring会加载应用程序的配置文件，如application.properties或application.yml。prepareEnvironment方法负责加载这些配置文件，并将其解析为Spring框架内部可以理解的数据结构。</li><li>配置环境属性：prepareEnvironment方法还负责配置应用程序的环境属性。这些属性可以通过Environment对象访问，用于在应用程序的不同部分共享配置信息。例如，可以通过环境属性指定数据库连接的URL、用户名和密码等。</li><li>配置配置源：prepareEnvironment方法还负责配置Spring框架的配置源。配置源是指Spring框架用于获取配置信息的来源，可以是XML配置文件、注解或Java配置类等。通过配置源，Spring可以了解应用程序的组件定义、依赖关系和其他配置信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">ApplicationArguments applicationArguments)</span> &#123;</span><br><span class="line"><span class="comment">// // 按照主程序中定义的 应用类型 设置 应用环境</span></span><br><span class="line"><span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> getOrCreateEnvironment();</span><br><span class="line">    <span class="comment">// 将配置参数设置到 应用环境中</span></span><br><span class="line">configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line">    <span class="comment">// 发布 ApplicationEnvironmentPreparedEvent 事件，通知 ConfigFileApplicationListener.onApplicationEvent -&gt; postProcessEnvironment</span></span><br><span class="line">listeners.environmentPrepared(environment);</span><br><span class="line">    <span class="comment">// 将 当前环境配置 与spring应用 相绑定</span></span><br><span class="line">bindToSpringApplication(environment);</span><br><span class="line">    <span class="comment">// 检查是否需要转换环境 </span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">environment = <span class="keyword">new</span> <span class="title class_">EnvironmentConverter</span>(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">deduceEnvironmentClass());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将 environment中的属性源 赋给 springboot的配置属性源</span></span><br><span class="line">ConfigurationPropertySources.attach(environment);</span><br><span class="line"><span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConfigFileApplicationListener.onApplicationEvent -&gt; postProcessEnvironment</code>中加载<code>application.yml </code>配置 <code>addPropertySources</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConfigFileApplicationListener.onApplicationEvent -&gt; postProcessEnvironment</span><br></pre></td></tr></table></figure><h4 id="SpringApplication-deduceEnvironmentClass"><a href="#SpringApplication-deduceEnvironmentClass" class="headerlink" title="SpringApplication#deduceEnvironmentClass"></a>SpringApplication#deduceEnvironmentClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">StandardEnvironment</span>&gt; deduceEnvironmentClass() &#123;</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line"><span class="keyword">return</span> StandardServletEnvironment.class;</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line"><span class="keyword">return</span> StandardReactiveWebEnvironment.class;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> StandardEnvironment.class;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SpringApplication-getSpringFactoriesInstances"><a href="#SpringApplication-getSpringFactoriesInstances" class="headerlink" title="SpringApplication#getSpringFactoriesInstances"></a>SpringApplication#getSpringFactoriesInstances</h4><p>用于从META-INF&#x2F;spring.factories文件中获取指定类型的所有实现类。在这里，它会获取所有实现了SpringBootExceptionReporter接口的类的实例。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line"><span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-prepareContext"><a href="#SpringApplication-prepareContext" class="headerlink" title="SpringApplication#prepareContext"></a>SpringApplication#prepareContext</h3><ol><li>加载应用程序配置文件，包括 <code>application.properties</code> 和 <code>application.yml</code>。</li><li>注册应用程序事件监听器。</li><li>解析命令行参数并将其存储在应用程序参数对象中。</li><li>打印应用程序启动横幅信息。</li></ol><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/springApplication_prepareContext.png">  <p><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/Users\User\AppData\Local\Temp\1696985455028.png" alt="1696985455028"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><br><span class="line"><span class="params">SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;</span><br><span class="line">    </span><br><span class="line">context.setEnvironment(environment);</span><br><span class="line">postProcessApplicationContext(context);</span><br><span class="line">    <span class="comment">// 调用ApplicationContextInitializer#initialize</span></span><br><span class="line">applyInitializers(context);</span><br><span class="line">    <span class="comment">// 发布 ApplicationContextInitializedEvent 事件</span></span><br><span class="line">listeners.contextPrepared(context);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">logStartupProfileInfo(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 ConfigurableListableBeanFactory 并注册一个 springApplicationArguments bean</span></span><br><span class="line"><span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line"><span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) &#123;</span><br><span class="line">beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// bean 重名时是否允许重写</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">.setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//  根据配置确定是否要填充懒加载的 BeanFactoryPostProcessor</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.lazyInitialization) &#123;</span><br><span class="line">context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">LazyInitializationBeanFactoryPostProcessor</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取启动类</span></span><br><span class="line">Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// 发布 ApplicationPreparedEvent 事件</span></span><br><span class="line">listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SpringApplication-load"><a href="#SpringApplication-load" class="headerlink" title="SpringApplication#load"></a>SpringApplication#load</h4><p>加载<code>beans</code>到应用上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load beans into the application context.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the context to load beans into</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sources the sources to load</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Loading source &quot;</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 初始化 BeanDefinitionLoader </span></span><br><span class="line"><span class="type">BeanDefinitionLoader</span> <span class="variable">loader</span> <span class="operator">=</span> createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">        <span class="comment">// 为潜在的 reader/scanner 配置 BeanNameGenerator</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beanNameGenerator != <span class="literal">null</span>) &#123;</span><br><span class="line">loader.setBeanNameGenerator(<span class="built_in">this</span>.beanNameGenerator);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 为潜在的 reader/scanner 配置 ResourceLoader</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">loader.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 为 BeanDefinitionLoader （潜在的 reader/scanner）配置 环境</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;</span><br><span class="line">loader.setEnvironment(<span class="built_in">this</span>.environment);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 加载启动类，将启动类注入到容器中， [可以继续往下挖]</span></span><br><span class="line">loader.load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/Users\User\AppData\Local\Temp\1696984777872.png" alt="1696984777872"></p><img src="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/ConfigurableListableBeanFactory类图.png">  <h5 id="BeanDefinitionLoader-loader-load"><a href="#BeanDefinitionLoader-loader-load" class="headerlink" title="BeanDefinitionLoader#loader.load#"></a>BeanDefinitionLoader#loader.load#</h5><p>根据不同的源类型加载配置文件 </p><ul><li>如果源对象是 Class 类型，则调用 load(Class&lt;?&gt; clazz) 方法加载配置文件。</li><li>如果源对象是 Resource 类型，则调用 load(Resource resource) 方法加载配置文件。</li><li>如果源对象是 Package 类型，则调用 load(Package pkg) 方法加载配置文件。</li><li>如果源对象是 CharSequence 类型，则调用 load(CharSequence content) 方法加载配置文件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">load</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">Assert.notNull(source, <span class="string">&quot;Source must not be null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Class&lt;?&gt;) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Resource) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Resource) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> Package) &#123;</span><br><span class="line"><span class="keyword">return</span> load((Package) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (source <span class="keyword">instanceof</span> CharSequence) &#123;</span><br><span class="line"><span class="keyword">return</span> load((CharSequence) source);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid source type &quot;</span> + source.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">load</span><span class="params">(Class&lt;?&gt; source)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (isGroovyPresent() &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) &#123;</span><br><span class="line"><span class="comment">// Any GroovyLoaders added in beans&#123;&#125; DSL can contribute beans here</span></span><br><span class="line"><span class="type">GroovyBeanDefinitionSource</span> <span class="variable">loader</span> <span class="operator">=</span> BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class);</span><br><span class="line">load(loader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEligible(source)) &#123;</span><br><span class="line"><span class="built_in">this</span>.annotatedReader.register(source);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Register one or more component classes to be processed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Calls to &#123;<span class="doctag">@code</span> register&#125; are idempotent; adding the same</span></span><br><span class="line"><span class="comment"> * component class more than once has no additional effect.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> componentClasses one or more component classes,</span></span><br><span class="line"><span class="comment"> * e.g. &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; classes</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">registerBean(componentClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="AnnotatedBeanDefinitionReader-doRegisterBean"><a href="#AnnotatedBeanDefinitionReader-doRegisterBean" class="headerlink" title="AnnotatedBeanDefinitionReader#doRegisterBean"></a>AnnotatedBeanDefinitionReader#doRegisterBean</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private &lt;T&gt; void doRegisterBean(Class&lt;T&gt; beanClass, @Nullable String name,</span><br><span class="line">@Nullable Class&lt;? extends Annotation&gt;[] qualifiers, @Nullable Supplier&lt;T&gt; supplier,</span><br><span class="line">@Nullable BeanDefinitionCustomizer[] customizers) &#123;</span><br><span class="line"></span><br><span class="line">AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);</span><br><span class="line">if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abd.setInstanceSupplier(supplier);</span><br><span class="line">ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">String beanName = (name != null ? name : this.beanNameGenerator.generateBeanName(abd, this.registry));</span><br><span class="line"></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line">if (qualifiers != null) &#123;</span><br><span class="line">for (Class&lt;? extends Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line">if (Primary.class == qualifier) &#123;</span><br><span class="line">abd.setPrimary(true);</span><br><span class="line">&#125;</span><br><span class="line">else if (Lazy.class == qualifier) &#123;</span><br><span class="line">abd.setLazyInit(true);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">abd.addQualifier(new AutowireCandidateQualifier(qualifier));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (customizers != null) &#123;</span><br><span class="line">for (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">customizer.customize(abd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringApplication-refreshContext"><a href="#SpringApplication-refreshContext" class="headerlink" title="SpringApplication#refreshContext"></a>SpringApplication#refreshContext</h3><ol><li>创建并初始化 BeanFactory：首先，它会创建一个 BeanFactory 对象，用于管理和创建应用程序中的 Bean。</li><li>加载 Bean 定义：接下来，它会加载应用程序中定义的 Bean，包括通过注解、XML 配置文件等方式定义的 Bean。</li><li>实例化和初始化 Bean：然后，它会实例化和初始化所有的 Bean，包括依赖注入、AOP 代理等操作。</li><li>处理 Bean 生命周期回调：在 Bean 实例化和初始化完成后，<code>refresh</code> 方法会调用各个 Bean 的生命周期回调方法，例如 <code>@PostConstruct</code> 注解标注的方法。</li><li>注册 Bean 后置处理器：<code>refresh</code> 方法还会注册 Bean 后置处理器，用于在 Bean 初始化前后进行一些额外的处理操作。</li></ol><p>通过调用 <code>SpringApplication#refresh</code> 方法，应用程序上下文将完成初始化和刷新，所有的 Bean 将被正确创建和配置，应用程序将进入可用状态，可以响应外部请求。</p><p>具体内容我放到另外一篇博文中了<a href="https://mqrayblog.cn/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/">springboot源码之启动流程2</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    refresh((ApplicationContext) context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.registerShutdownHook) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注册 关闭 钩子</span></span><br><span class="line">            context.registerShutdownHook();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AccessControlException ex) &#123;</span><br><span class="line">            <span class="comment">// Not allowed in some environments.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SpringApplication-callRunners"><a href="#SpringApplication-callRunners" class="headerlink" title="SpringApplication#callRunners"></a>SpringApplication#callRunners</h5><p><code>spring callRunners(context, applicationArguments)</code> 是 Spring Boot 中的一个方法，用于执行在应用程序启动时需要运行的 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 接口的实现类。</p><p>在 Spring Boot 应用程序启动时，可以通过实现 <code>ApplicationRunner</code> 或 <code>CommandLineRunner</code> 接口来定义一些需要在应用程序启动后立即执行的逻辑。这些逻辑可以包括初始化数据、加载配置、启动定时任务等。</p><p><code>callRunners(context, applicationArguments)</code> 方法会在 Spring Boot 应用程序启动时被调用，它会获取所有实现了 <code>ApplicationRunner</code> 和 <code>CommandLineRunner</code> 接口的 Bean，并按照优先级顺序依次执行它们的 <code>run</code> 方法。通过调用这些方法，可以在应用程序启动时执行一些自定义的逻辑。</p><p><code>context</code> 参数是 Spring 应用程序的上下文，它包含了应用程序中所有的 Bean。<code>applicationArguments</code> 参数是应用程序的命令行参数，可以通过它获取命令行传递的参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> &#123;</span><br><span class="line">List&lt;Object&gt; runners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line"><span class="keyword">for</span> (Object runner : <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(runners)) &#123;</span><br><span class="line"><span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) &#123;</span><br><span class="line">callRunner((ApplicationRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) &#123;</span><br><span class="line">callRunner((CommandLineRunner) runner, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="environment的区别"><a href="#environment的区别" class="headerlink" title="environment的区别"></a>environment的区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">getOrCreateEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.environment != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.environment;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">this</span>.webApplicationType) &#123;</span><br><span class="line"><span class="keyword">case</span> SERVLET:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardServletEnvironment</span>();</span><br><span class="line"><span class="keyword">case</span> REACTIVE:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardReactiveWebEnvironment</span>();</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line"><span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.kancloud.cn/luoyoub/spring-note/2243936">1. spring三级缓存</a><br><a href="https://www.cnblogs.com/ZhuChangwu/p/11755973.html">2. springbean装配过程</a><br><a href="https://gorden5566.com/post/1047.html">3. Spring 的 InstantiationAware 后处理器</a><br><a href="https://blog.csdn.net/lx1315998513/article/details/120641124">4. 为什么JDK动态代理只能代理接口，不能直接代理类？CGlib为什么可以代理类？</a><br><a href="https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter11/springboot.html">5. SpringBoot的启动流程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;主程序入口&quot;&gt;&lt;a href=&quot;#主程序入口&quot; class=&quot;headerlink&quot; title=&quot;主程序入口&quot;&gt;&lt;/a&gt;主程序入口&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;这里补充 入口 携带的注解说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure cla</summary>
      
    
    
    
    
    <category term="java" scheme="https://mqrayblog.cn/tags/java/"/>
    
    <category term="spring" scheme="https://mqrayblog.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java之springbean初始化</title>
    <link href="https://mqrayblog.cn/2023/10/08/java%E4%B9%8Bspringbean%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://mqrayblog.cn/2023/10/08/java%E4%B9%8Bspringbean%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2023-10-08T00:56:01.000Z</published>
    <updated>2023-10-24T04:46:09.776Z</updated>
    
    <content type="html"><![CDATA[<h4 id="spring三级缓存"><a href="#spring三级缓存" class="headerlink" title="spring三级缓存"></a>spring三级缓存</h4><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.kancloud.cn/luoyoub/spring-note/2243936">1. spring三级缓存</a><br><a href="https://www.cnblogs.com/ZhuChangwu/p/11755973.html">2. springbean装配过程</a><br><a href="https://gorden5566.com/post/1047.html">3. Spring 的 InstantiationAware 后处理器</a><br><a href="https://blog.csdn.net/lx1315998513/article/details/120641124">4. 为什么JDK动态代理只能代理接口，不能直接代理类？CGlib为什么可以代理类？</a><br><a href="https://fhfirehuo.github.io/Attacking-Java-Rookie/Chapter11/springboot.html">5. SpringBoot的启动流程</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;spring三级缓存&quot;&gt;&lt;a href=&quot;#spring三级缓存&quot; class=&quot;headerlink&quot; title=&quot;spring三级缓存&quot;&gt;&lt;/a&gt;spring三级缓存&lt;/h4&gt;&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="spring" scheme="https://mqrayblog.cn/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>工作之工程术语</title>
    <link href="https://mqrayblog.cn/2023/09/22/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD/"/>
    <id>https://mqrayblog.cn/2023/09/22/%E5%B7%A5%E4%BD%9C%E4%B9%8B%E5%B7%A5%E7%A8%8B%E6%9C%AF%E8%AF%AD/</id>
    <published>2023-09-22T02:23:32.000Z</published>
    <updated>2023-10-24T04:46:09.800Z</updated>
    
    <content type="html"><![CDATA[<p>产品线沿用了华为的管理方案，一堆主管发邮件各种专有名词，根本看不懂，特此记录：<br><code>RMT</code>：需求管理团队<br><code>RAT</code>: 需求分析团队<br><code>TSE</code>：测试系统工程师<br><code>DFX</code>: Design forX(面向产品生命周期各环节的设计)的缩写</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.ipdwiki.com/?cxkf/2251.html">1. 解读华为研发6:需求管理组织2-RMT&#x2F;RAT</a><br><a href="https://www.ipdwiki.com/?cpzhl/1129.html">2. DFX项目管理及集成产品开发（IPD）模式</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;产品线沿用了华为的管理方案，一堆主管发邮件各种专有名词，根本看不懂，特此记录：&lt;br&gt;&lt;code&gt;RMT&lt;/code&gt;：需求管理团队&lt;br&gt;&lt;code&gt;RAT&lt;/code&gt;: 需求分析团队&lt;br&gt;&lt;code&gt;TSE&lt;/code&gt;：测试系统工程师&lt;br&gt;&lt;code&gt;DFX&lt;/</summary>
      
    
    
    
    
    <category term="sth" scheme="https://mqrayblog.cn/tags/sth/"/>
    
  </entry>
  
  <entry>
    <title>java之jprofile分析内存占用</title>
    <link href="https://mqrayblog.cn/2023/09/21/java%E4%B9%8Bjprofile%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/"/>
    <id>https://mqrayblog.cn/2023/09/21/java%E4%B9%8Bjprofile%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/</id>
    <published>2023-09-21T07:53:18.000Z</published>
    <updated>2023-10-24T04:46:09.776Z</updated>
    
    <content type="html"><![CDATA[<p>有点舒服，假借内存分析之名学习一波java内存优化</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/kongzhongqijing/articles/3621163.html">1. java命令–jmap命令使用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有点舒服，假借内存分析之名学习一波java内存优化&lt;/p&gt;
&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kong</summary>
      
    
    
    
    
    <category term="java" scheme="https://mqrayblog.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>redis之排障</title>
    <link href="https://mqrayblog.cn/2023/09/20/redis%E4%B9%8B%E6%8E%92%E9%9A%9C/"/>
    <id>https://mqrayblog.cn/2023/09/20/redis%E4%B9%8B%E6%8E%92%E9%9A%9C/</id>
    <published>2023-09-20T13:28:31.000Z</published>
    <updated>2023-10-24T04:46:09.788Z</updated>
    
    <content type="html"><![CDATA[<p>扩容环境频繁出现oom，最终定位到两个原因：</p><ol><li>数据业务写入太多</li><li>bgsave导致</li></ol><p>最近有点忙，先占坑，后面梳理完再写</p><p>什么时候选择rdb，什么时候选择 aof<br>同步策略<br>优先级<br>键过期策略<br>键驱逐策略</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://segmentfault.com/a/1190000043845458">1. redis.conf 7.0 配置和原理全解，生产王者必备</a><br><a href="https://cloud.tencent.com/developer/article/2205116">2. redis.conf 7.0 配置和原理全解，生产王者必备</a><br><a href="https://www.cnblogs.com/wshenjin/p/11431378.html">3. https://www.cnblogs.com/wshenjin/p/11431378.html</a><br><a href="https://redis.io/commands/info/">4. https://redis.io/commands/info/</a><br><a href="https://redis.io/docs/reference/eviction/">5. 键过期策略</a><br><a href="https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/">6. bgsave导致oom</a><br><a href="https://blog.csdn.net/ldw201510803006/article/details/126093439">7. https://blog.csdn.net/ldw201510803006/article/details/126093439</a><br><a href="https://cloud.tencent.com/developer/article/1606110">8. https://cloud.tencent.com/developer/article/1606110</a><br><a href="https://github.com/redis/redis/issues/7717">9. https://github.com/redis/redis/issues/7717</a><br><a href="https://www.cnblogs.com/xuxh120/p/14466705.html">10. https://www.cnblogs.com/xuxh120/p/14466705.html</a><br><a href="https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/">11. https://yuerer.com/Redis-6-%E5%89%96%E6%9E%90(%E4%BA%8C)-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</a><br><a href="https://cloud.tencent.com/developer/article/1179710">12. rdb文件解析</a><br><a href="https://segmentfault.com/a/1190000039097986">13. Redis RDB 和 AOF 对比，恢复优先级</a><br><a href="https://xiaolincoding.com/redis/module/strategy.html#%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5">14. Redis 过期删除策略和内存淘汰策略有什么区别？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;扩容环境频繁出现oom，最终定位到两个原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据业务写入太多&lt;/li&gt;
&lt;li&gt;bgsave导致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最近有点忙，先占坑，后面梳理完再写&lt;/p&gt;
&lt;p&gt;什么时候选择rdb，什么时候选择 aof&lt;br&gt;同步策略&lt;br&gt;优先级</summary>
      
    
    
    
    
    <category term="redis" scheme="https://mqrayblog.cn/tags/redis/"/>
    
    <category term="排障" scheme="https://mqrayblog.cn/tags/%E6%8E%92%E9%9A%9C/"/>
    
  </entry>
  
  <entry>
    <title>linux之iptable</title>
    <link href="https://mqrayblog.cn/2023/09/19/linux%E4%B9%8Biptable/"/>
    <id>https://mqrayblog.cn/2023/09/19/linux%E4%B9%8Biptable/</id>
    <published>2023-09-19T14:39:54.000Z</published>
    <updated>2023-10-24T04:46:09.776Z</updated>
    
    <content type="html"><![CDATA[<p>网络延迟是最核心的网络性能指标。由于网络传输、网络包处理等各种因素影响，网络延迟不可避免，但过大的延迟会直接影响用户体验。<br>发现网络延时增大后，可以从路由、网络包的收发、网络包的处理，再到应用程序等，从各个层级分析网络延迟，待找到网络延时的来源层级后，再深入定位瓶颈所在。</p><p>NAT(network address translation) 网络地址转换也是一个可能导致网络延迟的因素。</p><h3 id="NAT原理"><a href="#NAT原理" class="headerlink" title="NAT原理"></a>NAT原理</h3><p>NAT技术可以重写IP数据包的源ip或者目的ip，被广泛用于解决公网ip地址短缺的问题。其只要原理是，网络中的多台主机，通过共享一个公网ip，访问外网资源。同时由于nat屏蔽了内网网络，也为局域网机器提供了安全隔离。</p><h4 id="NAT的实现"><a href="#NAT的实现" class="headerlink" title="NAT的实现"></a>NAT的实现</h4><p>既可以在支持网络地址转换的路由器(NAT网关)中配置NAT，也可以在linux服务器中配置NAT。<br>根据实现方式的不同，NAT分作如下三类：</p><ul><li>静态NAT， 即内网IP与公网IP一一对应。</li><li>动态NAT，内网IP从公网IP池中动态选择一个进行映射。</li><li>网络地址端口转换NAPT (network address and port translation)， 即把内网ip映射到公网ip的不同端口上，让多个内网ip可以共享一个公网ip地址。</li></ul><p>其中<code>NAPT</code>是最流行的<code>NAT</code>类型，在linux中配置的nat也是这个类型。而根据转换方式的不同，又可以将<code>NAPT</code>分作三类：</p><ul><li>SNAT: 即目的地址不变，只替换源IP或者源端口，主要用于多个内网ip共享访问一个公网ip，来访问外网资源的场景。</li><li>DNAT： 即源IP不变，只替换目的ip或端口。通过公网ip的不同端口，来访问内网的多种服务，同时隐藏后端服务器的真实ip地址。</li><li>双向地址转换，接收到网络包时，执行<code>DNAT</code>，将目的IP转化为内网ip；发送网络包时，使用<code>SNAT</code>将源IP转化为外部IP。</li></ul><img src="/2023/09/19/linux%E4%B9%8Biptable/linux_nat_demo.png">  <p>如图是一个网络拓扑<br>当内网IP<code>192.168.0.2</code>访问外网百度时，发出的网络包，经过<code>NAT网关</code>时，会使用<code>SNAT</code>将源ip地址转化为<code>NAT</code>网关的ip地址，百度接收网络包时，该包的源IP为<code>100.100.100.100</code>；<br>而百度返回的包在经过<code>NAT网关</code>时，则执行<code>DNAT</code>通过查找路由表将目的IP转化为内网的真实IP，即<code>192.168.0.2</code>。</p><h3 id="iptables与nat"><a href="#iptables与nat" class="headerlink" title="iptables与nat"></a>iptables与nat</h3><p>linux内核提供的<code>netfilter</code>框架，允许对网络数据包进行修改，比如<code>NAT</code>和过滤(比如防火墙)。在此基础上，<code>iptables、ip6tables、ebtables</code>等工具，又提供了更易用的命令行接口，以便系统管理员配置和管理<code>NAT</code>、防火墙规则。</p><p>要掌握<code>iptables</code>的原理和使用方法，其核心是弄清楚网络数据包通过<code>netfilter</code>时的工作流向，如下图：<br><img src="/2023/09/19/linux%E4%B9%8Biptable/Netfilter-packet-flow.png"> </p><h4 id="tables"><a href="#tables" class="headerlink" title="tables"></a>tables</h4><p>图中绿色方框即为表，用来管理链。linux中支持四种表，包括<code>filter、nat、mangle和raw</code>，其作用分别为：</p><ul><li><code>filter</code>： 用于过滤数据包</li><li><code>nat</code>： 用于网络地址转换</li><li><code>mangle</code>：用于修改分组数据</li><li><code>raw</code>：用于原始数据包</li></ul><h4 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h4><p>与table一期的白色方框即为链，用来管理具体的<code>iptables规则</code>，每个表中可以包含多条链。</p><p>以<code>NAT表</code>为例，它内置了三条链：</p><ul><li><code>prerouting</code>， 用于路由判断前所执行的规则，比如对接收到的网络数据包进行<code>DNAT</code></li><li><code>postrouting</code>，用于路由判断后所执行的规则，比如对发送或者转发的数据包进行<code>SNAT</code>或者<code>MASQUERADE</code></li><li><code>output</code>：类似prerouting，只处理本机发送出去的包。</li></ul><h4 id="conntrack"><a href="#conntrack" class="headerlink" title="conntrack"></a>conntrack</h4><p>灰色的<code>conntrack</code>，标识连接跟踪模块，他通过内核中的连接跟踪表(哈希表)，记录了网络连接的状态，是<code>iptables</code>状态过滤(-m state)和<code>nat</code>的实现基础。<br><code>iptables</code>的所有规则，都会放到这些表和链中，并按照图中的顺序和规则优先级顺序来执行。</p><p>[如何理解规则优先级？]</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>问题1：Linux的NAT时给予内核的连接跟踪模块实现，保留了源IP、源端口、目的IP、目的端口之间的关系，多个内网IP地址的端口相同，但是IP不同，再nf_conntrack中对应不同的记录，所以MASQUERADE可以正常工作。</p><p>问题2：NAT方式所有流量都要经过NAT服务器，所以NAT服务器本身的软中断导致CPU负载、网络流量、文件句柄、端口号上限、nf_conntrack table full都可能是性能瓶颈</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://time.geekbang.org/column/article/83189">1. 极客时间-如何优化nat性能</a><br><a href="https://zh.wikipedia.org/zh-hk/Iptables#/media/File:Netfilter-packet-flow.svg">2. Netfilter-packet-flow.svg</a><br><a href="http://www.apelearn.com/study_v2/chapter16.html#id3">2. linux系统日常管理</a><br><a href="https://mp.weixin.qq.com/s/VYBs8iqf0HsNg9WAxktzYQ">4. 记一次Docker&#x2F;Kubernetes上无法解释的连接超时原因探寻之旅</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络延迟是最核心的网络性能指标。由于网络传输、网络包处理等各种因素影响，网络延迟不可避免，但过大的延迟会直接影响用户体验。&lt;br&gt;发现网络延时增大后，可以从路由、网络包的收发、网络包的处理，再到应用程序等，从各个层级分析网络延迟，待找到网络延时的来源层级后，再深入定位瓶颈所</summary>
      
    
    
    
    
    <category term="linux" scheme="https://mqrayblog.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux之网络</title>
    <link href="https://mqrayblog.cn/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/"/>
    <id>https://mqrayblog.cn/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/</id>
    <published>2023-09-05T14:29:07.000Z</published>
    <updated>2023-10-24T04:46:09.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><h4 id="OSI七层网络模型"><a href="#OSI七层网络模型" class="headerlink" title="OSI七层网络模型"></a>OSI七层网络模型</h4><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_network_arch.png">  <h4 id="四层网络"><a href="#四层网络" class="headerlink" title="四层网络"></a>四层网络</h4><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_network_4.png">  <h4 id="linux网络"><a href="#linux网络" class="headerlink" title="linux网络"></a>linux网络</h4><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_network_kernel.webp">  <h5 id="linux网络收发流程"><a href="#linux网络收发流程" class="headerlink" title="linux网络收发流程"></a>linux网络收发流程</h5><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_network_send_receive.webp">  <h5 id="网络包的接收流程"><a href="#网络包的接收流程" class="headerlink" title="网络包的接收流程"></a>网络包的接收流程</h5><ol><li>当一个网络帧到达网卡时，网卡通过DMA方式把网络包放到收包队列中，然后通过硬中断，告知中断处理程序已经接收到网络包。</li><li>网卡中断处理程序为网络帧分配内核数据结构<code>sk_buff</code>，并将其拷贝到<code>sk_buff</code>缓冲区，然后通过软中断，通知内核收到了新的网络帧。</li><li>内核协议栈从缓冲区中取出网络帧，并通过网络协议栈从下往上逐层处理这个网络帧。<br>内核协议栈处理网络帧的过程如下：</li></ol><ul><li>在数据链路层检查报文的合法性，检查上层协议类型(IPV4&#x2F;6)，去掉数据链路层帧头、帧尾，交给网络层</li><li>网络层取出IP头，判断网络包的下一步去向，比如交由上层处理或者转发。如果是确认该网络包交由本机则取出上层协议类型(TCP&#x2F;UDP)，去掉IP头，交由传输层。</li><li>传输层取出TCP头或者UDP头后，根据<code>&lt;源ip、源端口、目的ip、目的端口&gt;</code>四元组作为标识，找到对应的<code>socket</code>，并将数据拷贝到<code>socket</code>的接收缓冲区中。<br>应用程序就可以使用<code>socket</code>接口读取到最新的数据了。</li></ul><h6 id="相关缓冲区"><a href="#相关缓冲区" class="headerlink" title="相关缓冲区"></a>相关缓冲区</h6><ol><li>网卡收发网络包是，通过<code>DMA</code>方式交互的环形缓冲区： 涉及<code>DMA</code>和网卡交互，属于网卡设备驱动范围。</li><li>网卡中断处理程序为网络帧分配的内核数据结构<code>sk_buff</code>缓冲区。</li><li>应用程序通过网络套接字与网络协议栈交互的套接字缓冲区。<br>这些缓冲区都处于内核管理的内存中。</li></ol><h5 id="网络包的发送流程"><a href="#网络包的发送流程" class="headerlink" title="网络包的发送流程"></a>网络包的发送流程</h5><ol><li>应用程序调用<code>socket api</code>发送网络包</li><li>套接字层会把数据包放到<code>socket</code>发送缓冲区中</li><li>网络协议栈从<code>socket</code>发送缓冲区中取出数据包，按照TCP&#x2F;IP协议栈，从上到下逐层处理。</li><li>传输层：增加TCP&#x2F;IP头； 网络层：执行路由查找并确认下一跳的IP，并且按照MTU大小进行分片；网络接口层进行物理寻址，找到下一跳的MAC地址，然后添加帧头和帧尾，放到发包队列中</li><li>软中断通知驱动程序告知有新的网络帧需要发送</li><li>驱动程序通过<code>DMA</code>从发包队列中读取网络帧，并通过物理网卡将其发送出去。</li></ol><p>名词有点多，一个一个来看：</p><ul><li>DMA: Direct Memory Access，译作直接存储器访问，将数据从一个地址空间复制到另一个地址空间，提供外设和存储器之间或者存储器与存储器之间的高速素具传递</li><li>硬中断：</li><li>软中断：软中断处理，有专门的内核线程 <code>ksoftirqd</code>。每个 CPU 都会绑定一个 <code>ksoftirqd</code>内核线程。</li><li><code>sk_buff</code>：一个维护网络帧结构的双向链表，链表中的每一个元素都是一个网络帧<code>Packet</code>。</li></ul><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><h4 id="水平触发与边缘触发"><a href="#水平触发与边缘触发" class="headerlink" title="水平触发与边缘触发"></a>水平触发与边缘触发</h4><p>水平触发(level-trggered)：<br>边缘触发(edge-triggered):</p><h3 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h3><ol><li>带宽： 链路的最大传输速率，单位为b&#x2F;s。带宽和物理网卡的配置直接关联，实际带宽取决于整个网络链路中最小的一个。</li><li>时延: 网络请求发出后，一直到收到远端响应所需要的事件延迟。在不同场景下含义有所不同，比如连接建立的时间(TCP握手延时)或者一个数据包往返所需时间(rtt)</li><li>吞吐量：标识没有丢包时的最大数据传输速率，单位为b&#x2F;s。吞吐量受带宽限制。</li><li>PPS： 即packet per second的缩写，标识以网络包为单位的传输速率，通常用来评估网络的转发能力。在以linux服务器转发时，很容易受到网络包大小的影响。</li></ol><h4 id="网络性能测试"><a href="#网络性能测试" class="headerlink" title="网络性能测试"></a>网络性能测试</h4><p>linux网络基于TCP&#x2F;IP协议栈，而不同协议层的行为不同。在评估网络性能前，需要确定应用程序基于协议栈的哪一层：</p><ol><li>基于http或者https的web应用程序，属于应用层，需要测试http&#x2F;https的性能。</li><li>对于游戏服务器，为了支持更多在线人数，通常基于tcp&#x2F;udp与客户端交互，此时需要测试tcp&#x2F;udp的性能。</li><li>将linux作为软交换机或者路由器来使用，此时则更关注网络包的处理能力，特别是网络层的转发性能。</li></ol><blockquote><p>底层协议是其上各层网络协议的基础，底层的性能决定了高层的网络性能。</p></blockquote><h5 id="测试网络接口层和网络层的性能"><a href="#测试网络接口层和网络层的性能" class="headerlink" title="测试网络接口层和网络层的性能"></a>测试网络接口层和网络层的性能</h5><p>网络接口层和网络层主要负责网络包的封装、寻址、路由、发送以及接收。这两层中每秒可处理的网络包PPS即是最重要的性能指标，特别是64B小包的处理能力。</p><p>Linux 内核自带的高性能网络测试工具 <code>pktgen</code></p><h5 id="tcp-udp性能测试"><a href="#tcp-udp性能测试" class="headerlink" title="tcp&#x2F;udp性能测试"></a>tcp&#x2F;udp性能测试</h5><p><code>iperf</code> 和 <code>netperf</code> 都是最常用的网络性能测试工具</p><h5 id="http性能测试"><a href="#http性能测试" class="headerlink" title="http性能测试"></a>http性能测试</h5><p>要测试 HTTP 的性能，也有大量的工具可以使用，比如 ab、webbench 等，都是常用的 HTTP 压力测试工具。其中，ab 是 Apache 自带的 HTTP 压测工具，主要测试 HTTP 服务的每秒请求数、请求延迟、吞吐量以及请求延迟的分布情况等。</p><p>为了得到应用程序的实际性能，就要求性能工具本身可以模拟用户的请求负载，而 iperf、ab 这类工具就无能为力了。幸运的是，我们还可以用 wrk、TCPCopy、Jmeter 或者 LoadRunner 等实现这个目标。</p><h3 id="网络性能优化"><a href="#网络性能优化" class="headerlink" title="网络性能优化"></a>网络性能优化</h3><h4 id="确定优化目标"><a href="#确定优化目标" class="headerlink" title="确定优化目标"></a>确定优化目标</h4><p>参考TCP&#x2F;IP分层协议簇，确定各层的性能预期。<br>除了上述描述的，针对传输层TCP&#x2F;UDP，网络包的大小会影响吞吐量(BPS)、连接数、延迟等指标。</p><h4 id="选用网络性能工具"><a href="#选用网络性能工具" class="headerlink" title="选用网络性能工具"></a>选用网络性能工具</h4><h5 id="根据指标选用工具"><a href="#根据指标选用工具" class="headerlink" title="根据指标选用工具"></a>根据指标选用工具</h5><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_net_opt_tool.png">  <h5 id="根据工具查询指标"><a href="#根据工具查询指标" class="headerlink" title="根据工具查询指标"></a>根据工具查询指标</h5><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_net_tool_opt.webp">  <h4 id="网络性能优化-1"><a href="#网络性能优化-1" class="headerlink" title="网络性能优化"></a>网络性能优化</h4><p>在获得网络基准测试报告后，通过相关性能工具，定位出网络性能瓶颈后，就可以进行优化了。<br>参考上述 LINUX系统下的网络协议栈和网络收发流程进行网络性能优化。<br>一般来说可以从： 应用程序，套接字、传输层、网络层和链路层等角度进行优化。</p><h5 id="应用程序优化"><a href="#应用程序优化" class="headerlink" title="应用程序优化"></a>应用程序优化</h5><p>应用程序通常是通过套接字接口进行网络操作。由于网络收发比较耗时，所以应用程序的优化，主要就是对网络IO和进程自身工作模型的优化。</p><ol><li>网络IO优化：<ul><li>使用epoll替代select和poll</li><li>使用异步io。 AIO允许应用程序同时发起很多IO操作，而不用等待操作完成，等到io完成后，系统会用<code>事件通知</code>的方式告知应用程序结果。不过AIO使用比较复杂，需要小心处理很多边缘情况。</li></ul></li><li>进程模型优化：<ul><li>主进程+ 多个worker子进程。 由主进程负责管理网络连接，子进程负责处理实际业务。</li><li>监听相同端口的多进程模型： 所有进程监听相同接口，并且开启<code>SO_REUSEPORT</code>选项，由内核负责，将请求负载均衡到这些监听进程中。</li></ul></li></ol><p>另外，应用层协议的优化也很重要，有如下常见的优化手段：</p><ol><li>使用长连接取代短连接，可以显著降低TCP建立连接的成本。在每秒请求次数较多时，效果明显。</li><li>使用内存等形式缓存不常变化的数据，可以降低网络IO次数，加快应用程序响应速度。</li><li>使用<code>protocol buffer</code>等序列化方式，压缩网络io的数据量，提高应用程序的吞吐。</li><li>使用<code>DNS预存、预取、HTTPDNS</code>等方式，减少DNS解析的延迟。</li></ol><h5 id="套接字优化"><a href="#套接字优化" class="headerlink" title="套接字优化"></a>套接字优化</h5><p>套接字可以屏蔽掉linux内核中不同协议的差异，为应用程序提供统一的访问接口。每个套接字都有一个读写缓冲区。</p><ul><li>读缓冲区： 缓存远端发来的数据，如果满就不能再接收新的数据。</li><li>写缓冲区：缓存要发出去的数据，如果满，应用程序的写操作就会被阻塞。<br>故而，为了提高网络吞吐量，通常需要调整这些缓冲区大小：</li></ul><ol><li>增大每个套接字的缓冲区大小： <code>net.core.optmem_max</code></li><li>增大套接字接收缓冲区大小： <code>net.core.rmem_max</code></li><li>增大套接字发送缓冲区大小： <code>net.core.wmem_max</code></li><li>增大TCP接收缓冲区大小:  <code>net.ipv4.tcp_rmem</code></li><li>增大TCP发送缓冲区大小:  <code>net.ipv4.tcp_wmem</code><br>除此之外，套接字的内核选项如下：</li></ol><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_net_socket_prm.webp">  <h5 id="传输层优化"><a href="#传输层优化" class="headerlink" title="传输层优化"></a>传输层优化</h5><p>实际上是指对两种协议的优化。</p><h6 id="TCP协议优化"><a href="#TCP协议优化" class="headerlink" title="TCP协议优化"></a>TCP协议优化</h6><p>流量控制：<br>慢启动：<br>拥塞控制：<br>延迟确认：<br>状态流图：如下图<br><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_tcp_opt.webp">  </p><ol><li>请求数比较大的场景下，大量处于<code>TIME_WAIT</code>状态的连接，会占用大量内存和端口资源，此时可以优化与<code>TIME_WAIT</code>转台相关的内核选项：</li></ol><ul><li>增大处于<code>TIME_WAIT</code>状态的连接数量<code>net.ipv4.tcp_max_tw_buckets</code>,并增大连接跟踪表的大小<code>net.netfilter.nf_conntrack_max</code>。</li><li>减小<code>net.ipv4.tcp_fin_timeout</code>和 <code>net.netfilter.nf_conntrack_tcp_timeout_time_wait</code>，让系统尽快释放所占用的资源。</li><li>开启端口复用<code>net.ipv4.tcp_tw_reuse</code>，这样被<code>TIME_WAIT</code>状态占用的端口，还能用到新建的连接中。</li><li>增大本地端口范围<code>net.ipv4.ip_local_port_range</code>，这样可以支持更多的连接，提高整体的并发能力。</li><li>增大文件描述符的数量：使用<code>fs.nr_open</code>和<code>fs.file_max</code>分别增大进程和系统的最大文件描述符；或者在应用程序的<code>systemd</code>配置文件中，配置<code>limitnofile</code>设置应用程序的最大文件描述符。</li></ul><ol start="2"><li>缓解<code>syn flood</code>利用<code>tcp</code>协议特点进行攻击而引发的性能问题，可以考虑优化与<code>syn</code>状态相关的内核选项：</li></ol><ul><li><p>增大<code>tcp</code>半连接的最大数量 <code>net.ipv4.tcp_max_syn_backlog</code>，或者开启<code>TCP SYN Cookies net.ipv4.tcp_syncookies</code>，来绕开半连接数量限制问题。[连着不可同时使用]</p></li><li><p>减少<code>SYN_RECV</code>状态连接重传<code>SYN+ACK</code>包的次数<code>net.ipv4.tcp_synack_retries</code>.</p></li></ul><ol start="3"><li>在长连接的场景中，通常使用<code>keepalive</code>检测tcp连接的状态，以便对端连接断开后可以自动回收。但是<code>keepalive</code>探测间隔和重试次数一般都无法满足应用程序的性能，此时需要优化与<code>keepalive</code>相关的内核选项：</li></ol><ul><li>缩短最后一次数据包到<code>keepalive</code>探测包之间的间隔时间<code>net.ipv4.tcp_keepalive_time</code>;</li><li>缩短发送<code>keepalive</code>探测包的间隔时间<code>net.ipv4.tcp_keepalive_intvl</code></li><li>减少<code>keepalive</code>探测失败后，一直到通知应用程序前的重试次数<code>net.ipv4.tcp_keepalive_probes</code>.</li></ul><img src="/2023/09/05/linux%E4%B9%8B%E7%BD%91%E7%BB%9C/linux_tcp_opt_core.webp"> <p>另外，如果使用不同的优化方法，可能会产生冲突。比如服务端使用<code>nagle</code>算法，客户端开启延时确认，就很容易导致网络延时增大。<br>对于<code>NAT</code>服务器而言，如果开启<code>net.ipv4.tcp_tw_recycle</code>就很容易导致各种连接失败，已于内核的4.1版本中删除。</p><h6 id="UDP协议优化"><a href="#UDP协议优化" class="headerlink" title="UDP协议优化"></a>UDP协议优化</h6><ol><li>增大套接字缓冲区大小和<code>UDP</code>缓冲区范围；</li><li>增大本地端口号范围；</li><li>根据<code>MTU</code>大小，调整<code>UDP</code>数据包的大小，减少或者避免分片。</li></ol><h5 id="网络层优化"><a href="#网络层优化" class="headerlink" title="网络层优化"></a>网络层优化</h5><p>网络层负责网络包的封装、寻址和路由，包括IP、ICMP协议。在网络层最主要的优化是对路由、<code>IP</code>分片以及<code>ICMP</code>等进行调优。</p><ol><li>从路由和转发的角度，可以调整如下内核选项：</li></ol><ul><li>在需要转发的服务器中，比如用作<code>nat网关</code>的服务器或者使用docker容器时，设置<code>net.ipv4.ip_forward=1</code>开启<code>IP转发</code>。</li><li>调整数据包的生存周期<code>TTL</code>，比如设置<code>net.ipv4.ip-default_ttl=64</code>.[增大该值会降低系统性能]</li><li>设置<code>net.ipv4.conf.eth0.rp_filter=1</code>开启数据包的反向地址校验，防止IP欺骗减少伪造IP带来的<code>DDOS</code>问题。</li></ul><ol start="2"><li>从分片的角度，调整<code>MTU</code>大小<br>以太网标准规定，一个网络帧最大为 1518B，那么去掉以太网头部的 18B 后，剩余的 1500 就是以太网 MTU 的大小。在使用<code>VXLAN、GRE</code>等叠加网络技术后，会使原来的网络包变大，使得MTU也需要调整。<br>以VXLAN为例，它在原来报文的基础上，增加了 14B 的以太网头部、 8B 的 VXLAN 头部、8B 的 UDP 头部以及 20B 的 IP 头部。换句话说，每个包比原来增大了 50B。<br>所以就需要交换机、路由器等的<code>MTU</code>增大到1550，或者把<code>VXLAN</code>封包前的<code>MTU</code>减小为1450。<br>当然，考虑到许多网络设备都支持<code>巨帧</code>，这种情况下，可以将<code>MTU</code>调大为9000，以提高网络吞吐量。</li><li>以ICMP角度出发，为了避免ICMP主机探测、ICMP flood等各种网络问题，可以通过内核选项，限制ICMP行为。</li></ol><ul><li>设置<code>net.ipv4.icmp_echo_ignore_all=1</code>禁用<code>ICMP</code>协议，外部主机就无法通过<code>ping</code>等使用<code>ICMP</code>协议的命令来探测主机。</li><li>设置<code>net.ipv4.icmp_echo_ignore_broadcasts=1</code>禁止广播<code>ICMP</code>.</li></ul><h5 id="链路层优化"><a href="#链路层优化" class="headerlink" title="链路层优化"></a>链路层优化</h5><p>链路层负责网络包在物理网络中的传输：<code>MAC寻址</code>、错误探测、通过网卡传输网络帧。</p><ol><li>由于网卡收包之后调用的中断处理程序(特别是软中断)，需要消耗大量的CPU，所以将这些中断处理程序调度到不同的CPU上执行，就可以显著提高网络吞吐量。</li></ol><ul><li>为网卡硬中断配置CPU亲和性(smp_affinity)，或者开启<code>irqbalance</code>。</li><li>开启<code>RPS (receive packet steering)</code> 和<code>RFS (receive flow steering)</code>将应用程序和软中断的处理，调度到相同的CPU上。这样就可以增加CPU命中率，减少网络延时。</li></ul><ol start="2"><li>原来内核中通过软件处理的功能可以卸载到网卡中，通过硬件执行：</li></ol><ul><li><code>TSO(TCP Segmentation Offload) | UFO (UDP Fragmentation Offload)</code>: 在<code>TCP/UDP</code>协议中直接发送大包，<code>TCP|UDP</code>包的分段|分片功能交由网卡完成。</li><li>GSO (Generic Segmentation Offload): 网卡不支持TSO|ufo时，将分片和分段操作延迟到进入网卡前再执行。</li><li>LRO（Large Receive Offload）：在接收 TCP 分段包时，由网卡将其组装合并后，再交给上层网络处理。不过要注意，在需要 IP 转发的情况下，不能开启 LRO，因为如果多个包的头部信息不一致，LRO 合并会导致网络包的校验错误。</li><li>GRO（Generic Receive Offload）：GRO 修复了 LRO 的缺陷，并且更为通用，同时支持 TCP 和 UDP。</li><li>RSS（Receive Side Scaling）：也称为多队列接收，它基于硬件的多个接收队列，来分配网络接收进程，这样可以让多个 CPU 来处理接收到的网络包。</li><li>VXLAN 卸载：也就是让网卡来完成 VXLAN 的组包功能。</li></ul><ol start="3"><li>网络接口本身</li></ol><ul><li>开启网络接口的多队列功能，每个队列可以用不同的中断号，调度到不同的CPU上执行。</li><li>增大网络接口的缓冲区和队列长度</li><li>使用<code>traffic control</code>工具，为不同的网络流量配置<code>QOS</code></li></ul><p>另外，在单机<code>10M</code>场景下，网络协议栈的冗长流程才是最主要的性能负担。这种场景下，可以使用两种方式进行优化。</p><ul><li>使用<code>DPDK</code>技术，跳过内核协议栈，直接由用户态进程用轮询的方式，处理网络请求。同时结合大页、cpu绑定、内存对齐、流水线并发等多种机制，优化网络包处理效率。</li><li>使用内核自带的<code>XDP</code>技术，在网络包进入内核协议前就对齐进行处理。<blockquote><p>nslookup ip<br>time nslookup ip<br>ping -c3 <a href="http://www.baidu.com/">www.baidu.com</a><br>dnsmasq &#x2F;etc&#x2F;init.d&#x2F;dnsmasq start<br>dig +trace +nodnssec time.geekbang.org<br>strace</p></blockquote></li></ul><p>域名劫持和规避<br>客户端：HTTPDNS</p><p>全局负载均衡（GSLB）</p><p>PTR 请求</p><p>tcpdump</p><p>iptable</p><p>traceroute<br>tracepath<br>nc</p><p>&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</p><ol><li>最大连接数是不是受限于65535个端口？<br>无论TCP&#x2F;UDP，端口号只占16位，最大值为65535，是不是说如果使用TCP协议，单台机器、单个IP地址，并发连接数最大也只有65535个呢？<br>[困扰许久的问题]<br>linux中，通过<code>协议、源ip、源端口、目的ip、目的端口</code>这个五元组来标识一个连接。</li></ol><ul><li>客户端，对于客户端而言，每个请求都需要耗费一个本地端口去连接远程服务器，由于本地端口是独占的，所以客户端最多只能发起65535个连接。</li><li>服务器，其通常是监听在固定端口上，等待客户端连接。由于客户端的源ip、源端口是可变的。极限情况下，服务器端的理论最大连接数可以达到2^48<br>服务器端是支持海量连接数的，当然还受到linux协议栈本身的性能、各种物理和软件的资源限制，实际情况会低很多C10M.</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://time.geekbang.org/column/article/81268">1. 极客时间-linux性能优化</a><br><a href="https://blog.csdn.net/lihao21/article/details/67631516">2. 水平触发和边缘触发</a><br><a href="https://blog.csdn.net/yolo_yyh/article/details/118367979">3. 陈硕-muduo网络库与服务模型介绍</a><br><a href="https://cloud.tencent.com/developer/article/1721171">4. linux版本查看</a><br><a href="https://plantegg.github.io/2019/01/09/nslookup-OK-but-ping-fail/">5. dns排障实例</a><br><a href="https://www.rfc-editor.org/rfc-index.html">6. rfc</a><br><a href="https://wiki.wireshark.org/TCP%204-times%20close">7. wireshark四次挥手案例</a><br><a href>8. 林沛满《Wireshark网络分析就这么简单》和《Wireshark网络分析的艺术》</a><br><a href="https://zhuanlan.zhihu.com/p/138573828">9. DMA原理介绍</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h3&gt;&lt;h4 id=&quot;OSI七层网络模型&quot;&gt;&lt;a href=&quot;#OSI七层网络模型&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="linux" scheme="https://mqrayblog.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>redis之事务</title>
    <link href="https://mqrayblog.cn/2023/09/05/redis%E4%B9%8B%E4%BA%8B%E5%8A%A1/"/>
    <id>https://mqrayblog.cn/2023/09/05/redis%E4%B9%8B%E4%BA%8B%E5%8A%A1/</id>
    <published>2023-09-05T00:12:47.000Z</published>
    <updated>2023-10-24T04:46:09.784Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>redis 通过 multi、watch、exec等命令来实现事务功能。</p></blockquote><p>redis提供这样一种将多个待执行的命令入队，在事务开始之后执行入队的事务命令，即使事务队列中部分命令执行失败也不会中断事务，事务队列中的所有命令执行完毕后，才会去请求其他客户端的命令请求。</p><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>redis中事务从开始到结束有如下三个阶段：</p><ol><li>事务开始</li><li>命令入队</li><li>事务执行</li></ol><h4 id="命令开始"><a href="#命令开始" class="headerlink" title="命令开始"></a>命令开始</h4><p>redis中，客户端使用<code>multi</code>命令标识当前客户端进入事务状态。<br>该命令将执行该命令的客户端从非事务状态切换到事务状态<code>#define CLIENT_MULTI (1&lt;&lt;3)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    <span class="type">uint64_t</span> flags;         <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h4><p>客户端处于非事务状态时，这个客户端发送的命令将会被服务端立即执行。<br>而客户端处于事务状态时，服务器会根据这个客户端发来的不同命令执行不同的操作：</p><ol><li>如果是 <code>multi、exec、discard、watch</code>四个命令中的一个，服务器立即执行。</li><li>否则，将命令放入事件队列中，向客户端返回<code>QUEUED</code>回复。</li></ol><h4 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h4><p>客户端中使用<code>multiState mstate</code>保存事务队列，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    multiCmd *commands;     <span class="comment">// 事务队列，记录命令</span></span><br><span class="line">    <span class="type">int</span> count;              <span class="comment">// 已入队的命令计数</span></span><br><span class="line">    <span class="type">int</span> cmd_flags;          <span class="comment">/* The accumulated command flags OR-ed together.</span></span><br><span class="line"><span class="comment">                               So if at least a command has a given flag, it</span></span><br><span class="line"><span class="comment">                               will be set in this field. */</span></span><br><span class="line">    <span class="type">int</span> cmd_inv_flags;      <span class="comment">/* Same as cmd_flags, OR-ing the ~flags. so that it</span></span><br><span class="line"><span class="comment">                               is possible to know if all the commands have a</span></span><br><span class="line"><span class="comment">                               certain flag. */</span></span><br><span class="line">    <span class="type">size_t</span> argv_len_sums;    <span class="comment">/* mem used by all commands arguments */</span></span><br><span class="line">    <span class="type">int</span> alloc_count;         <span class="comment">/* total number of multiCmd struct memory reserved. */</span></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p><code>multiState</code>中记录了事务命令，事务命令个数。其中，事务队列是一个<code>FIFO</code>队列。<br><code>commands</code>则保存了每个入队的命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    robj **argv; <span class="comment">// 参数</span></span><br><span class="line">    <span class="type">int</span> argv_len; <span class="comment">// 参数个数</span></span><br><span class="line">    <span class="type">int</span> argc; <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span> <span class="comment">// 命令指针</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><p>客户端执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">MULTI</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET <span class="string">&quot;name&quot;</span> <span class="string">&quot;Practical Common Lisp&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GET <span class="string">&quot;name&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET <span class="string">&quot;author&quot;</span> <span class="string">&quot;Peter Seibel&quot;</span></span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GET <span class="string">&quot;author&quot;</span></span></span><br><span class="line">QUEUED</span><br></pre></td></tr></table></figure><img src="/2023/09/05/redis%E4%B9%8B%E4%BA%8B%E5%8A%A1/redis_transaction.png">  <h4 id="事务执行"><a href="#事务执行" class="headerlink" title="事务执行"></a>事务执行</h4><p>处于事务状态的客户端向服务器发送<code>exec</code>命令时，该命令将被立即执行。服务端遍历客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果返回给客户端。</p><h3 id="watch-命令的实现"><a href="#watch-命令的实现" class="headerlink" title="watch 命令的实现"></a>watch 命令的实现</h3><p><code>watch</code>命令是乐观锁，在执行<code>exec</code>命令之前，监视任意数量的数据库键，在执行<code>EXEC</code>命令时，检查被监视的键是否至少有一个已经被修改过，如果是，服务器将拒绝执行事务，并向事务所在的客户端发送代表事务执行失败的空返回。</p><h4 id="watch-监视-键"><a href="#watch-监视-键" class="headerlink" title="watch 监视 键"></a>watch 监视 键</h4><p>数据库中使用<code>watch_keys</code>字典记录数据库中的键，其中字典<code>key</code>为被<code>watch</code>命令监视的数据库键，字典值为所有监控相关数据库键的客户端。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *blocking_keys_unblock_on_nokey;   <span class="comment">/* Keys with clients waiting for</span></span><br><span class="line"><span class="comment">                                             * data, and should be unblocked if key is deleted (XREADEDGROUP).</span></span><br><span class="line"><span class="comment">                                             * This is a subset of blocking_keys*/</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">    clusterSlotToKeyMapping *slots_to_keys; <span class="comment">/* Array of slots to keys. Only used in cluster mode (db 0). */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h4 id="监视触发"><a href="#监视触发" class="headerlink" title="监视触发"></a>监视触发</h4><p>所有对数据库进行修改的命令，比如<code>set、lpush、sadd、zrem，del</code>在执行之后都会调用<code>multi.c/touchKey</code>函数对<code>watched_keys</code>进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有，将当前客户端的<code>flags</code>标识为<code>#define CLIENT_DIRTY_CAS (1&lt;&lt;5)</code></p><h4 id="判断事务是否安全"><a href="#判断事务是否安全" class="headerlink" title="判断事务是否安全"></a>判断事务是否安全</h4><p>当服务端收到户端发送<code>exec</code>命令时，服务器将根据这个客户端的<code>flags</code>是否打开了<code>CLIENT_DIRTY_CAS</code>标识来决定是否执行事务。</p><ol><li>如果<code>CLIENT_DIRTY_CAS</code>被打开，则说明客户端监视的数据库键中至少有一个已经被修改了，客户端提交的事务不再安全，服务器拒绝执行客户端提交的事务。</li><li>否则，认为事务安全，继续执行事务队列里的命令。</li></ol><h3 id="疑问质疑"><a href="#疑问质疑" class="headerlink" title="疑问质疑?"></a>疑问质疑?</h3><h5 id="集群模式下是否不支持事务？"><a href="#集群模式下是否不支持事务？" class="headerlink" title="集群模式下是否不支持事务？"></a>集群模式下是否不支持事务？</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">182.168.168.238:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">182.168.168.238:6379(TX)&gt; set name mqray</span><br><span class="line">QUEUED</span><br><span class="line">182.168.168.238:6379(TX)&gt; get name</span><br><span class="line">QUEUED</span><br><span class="line">182.168.168.238:6379(TX)&gt; set height 181</span><br><span class="line">QUEUED</span><br><span class="line">182.168.168.238:6379(TX)&gt; get height</span><br><span class="line">QUEUED</span><br><span class="line">182.168.168.238:6379(TX)&gt; exec  </span><br><span class="line">(error) CROSSSLOT Keys in request don&#x27;t hash to the same slot</span><br><span class="line">182.168.168.238:6379&gt; </span><br></pre></td></tr></table></figure><p>(集群模式下使用事务遇到的问题)<br>的确如此！</p><h5 id="redis集群模式下能否支持事务？"><a href="#redis集群模式下能否支持事务？" class="headerlink" title="redis集群模式下能否支持事务？"></a>redis集群模式下能否支持事务？</h5><p><a href>redis集群模式下支持事务</a></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://redisbook.com/preview/transaction/transaction_implement.html">1. 事务的实现</a><br><a href="http://blog.guonl.cn/2019/02/20/redis%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%AF%B9%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%94%AF%E6%8C%81/#hash-tags">2. redis集群模式下能否支持事务</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;redis 通过 multi、watch、exec等命令来实现事务功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;redis提供这样一种将多个待执行的命令入队，在事务开始之后执行入队的事务命令，即使事务队列中部分命令执行失败也不会中断事务，事务队</summary>
      
    
    
    
    <category term="databases" scheme="https://mqrayblog.cn/categories/databases/"/>
    
    
    <category term="redis" scheme="https://mqrayblog.cn/tags/redis/"/>
    
    <category term="源码阅读" scheme="https://mqrayblog.cn/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>redis之发布订阅</title>
    <link href="https://mqrayblog.cn/2023/09/04/redis%E4%B9%8B%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    <id>https://mqrayblog.cn/2023/09/04/redis%E4%B9%8B%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</id>
    <published>2023-09-03T23:47:03.000Z</published>
    <updated>2023-10-24T04:46:09.784Z</updated>
    
    <content type="html"><![CDATA[<p>redis的发布订阅功能由<code>publish|subscribe|psubscribe</code>等命令组成。</p><h3 id="频道的订阅与退订"><a href="#频道的订阅与退订" class="headerlink" title="频道的订阅与退订"></a>频道的订阅与退订</h3><h4 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h4><p>当客户端执行<code>subscribe</code> 命令订阅一个或多个频道时，这个客户端与被订阅的频道建就建立了一种订阅关系。</p><p>redis中将所有频道的订阅关系存储在服务器状态<code>pubsub_channels</code>中，键为被订阅频道，值为记录了所有订阅此频道的客户端。：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Pubsub */</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* Map channels to list of subscribed clients */</span></span><br><span class="line">    dict *pubsub_patterns;  <span class="comment">/* A dict of pubsub_patterns */</span></span><br><span class="line">    <span class="type">int</span> notify_keyspace_events; <span class="comment">/* Events to propagate via Pub/Sub. This is an</span></span><br><span class="line"><span class="comment">                                   xor of NOTIFY_... flags. */</span></span><br><span class="line">    dict *pubsubshard_channels;  <span class="comment">/* Map shard channels to list of subscribed clients */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，客户端上也会记录这一信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* channels a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    dict *pubsub_patterns;  <span class="comment">/* patterns a client is interested in (PSUBSCRIBE) */</span></span><br><span class="line">    dict *pubsubshard_channels;  <span class="comment">/* shard level channels a client is interested in (SSUBSCRIBE) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅过程的实现就是单链表的插入过程：</p><ol><li>检查频道中是否有其他订阅者</li><li>如果没有，则创建一个键值对，值为空链表，然后将当前客户端加到链表中</li><li>如果有，则将当前客户端加入到链表为</li></ol><h4 id="unscbscribe"><a href="#unscbscribe" class="headerlink" title="unscbscribe"></a>unscbscribe</h4><p>当一个客户端退订一个或多个频道时，将从<code>pubsub_channels</code>中解除客户端与该退订频道之间的关联。<br>操作过程即遍历<code>pubsub_channels</code>，对每个频道上的链表做删除操作。</p><h3 id="模式的订阅与退订"><a href="#模式的订阅与退订" class="headerlink" title="模式的订阅与退订"></a>模式的订阅与退订</h3><p>与频道订阅类似，redis客户端通过<code>psubscribe</code>命令订阅模式，并将模式的订阅关系保存在服务器的<code>pubsub_patterns</code>状态中。在<code>redis2.x</code>中，这一结构保存在<code>pubsubPattern</code>结构中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span>&#123;</span></span><br><span class="line">    redisClient *client； <span class="comment">// 记录模式订阅的客户端</span></span><br><span class="line">    robj *pattern； <span class="comment">// 记录被订阅的模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在当前版本中<code>redis 6.x</code>已经被修改为了dict。</p><h4 id="psubscribe"><a href="#psubscribe" class="headerlink" title="psubscribe"></a>psubscribe</h4><p>在新版本中，其操作和<code>subscribe</code>一致，将模式名作为key，使用链表记录订阅模式的客户端。<br>具体执行逻辑即链表的插入操作</p><h4 id="punsubscribe"><a href="#punsubscribe" class="headerlink" title="punsubscribe"></a>punsubscribe</h4><p>客户端执行此命令时，服务器将会剔除掉<code>pubsub_patterns</code>中维护的模式订阅关系，具体操作即对链表进行删除操作。</p><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>当客户端执行<code>publish &lt;channel&gt; &lt;message&gt;</code>命令将休息<code>message</code>发送给频道<code>channel</code>时，服务器需要执行如下两个动作：</p><ol><li>将消息发送给 <code>channel</code>频道的所有订阅者。</li><li>检测是否频道所符合的模式，如果匹配，则将消息发送给这些订阅了这些模式的订阅者。</li></ol><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Publish a message to all the subscribers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pubsubPublishMessageInternal</span><span class="params">(robj *channel, robj *message, pubsubtype type)</span> &#123;</span><br><span class="line">    <span class="type">int</span> receivers = <span class="number">0</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send to clients listening for that channel */</span></span><br><span class="line">    de = dictFind(*type.serverPubSubChannels, channel);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="built_in">list</span> *<span class="built_in">list</span> = dictGetVal(de);</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        listRewind(<span class="built_in">list</span>,&amp;li);</span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            client *c = ln-&gt;value;</span><br><span class="line">            addReplyPubsubMessage(c,channel,message,*type.messageBulk);</span><br><span class="line">            updateClientMemUsageAndBucket(c);</span><br><span class="line">            receivers++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type.shard) &#123;</span><br><span class="line">        <span class="comment">/* Shard pubsub ignores patterns. */</span></span><br><span class="line">        <span class="keyword">return</span> receivers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send to clients listening to matching channels */</span></span><br><span class="line">    di = dictGetIterator(server.pubsub_patterns);</span><br><span class="line">    <span class="keyword">if</span> (di) &#123;</span><br><span class="line">        channel = getDecodedObject(channel);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            robj *pattern = dictGetKey(de);</span><br><span class="line">            <span class="built_in">list</span> *clients = dictGetVal(de);</span><br><span class="line">            <span class="keyword">if</span> (!stringmatchlen((<span class="type">char</span>*)pattern-&gt;ptr,</span><br><span class="line">                                sdslen(pattern-&gt;ptr),</span><br><span class="line">                                (<span class="type">char</span>*)channel-&gt;ptr,</span><br><span class="line">                                sdslen(channel-&gt;ptr),<span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            listRewind(clients,&amp;li);</span><br><span class="line">            <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                client *c = listNodeValue(ln);</span><br><span class="line">                addReplyPubsubPatMessage(c,pattern,channel,message);</span><br><span class="line">                updateClientMemUsageAndBucket(c);</span><br><span class="line">                receivers++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(channel);</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息发布"><a href="#消息发布" class="headerlink" title="消息发布"></a>消息发布</h4><p>可以看到，主体逻辑即是遍历订阅该频道的客户端，调用<code>addReplyPubsubMessage</code>发送消息；找到匹配的模式的客户端，调用<code>addReplyPubsubPatMessage</code>方法发送消息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send a pubsub message of type &quot;message&quot; to the client.</span></span><br><span class="line"><span class="comment"> * Normally &#x27;msg&#x27; is a Redis object containing the string to send as</span></span><br><span class="line"><span class="comment"> * message. However if the caller sets &#x27;msg&#x27; as NULL, it will be able</span></span><br><span class="line"><span class="comment"> * to send a special message (for instance an Array type) by using the</span></span><br><span class="line"><span class="comment"> * addReply*() API family. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addReplyPubsubMessage</span><span class="params">(client *c, robj *channel, robj *msg, robj *message_bulk)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> old_flags = c-&gt;flags;</span><br><span class="line">    c-&gt;flags |= CLIENT_PUSHING;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>) <span class="comment">// resp版本，客户端服务器通信协议版本</span></span><br><span class="line">        addReply(c,shared.mbulkhdr[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        addReplyPushLen(c,<span class="number">3</span>);</span><br><span class="line">    addReply(c,message_bulk);</span><br><span class="line">    addReplyBulk(c,channel);</span><br><span class="line">    <span class="keyword">if</span> (msg) addReplyBulk(c,msg);</span><br><span class="line">    <span class="keyword">if</span> (!(old_flags &amp; CLIENT_PUSHING)) c-&gt;flags &amp;= ~CLIENT_PUSHING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send a pubsub message of type &quot;pmessage&quot; to the client. The difference</span></span><br><span class="line"><span class="comment"> * with the &quot;message&quot; type delivered by addReplyPubsubMessage() is that</span></span><br><span class="line"><span class="comment"> * this message format also includes the pattern that matched the message. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addReplyPubsubPatMessage</span><span class="params">(client *c, robj *pat, robj *channel, robj *msg)</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span> old_flags = c-&gt;flags;</span><br><span class="line">    c-&gt;flags |= CLIENT_PUSHING;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>)</span><br><span class="line">        addReply(c,shared.mbulkhdr[<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        addReplyPushLen(c,<span class="number">4</span>);</span><br><span class="line">    addReply(c,shared.pmessagebulk);</span><br><span class="line">    addReplyBulk(c,pat);</span><br><span class="line">    addReplyBulk(c,channel);</span><br><span class="line">    addReplyBulk(c,msg);</span><br><span class="line">    <span class="keyword">if</span> (!(old_flags &amp; CLIENT_PUSHING)) c-&gt;flags &amp;= ~CLIENT_PUSHING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上述函数的实现中，在判断客户端服务器通信协议版本之后，都是通过调用<code>addReply</code>函数实现的消息发送。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Higher level functions to queue data on the client output buffer.</span></span><br><span class="line"><span class="comment"> * The following functions are the ones that commands implementations will call.</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------------------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add the object &#x27;obj&#x27; string representation to the client output buffer. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addReply</span><span class="params">(client *c, robj *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (prepareClientToWrite(c) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(obj)) &#123;</span><br><span class="line">        _addReplyToBufferOrList(c,obj-&gt;ptr,sdslen(obj-&gt;ptr));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="comment">/* For integer encoded strings we just convert it into a string</span></span><br><span class="line"><span class="comment">         * using our optimized function, and attach the resulting string</span></span><br><span class="line"><span class="comment">         * to the output buffer. */</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="type">size_t</span> len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="type">long</span>)obj-&gt;ptr);</span><br><span class="line">        _addReplyToBufferOrList(c,buf,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Wrong obj-&gt;encoding in addReply()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>message</code>的字符串表征后调用<code>_addReplyToBufferOrList</code>发送给客户端输出缓冲区.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _addReplyToBufferOrList(client *c, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replicas should normally not cause any writes to the reply buffer. In case a rogue replica sent a command on the</span></span><br><span class="line"><span class="comment">     * replication link that caused a reply to be generated we&#x27;ll simply disconnect it.</span></span><br><span class="line"><span class="comment">     * Note this is the simplest way to check a command added a response. Replication links are used to write data but</span></span><br><span class="line"><span class="comment">     * not for responses, so we should normally never get here on a replica client. */</span></span><br><span class="line">    <span class="keyword">if</span> (getClientType(c) == CLIENT_TYPE_SLAVE) &#123;</span><br><span class="line">        sds cmdname = c-&gt;lastcmd ? c-&gt;lastcmd-&gt;fullname : <span class="literal">NULL</span>;</span><br><span class="line">        logInvalidUseAndFreeClientAsync(c, <span class="string">&quot;Replica generated a reply to command &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                                        cmdname ? cmdname : <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We call it here because this function may affect the reply</span></span><br><span class="line"><span class="comment">     * buffer offset (see function comment) */</span></span><br><span class="line">    reqresSaveClientReplyOffset(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we&#x27;re processing a push message into the current client (i.e. executing PUBLISH</span></span><br><span class="line"><span class="comment">     * to a channel which we are subscribed to, then we wanna postpone that message to be added</span></span><br><span class="line"><span class="comment">     * after the command&#x27;s reply (specifically important during multi-exec). the exception is</span></span><br><span class="line"><span class="comment">     * the SUBSCRIBE command family, which (currently) have a push message instead of a proper reply.</span></span><br><span class="line"><span class="comment">     * The check for executing_client also avoids affecting push messages that are part of eviction. */</span></span><br><span class="line">    <span class="keyword">if</span> (c == server.current_client &amp;&amp; (c-&gt;flags &amp; CLIENT_PUSHING) &amp;&amp;</span><br><span class="line">        server.executing_client &amp;&amp; !cmdHasPushAsReply(server.executing_client-&gt;cmd))</span><br><span class="line">    &#123;</span><br><span class="line">        _addReplyProtoToList(c,server.pending_push_messages,s,len);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> reply_len = _addReplyToBuffer(c,s,len);</span><br><span class="line">    <span class="keyword">if</span> (len &gt; reply_len) _addReplyProtoToList(c,c-&gt;reply,s+reply_len,len-reply_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查看订阅信息"><a href="#查看订阅信息" class="headerlink" title="查看订阅信息"></a>查看订阅信息</h3><p><code>PUBSUB</code>是redis 2.8新增命令之一，客户端以此查看频道或者模式的相关信息。</p><h4 id="pubsub-channels"><a href="#pubsub-channels" class="headerlink" title="pubsub channels"></a>pubsub channels</h4><p><code>pubsub channels [patterns]</code>用于返回服务器当前被订阅的频道，其中<code>pattern</code>可选。</p><ol><li>指定<code>pattern</code>，返回服务器当前被订阅的频道中那些与<code>pattern</code>模式相匹配的频道。</li><li>不指定<code>pattern</code>参数，则命令返回服务器当前被订阅的所有频道。</li></ol><h4 id="pubsub-numsub"><a href="#pubsub-numsub" class="headerlink" title="pubsub numsub"></a>pubsub numsub</h4><p><code>pubsub numsub [channel1 channel2]</code>接收多个频道作为输入，返回这些频道的订阅者数量。这里是统计<code>pubsub_channels</code>的长度来实现的。</p><h4 id="pubsub-numpat"><a href="#pubsub-numpat" class="headerlink" title="pubsub numpat"></a>pubsub numpat</h4><p><code>pubsub numpat</code>用于返回服务器当前被订阅模式的数量。实现原理是返回<code>pubsub_patterns</code>的长度实现。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://github.com/redis/redis/blob/e792653753dc62b5a00822121e585511542a024b/src/pubsub.c">1. pubsub.c</a><br><a href="https://github.com/redis/redis/blob/a2046c1eb1bcfcdeffadfffffad3b1f635965652/src/networking.c">2. networking.c</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;redis的发布订阅功能由&lt;code&gt;publish|subscribe|psubscribe&lt;/code&gt;等命令组成。&lt;/p&gt;
&lt;h3 id=&quot;频道的订阅与退订&quot;&gt;&lt;a href=&quot;#频道的订阅与退订&quot; class=&quot;headerlink&quot; title=&quot;频道的订阅与退订</summary>
      
    
    
    
    <category term="databases" scheme="https://mqrayblog.cn/categories/databases/"/>
    
    
    <category term="redis" scheme="https://mqrayblog.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis之集群模式</title>
    <link href="https://mqrayblog.cn/2023/08/28/redis%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://mqrayblog.cn/2023/08/28/redis%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-08-28T09:44:38.000Z</published>
    <updated>2023-10-24T04:46:09.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis-集群模式"><a href="#redis-集群模式" class="headerlink" title="redis 集群模式"></a>redis 集群模式</h2><p>redis集群是redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。</p><h3 id="redis集群的优点"><a href="#redis集群的优点" class="headerlink" title="redis集群的优点"></a>redis集群的优点</h3><ol><li>高可用： 节点故障时，能自动进行故障转移，保证服务的持续可用。</li><li>负载均衡： 工作负载能够被分发到不同的节点上，有效分摊单节点访问压力。</li><li>容灾恢复：通过主从复制、哨兵机制，节点故障时能够快速进行故障恢复</li><li>数据分片： 集群模式下，可以由多个主节点执行写入操作</li><li>易于扩展：可以根据业务需求和系统负载，动态的添加或减少节点，实现水平扩展。</li></ol><h2 id="集群的实现原理"><a href="#集群的实现原理" class="headerlink" title="集群的实现原理"></a>集群的实现原理</h2><p>一个redis集群通常由多个节点组成。在集群建立前，每个节点都是相互独立的，都处于一个只包含自己的集群中。在组件集群时，需要将每个独立的节点连接起来，构成一个包含多个节点的集群。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>一个节点就是一个运行在集群模式下的redis服务器，服务器在启动时回一句<code>cluster-enabled</code>配置来决定是否开启服务器的集群模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./src/redis-server --cluster-enabled <span class="built_in">yes</span> <span class="comment"># 开启集群模式</span></span><br></pre></td></tr></table></figure><p>运行在集群模式下的服务器，会继续使用所有在单机模式中使用的服务器组件。例如：</p><ol><li>使用文件事件处理器来处理命令请求和返回命令回复。</li><li>使用时间事件处理器执行<code>serverCron</code>函数，在集群模式下继续调用<code>clusterCron</code>函数执行集群模式下的常规操作。</li><li>继续使用数据库保存键值对数据。</li><li>继续使用<code>rdb</code>和<code>aof</code>进行持久化。</li><li>继续使用发布订阅机制执行<code>publish、subscribe</code>命令。</li><li>继续使用复制模块进行节点的复制工作。</li><li>使用<code>lua</code>脚本环境来执行客户端输入的<code>lua</code>脚本。</li></ol><h3 id="集群创建"><a href="#集群创建" class="headerlink" title="集群创建"></a>集群创建</h3><p>在节点<code>A</code>上执行<code>cluster meet ip port</code>，其中<code>ip|port</code>指向节点<code>B</code>，可以让节点<code>A</code>向节点<code>B</code>进行握手，当握手成功时，节点<code>A</code>就会将<code>B</code>节点添加到<code>A</code>节点所在的集群中。</p><p>假设目前有<code>A|B|C</code>三个节点，分别对应<code>&lt;ip_a|port_a&gt;、&lt;ip_b|port_b&gt;、&lt;ip_c|port_c&gt;</code>，在未组建集群前，可以理解为三个集群。如果此时需要将三个节点组成一个集群，则需要执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip_a:port_a&gt;cluster meet ip_b port_b #将b节点加入到a节点所在集群中</span><br><span class="line">ip_a:port_a&gt;cluster meet ip_c port_c #将c节点加入到a节点所在集群中</span><br></pre></td></tr></table></figure><p>在客户端中，可以通过<code>cluster nodes</code>获取当前集群的节点信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.167.98.52:6379&gt; cluster nodes</span><br><span class="line">c87ec22247436ee75969a2a524a82cec4d0be9c6 192.167.240.46:6379@16379 master - 0 1693237335871 2 connected 5461-10922</span><br><span class="line">a1520d54c3f1093ba701283cc2a61405776168f2 192.167.98.52:6379@16379 myself,master - 0 1693237334000 3 connected 10923-16383</span><br><span class="line">1e50e943a3ebf1fc955922fff55df6d372861f4b 192.167.76.255:6379@16379 master - 0 1693237334863 1 connected 0-5460</span><br></pre></td></tr></table></figure><h4 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h4><h5 id="clusterNode"><a href="#clusterNode" class="headerlink" title="clusterNode"></a>clusterNode</h5><p>每一个节点都会使用一个<code>clusterNode</code>结构记录自身状态，并为集群中的其他节点创建一个相应的<code>clusterNode</code>结构，以此记录其他节点的状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="type">mstime_t</span> ctime; <span class="comment">// 节点创建时间</span></span><br><span class="line">    <span class="type">char</span> name[CLUSTER_NAMELEN]; <span class="comment">// 节点名称</span></span><br><span class="line">    <span class="type">char</span> shard_id[CLUSTER_NAMELEN]; <span class="comment">// 分片id</span></span><br><span class="line">    <span class="type">int</span> flags;      <span class="comment">// 节点标识</span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch; <span class="comment">// 配置纪元</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> slots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">// 当前节点负责哈希槽</span></span><br><span class="line">    <span class="type">uint16_t</span> *slot_info_pairs; <span class="comment">/* Slots info represented as (start/end) pair (consecutive index). */</span></span><br><span class="line">    <span class="type">int</span> slot_info_pairs_count; <span class="comment">/* Used number of slots in slot_info_pairs */</span></span><br><span class="line">    <span class="type">int</span> numslots;   <span class="comment">// 当前节点负责处理的槽位数量</span></span><br><span class="line">    <span class="type">int</span> numslaves;  <span class="comment">// 如果当前节点是主节点，记录其从节点数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span> <span class="comment">// 指向 从节点 的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span>;</span> <span class="comment">// 如果当前节点是从节点，则指向其主节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> last_in_ping_gossip; <span class="comment">/* The number of the last carried in the ping gossip section */</span></span><br><span class="line">    <span class="type">mstime_t</span> ping_sent;      <span class="comment">// 此节点上次发送 ping 消息的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> pong_received;  <span class="comment">// 上次收到 pong 消息的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> data_received;  <span class="comment">/* Unix time we received any data */</span></span><br><span class="line">    <span class="type">mstime_t</span> fail_time;      <span class="comment">// 上次 fail 的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> voted_time;     <span class="comment">/* Last time we voted for a slave of this master */</span></span><br><span class="line">    <span class="type">mstime_t</span> repl_offset_time;  <span class="comment">// 上次 接收到 offset 的时间</span></span><br><span class="line">    <span class="type">mstime_t</span> orphaned_time;     <span class="comment">/* Starting time of orphaned master condition */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_offset;      <span class="comment">// 上次接收到的 offset 值</span></span><br><span class="line">    <span class="type">char</span> ip[NET_IP_STR_LEN];    <span class="comment">// 节点上次使用的 ip</span></span><br><span class="line">    sds hostname;               <span class="comment">// hostname</span></span><br><span class="line">    sds human_nodename;         <span class="comment">/* The known human readable nodename for this node */</span></span><br><span class="line">    <span class="type">int</span> tcp_port;               <span class="comment">// 客户端tcp端口</span></span><br><span class="line">    <span class="type">int</span> tls_port;               <span class="comment">// 客户端 tls 使用的端口</span></span><br><span class="line">    <span class="type">int</span> cport;                  <span class="comment">// 节点暴露的端口</span></span><br><span class="line">    clusterLink *link;          <span class="comment">// 连接节点所需要的信息，比如套接字描述符、输入输出缓冲区</span></span><br><span class="line">    clusterLink *inbound_link;  <span class="comment">/* TCP/IP link accepted from this node */</span></span><br><span class="line">    <span class="built_in">list</span> *fail_reports;         <span class="comment">// 记录其他节点的下线报告</span></span><br><span class="line">&#125; clusterNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="clusterNodeFailReport"><a href="#clusterNodeFailReport" class="headerlink" title="clusterNodeFailReport"></a>clusterNodeFailReport</h5><p>用于记录与当前节点握手过的其他节点的下线报告。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span>  <span class="comment">/* Node reporting the failure condition. */</span></span><br><span class="line">    <span class="type">mstime_t</span> time;             <span class="comment">/* Time of the last report from this node. */</span></span><br><span class="line">&#125; clusterNodeFailReport;</span><br></pre></td></tr></table></figure><h5 id="clusterState"><a href="#clusterState" class="headerlink" title="clusterState"></a>clusterState</h5><p><code>clusterState</code>结构则记录了在当前节点视角下，集群目前所处的状态。如，集群状态、集群节点数量、分片</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    clusterNode *myself;  <span class="comment">// 当前节点</span></span><br><span class="line">    <span class="type">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="type">int</span> state;            <span class="comment">// 集群状态</span></span><br><span class="line">    <span class="type">int</span> size;             <span class="comment">// 主节点数量</span></span><br><span class="line">    dict *nodes;          <span class="comment">// 记录 name -&gt; clusterNode的哈希表</span></span><br><span class="line">    dict *shards;         <span class="comment">// 记录 shard_id -&gt; list(nodes) 的哈希表</span></span><br><span class="line">    dict *nodes_black_list; <span class="comment">/* Nodes we don&#x27;t re-add for a few seconds. */</span></span><br><span class="line">    clusterNode *migrating_slots_to[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *importing_slots_from[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS];</span><br><span class="line">    rax *slots_to_channels;</span><br><span class="line">    <span class="comment">/* The following fields are used to take the slave state on elections. */</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_auth_time; <span class="comment">/* Time of previous or next election. */</span></span><br><span class="line">    <span class="type">int</span> failover_auth_count;    <span class="comment">/* Number of votes received so far. */</span></span><br><span class="line">    <span class="type">int</span> failover_auth_sent;     <span class="comment">/* True if we already asked for votes. */</span></span><br><span class="line">    <span class="type">int</span> failover_auth_rank;     <span class="comment">/* This slave rank for current auth request. */</span></span><br><span class="line">    <span class="type">uint64_t</span> failover_auth_epoch; <span class="comment">/* Epoch of the current election. */</span></span><br><span class="line">    <span class="type">int</span> cant_failover_reason;   <span class="comment">/* Why a slave is currently not able to</span></span><br><span class="line"><span class="comment">                                   failover. See the CANT_FAILOVER_* macros. */</span></span><br><span class="line">    <span class="comment">/* Manual failover state in common. */</span></span><br><span class="line">    <span class="type">mstime_t</span> mf_end;            <span class="comment">/* Manual failover time limit (ms unixtime).</span></span><br><span class="line"><span class="comment">                                   It is zero if there is no MF in progress. */</span></span><br><span class="line">    <span class="comment">/* Manual failover state of master. */</span></span><br><span class="line">    clusterNode *mf_slave;      <span class="comment">/* Slave performing the manual failover. */</span></span><br><span class="line">    <span class="comment">/* Manual failover state of slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mf_master_offset; <span class="comment">/* Master offset the slave needs to start MF</span></span><br><span class="line"><span class="comment">                                   or -1 if still not received. */</span></span><br><span class="line">    <span class="type">int</span> mf_can_start;           <span class="comment">/* If non-zero signal that the manual failover</span></span><br><span class="line"><span class="comment">                                   can start requesting masters vote. */</span></span><br><span class="line">    <span class="comment">/* The following fields are used by masters to take state on elections. */</span></span><br><span class="line">    <span class="type">uint64_t</span> lastVoteEpoch;     <span class="comment">/* Epoch of the last vote granted. */</span></span><br><span class="line">    <span class="type">int</span> todo_before_sleep; <span class="comment">/* Things to do in clusterBeforeSleep(). */</span></span><br><span class="line">    <span class="comment">/* Stats */</span></span><br><span class="line">    <span class="comment">/* Messages received and sent by type. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stats_bus_messages_sent[CLUSTERMSG_TYPE_COUNT];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stats_bus_messages_received[CLUSTERMSG_TYPE_COUNT];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> stats_pfail_nodes;    <span class="comment">/* Number of nodes in PFAIL status,</span></span><br><span class="line"><span class="comment">                                       excluding nodes without address. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stat_cluster_links_buffer_limit_exceeded;  <span class="comment">/* Total number of cluster links freed due to exceeding buffer limit */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bit map for slots that are no longer claimed by the owner in cluster PING</span></span><br><span class="line"><span class="comment">     * messages. During slot migration, the owner will stop claiming the slot after</span></span><br><span class="line"><span class="comment">     * the ownership transfer. Set the bit corresponding to the slot when a node</span></span><br><span class="line"><span class="comment">     * stops claiming the slot. This prevents spreading incorrect information (that</span></span><br><span class="line"><span class="comment">     * source still owns the slot) using UPDATE messages. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> owner_not_claiming_slot[CLUSTER_SLOTS / <span class="number">8</span>];</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure><h4 id="cluster-meet-命令执行过程"><a href="#cluster-meet-命令执行过程" class="headerlink" title="cluster meet 命令执行过程"></a>cluster meet 命令执行过程</h4><p>通过向节点<code>A</code>发送<code>cluster meet &lt;ip_b&gt; &lt;port_b&gt;</code>，可以将节点<code>B</code>纳入到节点<code>A</code>所在的集群中。<br>节点<code>A</code>收到命令后，将与节点<code>B</code>进行握手以确定彼此存在，并继续执行如下操作：</p><ol><li>节点<code>A</code>为节点<code>B</code>创建一个<code>clusterNode</code>结构，并将该结构保存至自己的<code>clusterState.nodes</code>字典中。</li><li>节点<code>A</code>依据<code>cluster meet &lt;ip_b&gt; &lt;port_b&gt;</code>命令中的IP地址和端口号向节点<code>B</code>发送一条<code>MEET消息</code>。(后续会介绍消息格式)</li><li>如果一切顺利，节点<code>B</code>接收到节点<code>A</code>发送的<code>meet</code>消息，节点<code>B</code>会为节点<code>A</code>创建一个<code>clusterNode</code>结构，并将此结构添加到自己的<code>clusterState.nodes</code>字典中。</li><li>节点<code>B</code>向节点<code>A</code>发送<code>PONG</code>消息。</li><li>如果节点<code>A</code>收到节点<code>B</code>发送的<code>PONG</code>消息，则节点<code>A</code>可获悉节点<code>B</code>已经收到自己发送的<code>meet</code>消息。</li><li>节点<code>A</code>向节点<code>B</code>返回一条<code>PING</code>命令。</li><li>如果顺利，节点<code>B</code>收到节点<code>A</code>返回的<code>PING</code>消息，以此获悉节点<code>A</code>已经成功接收到节点<code>B</code>返回的<code>PONG</code>消息。此时，握手完成。<br>节点<code>A|B</code>集群组建过程的时序图如下：<img src="/2023/08/28/redis%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/redis_cluster_meet.png"></li></ol><h3 id="槽分派"><a href="#槽分派" class="headerlink" title="槽分派"></a>槽分派</h3><p>redis集群通过<code>分片</code>的方式来保存数据库中的键值对，集群的整个数据库被分为<code>16384</code>个槽位，数据库中的每个键都属于这些槽中的一个，集群中的每个节点可以处理0个或者<code>16384</code>个槽位。</p><p>当数据库中的<code>16384</code>个槽位都有节点在处理时，集群属于上线状态；否则，集群属于下线状态。</p><p>集群创建完毕后，可以使用如下命令将槽分配给节点a：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip_a:port_a&gt;cluster addslots &lt;slot&gt; [slot ...]</span><br></pre></td></tr></table></figure><p>当<code>16384</code>个槽位都有相应节点处理时，集群进入上线状态。可以使用<code>cluster info</code>查看集群状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">192.167.98.52:6379&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:3</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:3</span><br><span class="line">cluster_my_epoch:3</span><br><span class="line">cluster_stats_messages_ping_sent:849247</span><br><span class="line">cluster_stats_messages_pong_sent:834979</span><br><span class="line">cluster_stats_messages_fail_sent:1</span><br><span class="line">cluster_stats_messages_publish_sent:224</span><br><span class="line">cluster_stats_messages_sent:1684451</span><br><span class="line">cluster_stats_messages_ping_received:834979</span><br><span class="line">cluster_stats_messages_pong_received:849246</span><br><span class="line">cluster_stats_messages_fail_received:1</span><br><span class="line">cluster_stats_messages_publish_received:57273</span><br><span class="line">cluster_stats_messages_received:1741499</span><br></pre></td></tr></table></figure><h4 id="相关命令实现原理"><a href="#相关命令实现原理" class="headerlink" title="相关命令实现原理"></a>相关命令实现原理</h4><h5 id="cluster-addslots"><a href="#cluster-addslots" class="headerlink" title="cluster addslots"></a>cluster addslots</h5><p>该命令的实现可以理解为对<code>clusterNode.slots</code>和<code>clusterState.slots</code>的更新标注。</p><h5 id="执行命令过程"><a href="#执行命令过程" class="headerlink" title="执行命令过程"></a>执行命令过程</h5><p>当客户端向节点发送与数据库有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽位，并检查该槽位是否由当前节点处理。</p><ol><li>如果键所在槽位指派给当前节点，当前节点直接执行命令。</li><li>否则，节点向客户端返回<code>MOVED</code>错误，指引客户端重定向到正确的节点，并再次发送待执行的命令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.167.98.52:6379&gt; <span class="built_in">set</span> mqray181162 hh</span><br><span class="line">-&gt; Redirected to slot [2196] located at 192.167.76.255:6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>通过<code>cluster keyslot</code>可以查阅键所属的槽位：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">192.167.76.255:6379&gt; cluster keyslot mqray181162</span><br><span class="line">(<span class="built_in">integer</span>) 2196</span><br></pre></td></tr></table></figure><p>前面通过<code>cluster nodes</code>已获悉当前节点处理的槽位信息，可以看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.167.76.255:6379&gt; cluster nodes</span><br><span class="line">a1520d54c3f1093ba701283cc2a61405776168f2 192.167.98.52:6379@16379 master - 0 1693270395063 3 connected 10923-16383</span><br><span class="line">c87ec22247436ee75969a2a524a82cec4d0be9c6 192.167.240.46:6379@16379 master - 0 1693270396071 2 connected 5461-10922</span><br><span class="line">1e50e943a3ebf1fc955922fff55df6d372861f4b 192.167.76.255:6379@16379 myself,master - 0 1693270394000 1 connected 0-5460</span><br></pre></td></tr></table></figure><p>可以看到，<code>192.167.98.52:6379</code>节点负责处理的槽位区间为<code>10923-16383</code>，接收到命令时，检测到当前命令操作的键所指向的节点为<code>192.167.76.255:6379</code>后，返回了<code>MOVED</code>错误，重定向后重新执行该命令。<br>实际上，一个集群客户端通常会维护多个节点的套接字连接，而所谓的重定向只是换一个套接字来发送命令。</p><h5 id="key对应槽位的计算方式"><a href="#key对应槽位的计算方式" class="headerlink" title="key对应槽位的计算方式"></a>key对应槽位的计算方式</h5><p>使用<code>cluster keyslot key</code>可以获取键所属槽位，其计算公式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot  = CRC16(key) % 16384</span><br></pre></td></tr></table></figure><h4 id="节点如何记录槽位"><a href="#节点如何记录槽位" class="headerlink" title="节点如何记录槽位"></a>节点如何记录槽位</h4><h5 id="clusterNode-slots"><a href="#clusterNode-slots" class="headerlink" title="clusterNode.slots"></a>clusterNode.slots</h5><p><code>clusterNode</code>中通过如下两个属性记录该节点负责处理的槽位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> slots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">// 当前节点负责哈希槽</span></span><br><span class="line">    <span class="type">uint16_t</span> *slot_info_pairs; <span class="comment">/* Slots info represented as (start/end) pair (consecutive index). */</span></span><br><span class="line">    <span class="type">int</span> numslots;   <span class="comment">// 当前节点负责处理的槽位数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>slots</code>是一个二进制位数组，数组长度为<code>16384/8=2048</code>字节。<br>reis以0为起始索引，对<code>slots</code>数组中的<code>16384</code>个二进制位进行编号，根据索引上的二进制位来判断当前节点是否需要处理槽<code>i</code>。</p><blockquote><p>对于一个节点而言，检查具体某一个槽位是否被当前节点处理的时间复杂度是O(1)。<br>而<code>numslots</code>即为这个二进制数组中1的个数。</p></blockquote><h5 id="clusterState-slots"><a href="#clusterState-slots" class="headerlink" title="clusterState.slots"></a>clusterState.slots</h5><p>一个节点除了将自己所负责的槽位记录在<code>slots</code>数组中，还会将自己的<code>slots</code>数组通过消息的方式发送给集群中的其他节点，以通知其他节点，当前节点负责处理哪些槽位。<br>集群中的其他节点收到此消息，会更新该节点视角下的<code>clusterState.nodes</code>更新其中传递该消息的节点所负责的槽位分配情况。<br>因此，集群中的每个节点都知道数据库中<code>16384</code>个槽位的分配情况。</p><h4 id="集群槽位分配记录"><a href="#集群槽位分配记录" class="headerlink" title="集群槽位分配记录"></a>集群槽位分配记录</h4><p><code>clusterState</code>结构中记录了如下信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>slots</code>数组长达<code>16384</code>，记录了每个槽位被分配的节点<code>clusterNode</code>的指针。<br>如果<code>slots[i]==null</code>，则表示当前槽位尚未分配；如果指向某个<code>clusterNode</code>，则表示当前槽位被分配给该节点。</p><h4 id="为什么需要将节点槽位信息存储在-clusterNode中又需要存在-clusterState中？"><a href="#为什么需要将节点槽位信息存储在-clusterNode中又需要存在-clusterState中？" class="headerlink" title="为什么需要将节点槽位信息存储在 clusterNode中又需要存在 clusterState中？"></a>为什么需要将节点槽位信息存储在 clusterNode中又需要存在 clusterState中？</h4><p>如果只在<code>clusterNode.slots</code>中记录，则无法高效处理如下情况：</p><ol><li>检测槽位<code>i</code>是否被分配&#x2F;检测槽位<code>i</code>被分配给了哪个节点： 这两种场景需要遍历集群中的每个节点的<code>clusterNode.slots</code>数组，直到找到该槽位被分配的节点。时间复杂度为<code>O(N)</code>。而如果<code>clusterState.slots</code>存储了，则时间复杂度为<code>O(1)</code>。</li></ol><p>那么是否可以只将槽位分派信息记录在<code>clusterNode.slots</code>中呢？<br>由于redis槽位分配中，某节点的槽位分配会通过消息传递给集群中的其他节点，传递消息时只需要将<code>clusterNode.slots</code>传递出去即可。而如果只存在<code>clusterState.slots</code>中，那么每次传播槽位分派信息时，需要遍历<code>clusterState.slots</code>以获取当前的槽位分派信息。</p><h3 id="节点数据库的实现"><a href="#节点数据库的实现" class="headerlink" title="节点数据库的实现"></a>节点数据库的实现</h3><p>节点和单机服务器在数据方面的区别是： 节点只能使用0号数据库，而单机服务器则没有此限制。<br>除了将键值对保存在数据库中，还会用<code>clusterState。slots_to_keys</code>记录槽位和键之间的关系。注意，在当前版本中，这一结构被移动到<code>clusterInit.slotToKeyInit</code>函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize slots-keys map of given db. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">slotToKeyInit</span><span class="params">(redisDb *db)</span> &#123;</span><br><span class="line">    db-&gt;slots_to_keys = zcalloc(<span class="keyword">sizeof</span>(clusterSlotToKeyMapping));</span><br><span class="line">    clusterDictMetadata *dictmeta = dictMetadata(db-&gt;dict);</span><br><span class="line">    dictmeta-&gt;db = db;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slot to keys mapping for all slots, opaque outside this file. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterSlotToKeyMapping</span> &#123;</span></span><br><span class="line">    slotToKeys by_slot[CLUSTER_SLOTS];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Slot to keys for a single slot. The keys in the same slot are linked together</span></span><br><span class="line"><span class="comment"> * using dictEntry metadata. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">slotToKeys</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> count;             <span class="comment">/* Number of keys in the slot. */</span></span><br><span class="line">    dictEntry *head;            <span class="comment">/* The first key-value entry in the slot. */</span></span><br><span class="line">&#125; slotToKeys;</span><br></pre></td></tr></table></figure><h3 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h3><p>redis集群的重新分片是指可以将任意数量的已经指派给某个节点<code>A</code>(源节点)的槽位重新指派给节点<code>B</code>(目标节点)，并且相关槽位所属的键值对也会从源节点移动到目标节点。<br><code>重新分片</code>操作过程中集群不需要下线，且源节点和目标节点可以继续处理命令请求。</p><h4 id="重新分片的实现原理"><a href="#重新分片的实现原理" class="headerlink" title="重新分片的实现原理"></a>重新分片的实现原理</h4><p>集群中的重新分配操作是由redis的集群管理软件<code>redis-trib</code>负责执行的。redis提供了进行重新分片所需要的命令，而<code>redis-trib</code>通过向源目标节点发送命令来进行重新分片。<br><code>redis-trib</code>对集群的单个槽位进行分片的过程如下：<br><img src="/2023/08/28/redis%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/redis_cluster_sharding.png"></p><p>另外注意到，<code>clusterState</code>结构中记录了集群得重新分片信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    clusterNode *migrating_slots_to[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *importing_slots_from[CLUSTER_SLOTS];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>migrating_slots_to</code>记录了当前节点正在迁移至其他节点的槽。而<code>importing_slots_from</code>则记录了当前节点正在从哪些节点导入槽。</p><h4 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h4><p>重新分片过程中，可能存在这样一种场景：<br>待迁移的槽位中键值对部分存在于源节点中，另一部分被存储在目标节点中。<br>当客户端向源节点发送一个于数据库键有关的命令，并且命令要处理的数据库键恰好属于正在被迁移的槽时：</p><ol><li>源节点会先在自己的数据库中查找键，找到则执行客户端命令；</li><li>如果未找到，则该键有可能已经被迁移到了目标节点，源节点将向客户端返回一个<code>ASK错误</code>，指引这个客户端重定向到正在导入槽的目标节点，并再次发送之前想要执行的命令。(查看<code>clusterState.migrating_slots_to[i]</code>已检查是否在进行迁移，如果指向不为null，则重定向到指针指向的节点)</li></ol><h4 id="ASKING"><a href="#ASKING" class="headerlink" title="ASKING"></a>ASKING</h4><p>打开发送该命令的客户端的<code>redis_asking</code>标识，以使得客户端在遇到moved错误时能够破例在当前节点中执行关于槽i的命令一次。注意该标识是一次性的，当节点执行了一个带有<code>redis_asking</code>标识的客户端发送的命令后，该标志位将被移除。</p><h4 id="ASK错误-和-MOVED-错误"><a href="#ASK错误-和-MOVED-错误" class="headerlink" title="ASK错误 和 MOVED 错误"></a>ASK错误 和 MOVED 错误</h4><ul><li>MOVED错误： 槽的指派关系发生变化，使得客户端需要从 MOVED错误返回的 ip port 中获取到最新的槽位负责节点然后执行命令</li><li>ASK错误：是两个节点在迁移槽的过程中的临时措施，当客户端收到关于槽i的<code>ASK错误</code>后，客户端只会在接下来的一次命令请求中将关于槽i的命令请求发送至发生<code>ASK错误</code>所指示的节点。但对该客户端之后的命令请求无效。</li></ul><h3 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h3><p>集群模式中，节点分为主节点和从节点，主节点负责处理槽，从节点负责复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p><p>集群中有节点<code>A|b|c</code>，各有三个从节点，此时节点<code>A</code>下线，则将由<code>B|C</code>负责从节点<code>A</code>的从节点中选出一个作为新的主节点，由这个被选中的节点负责处理原先节点<code>A</code>负责的槽位，并继续处理客户端的命令请求。</p><h4 id="配置从节点"><a href="#配置从节点" class="headerlink" title="配置从节点"></a>配置从节点</h4><p>在前文中，集群架构还只是顶层的多个主节点。集群模式当然是支持为节点分配从节点的。使用如下命令可以让接收命令的节点成为<code>node_id</code>所指定的从节点，并开始对主节点进行复制。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate &lt;node_id &gt;</span><br></pre></td></tr></table></figure><h4 id="从节点如何复制主节点"><a href="#从节点如何复制主节点" class="headerlink" title="从节点如何复制主节点"></a>从节点如何复制主节点</h4><ol><li>收到命令的节点从<code>clusterNode.nodes</code>中找到<code>noed_id</code>对应节点的<code>clusterNode</code>结构，并且将自己的<code>clusterState.myself.slaveof</code>指向该节点，以记录当前正在复制的主节点。另外，将<code>clusterState.myself.flags</code>修改为<code>REDIS_NODE_slave</code>，以标识当前是从节点。</li><li>根据<code>clusterState.myself.slaveof</code>指向的<code>clusterNode</code>中保存的<code>IP|port</code>对主节点进行复制。<br><code>slaveof ip pport</code></li><li>一个节点成为从节点，并且开始复制主节点这一信息会<code>通过消息</code>发送给集群中的其他节点<br>，最终所有节点都会知道这一消息。</li></ol><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><h5 id="疑似下线-pfail"><a href="#疑似下线-pfail" class="headerlink" title="疑似下线 pfail"></a>疑似下线 pfail</h5><p>集群中的每个节点都会定期向集群中的其他节点发送<code>ping</code>消息，以此检测对方是否在线，如果该命令没有在规定时间内响应，那么发送消息的节点会将收到消息的节点标记为<code>pfail， 疑似下线</code>。<br>同理，集群中的各个节点会通过互相发消息的方式来交换集群中各个节点的状态信息。<br>如果主节点<code>A</code>通过消息得知主节点<code>B</code>认为主节点<code>C</code>进入疑似下线状态，则主节点<code>a</code>会将<code>clusterNode.nodes</code>中找到节点<code>C</code>，并将节点<code>B</code>报告的下线报告加入到<code>clusterNode.fail_reports</code>链表中。<br>每个下线报告中记录了如下信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This structure represent elements of node-&gt;fail_reports. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNodeFailReport</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span>  <span class="comment">// 报告目标节点下线的主节点</span></span><br><span class="line">    <span class="type">mstime_t</span> time;             <span class="comment">// 最后一次从node收到下线报告的时间</span></span><br><span class="line">&#125; clusterNodeFailReport;</span><br></pre></td></tr></table></figure><h5 id="已下线-fail"><a href="#已下线-fail" class="headerlink" title="已下线 fail"></a>已下线 fail</h5><p>如果在一个集群中，半数以上负责处理槽的主节点都将某个主节点<code>X</code>报告为疑似下线，那么这个节点<code>X</code>将被标记为<code>已下线</code>，将主节点标记为已下线的节点会向集群<code>广播</code>一条关于主节点<code>X</code>的<code>fail</code>消息，收到此消息的所有节点会立即将<code>clusterNode.nodes</code>中节点<code>X</code>的状态修改为已下线。</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><img src="/2023/08/28/redis%E4%B9%8B%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F/redis_cluster_fialover.png"><p>如果从节点检测到自己正在复制的主节点进入了下线状态，从节点将开始对下线主节点进行故障转移：</p><ol><li>复制下线节点的所有从节点中选出一个。</li><li>被选中的从节点执行<code>slaveof no one</code>，成为主节点</li><li>原先指派给下线主节点的槽位重新指派给当前节点。</li><li>向集群广播一条<code>pong</code>消息，通知集群中的其他节点，当前节点已成为主节点，并且负责接管下线节点所负责的槽位。</li><li>新的主节点开始接收和自己负责槽位相关的命令请求，故障转移完成。</li></ol><h5 id="集群选主"><a href="#集群选主" class="headerlink" title="集群选主"></a>集群选主</h5><p>从节点检测到主节点下线后如何进行选主？</p><ol><li>集群中的某个节点开始一次故障转移操作时，集群的配置纪元<code>+1</code>.</li><li>在每个配置纪元中，集群中每个负责处理槽的主节点拥有一次投票机会，第一个向此主节点请求投票的节点将获得投票。</li><li>从节点发现复制的主节点下线时，将广播<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，要求所有收到消息且具有投票权的主节点进行投票。</li><li>具有投票权且尚未投票的主节点，将返回消息<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>。</li><li>每个从节点统计自己获取的投票数量，如果得票数大于等于<code>N/2+1</code>，则此从节点将当选成为新的主节点。N是集群中具有投票权的主节点数量。</li><li>如果一个配置纪元中无法选出主节点，则将进行下一次选举。</li></ol><h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>节点发送的消息主要有如下五种：</p><ol><li><code>MEET</code>： 发送者通过客户端向接受者发送，标识请</li><li><code>PING</code>: 集群中的每个节点默认每隔一秒从已知的节点列表中随机选出<code>5</code>个节点，对最长时间没有发送过<code>ping</code>消息的节点发送<code>ping</code>消息，以此检测被选中的节点是否在线。如果节点<code>a</code>最后一次收到节点<code>b</code>发送的<code>PONG</code>消息的时间距当前时间已超出节点<code>a</code>设置的<code>cluster-node-timeout</code>的一般，那么节点<code>a</code>也会向节点<code>B</code>发送<code>ping</code>消息。</li><li><code>PONG</code>：接收者回复<code>meet|ping</code>命令；或者向节点广播<code>PONG</code>命令以通知其他节点当前节点状态变化。</li><li><code>FAIL</code>：主节点<code>A</code>判断主节点<code>B</code>进入<code>Fail</code>状态，节点<code>A</code>会向集群广播一条关于节点<code>B</code>fail的消息，所有收到此消息的节点都会立即将节点<code>B</code>标记为已下线。</li><li><code>publish</code>： 节点收到<code>publish</code>命令时，节点会执行命令，并向集群广播一条<code>publish</code>消息，所有接收到此消息的节点都会执行相同的<code>publish</code>命令。</li></ol><h4 id="gossip协议"><a href="#gossip协议" class="headerlink" title="gossip协议"></a>gossip协议</h4><h3 id="扩容-缩容"><a href="#扩容-缩容" class="headerlink" title="扩容 缩容"></a>扩容 缩容</h3><h4 id="扩容方案"><a href="#扩容方案" class="headerlink" title="扩容方案"></a>扩容方案</h4><ol><li>将新节点纳入集群， 使用<code>cluster meet</code>或者 <code>redis-trib add node</code></li><li>确定 加入的新节点 所负责的槽位， 同时查询<code>clusterState.slots</code>查询该槽位的原先被指派的主节点。</li><li>遍历 所有槽位， 将每个槽位关联的节点中的 键值对 迁移到 新加入的节点中。</li><li>该主节点负责的槽位全部迁移完毕，向集群广播当前的节点状态，负责迁移后槽位，以及相关命令的执行。</li></ol><h4 id="缩容方案"><a href="#缩容方案" class="headerlink" title="缩容方案"></a>缩容方案</h4><ol><li>是否是主节点。</li><li>是主节点，有无被分派的槽位。</li><li>有分配的槽位，先将当前负责的槽位分配到其他节点。</li><li>所有槽位完成重新指派并完成数据库键值对的迁移后，广播当前节点准备下线。</li><li>原先该主节点的从节点下线。</li></ol><h3 id="思考？"><a href="#思考？" class="headerlink" title="思考？"></a>思考？</h3><h4 id="为什么redis支持16384个槽位？"><a href="#为什么redis支持16384个槽位？" class="headerlink" title="为什么redis支持16384个槽位？"></a>为什么redis支持16384个槽位？</h4><p>前面我们提到过，redis中计算一个键所对应的槽位的计算方式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot  = CRC16(key) % <span class="number">16384</span></span><br></pre></td></tr></table></figure><p>而CRC16能够获得65535个值，那为什么redis只支持16384个呢？<br>原因在于，redis的各种检测命令、广播命令中，都会将携带<code>slots</code>信息。两者的开销分别是 <code>2^16/8=8KB</code>和<code>2^14/8=2KB</code>。<br>而redis集群模式最多支持<code>1000</code>个分片，故而选择16384相对65535是更合理的选择。</p><h5 id="为什么要传全量的slot状态？"><a href="#为什么要传全量的slot状态？" class="headerlink" title="为什么要传全量的slot状态？"></a>为什么要传全量的slot状态？</h5><p>因为分布式场景，基于状态的设计更合理，状态的传播具有幂等性</p><h6 id="为什么不考虑压缩？"><a href="#为什么不考虑压缩？" class="headerlink" title="为什么不考虑压缩？"></a>为什么不考虑压缩？</h6><p>集群规模较小的场景下，每个分片负责大量的slot，很难压缩。</p><p>详见<a href="https://github.com/redis/redis/issues/2576">https://github.com/redis/redis/issues/2576</a></p><h4 id="为什么-集群模式中不适用-发布订阅"><a href="#为什么-集群模式中不适用-发布订阅" class="headerlink" title="为什么 集群模式中不适用 发布订阅"></a>为什么 集群模式中不适用 发布订阅</h4><p>所有的publish命令都会向所有节点（包括从节点）进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重了带宽负担，对于在有大量节点的集群中频繁使用pub，会严重消耗带宽。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.cnblogs.com/yidengjiagou/p/17345831.html">1. redis集群模式</a><br><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html#%E7%8A%B6%E6%80%81%E6%A3%80%E6%B5%8B%E5%8F%8A%E7%BB%B4%E6%8A%A4">2. 状态检测及维护</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;redis-集群模式&quot;&gt;&lt;a href=&quot;#redis-集群模式&quot; class=&quot;headerlink&quot; title=&quot;redis 集群模式&quot;&gt;&lt;/a&gt;redis 集群模式&lt;/h2&gt;&lt;p&gt;redis集群是redis提供的分布式数据库方案，集群通过分片来进行数据共享</summary>
      
    
    
    
    <category term="databases" scheme="https://mqrayblog.cn/categories/databases/"/>
    
    
    <category term="redis" scheme="https://mqrayblog.cn/tags/redis/"/>
    
    <category term="源码阅读" scheme="https://mqrayblog.cn/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>java之ConcurrentHashMap</title>
    <link href="https://mqrayblog.cn/2023/08/28/java%E4%B9%8BConcurrentHashMap/"/>
    <id>https://mqrayblog.cn/2023/08/28/java%E4%B9%8BConcurrentHashMap/</id>
    <published>2023-08-28T09:44:02.000Z</published>
    <updated>2023-10-24T04:46:09.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://juejin.cn/post/7064061605185028110">1. 一文彻底弄懂ConcurrentHashMap</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7064061605185028110&quot;&gt;1. 一文彻底弄懂Concurre</summary>
      
    
    
    
    <category term="coding" scheme="https://mqrayblog.cn/categories/coding/"/>
    
    
    <category term="java" scheme="https://mqrayblog.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java之spring注解</title>
    <link href="https://mqrayblog.cn/2023/08/17/java%E4%B9%8Bspring%E6%B3%A8%E8%A7%A3/"/>
    <id>https://mqrayblog.cn/2023/08/17/java%E4%B9%8Bspring%E6%B3%A8%E8%A7%A3/</id>
    <published>2023-08-17T15:01:54.000Z</published>
    <updated>2023-10-24T04:46:09.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><ol><li>@Transactional</li><li>@TransmittableThreadLocal</li><li>@PostConstruct</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="http://mysql.taobao.org/monthly/2021/10/02/">1. PolarDB 数据库内核月报</a><br><a href="https://www.cnblogs.com/caoyc/p/5632963.html">2. spring @Transactional注解参数详解</a><br><a href="https://juejin.cn/post/6998552093795549191">3. TransmittableThreadLocal原理解析</a><br><a href="https://blog.csdn.net/wk52525/article/details/107859685">4. TransmittableThreadLocal（TTL）实现线程变量传递的原理分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;@Transactional&lt;/li&gt;
&lt;li&gt;@TransmittableThreadLocal&lt;/li&gt;
&lt;li&gt;@PostConstruct&lt;/li&gt;</summary>
      
    
    
    
    <category term="coding" scheme="https://mqrayblog.cn/categories/coding/"/>
    
    
    <category term="java" scheme="https://mqrayblog.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>redis之哨兵机制</title>
    <link href="https://mqrayblog.cn/2023/08/17/redis%E4%B9%8B%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/"/>
    <id>https://mqrayblog.cn/2023/08/17/redis%E4%B9%8B%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/</id>
    <published>2023-08-16T23:44:03.000Z</published>
    <updated>2023-10-24T04:46:09.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前文<a href="https://mqrayblog.cn/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">redis之主从复制</a>中，在讲述<code>redis</code>主从模式时，提及主从模式在主节点故障时，无法自主恢复，需要人工干预才能恢复。那么有没有什么方法可以使集群能够自动进行故障恢复呢？当然有，那就是<code>哨兵模式</code>。</p><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p>哨兵机制是<code>redis高可用</code>的解决方案： 由一个或者多个<code>sentinel</code>实例组成的<code>sentinel</code>系统监控任意多个主服务器，同时监控这些主服务器下的从服务器。在所监视的主服务器下线时，自动完成故障恢复：包括新选主、剩从切换新主、旧主变新从。故障恢复后，由新主处理命令请求。</p><img src="/2023/08/17/redis%E4%B9%8B%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/sentinel_arch.jpg">  <blockquote><p>第一次看到这里有疑惑，哨兵机制是对 主从做的改进， 那为什么 哨兵机制能够监控多个主服务器呢？此时的redis架构是多个 <code>主从=主从-主从</code> 模式么？</p></blockquote><p>综上所述，<code>哨兵机制需要提供如下服务</code>：</p><ol><li>感知 主服务器故障 </li><li>拥有故障恢复能力  [选主过程由谁落实，有哪些条件？]<ul><li>选取 leader sentinel  </li><li>选取新的主服务器</li><li>剩从切换新主</li><li>旧主变新从<br>那么<code>redis</code> 是如何为它提供如此能力的呢？</li></ul></li></ol><h3 id="如何理解哨兵？"><a href="#如何理解哨兵？" class="headerlink" title="如何理解哨兵？"></a>如何理解哨兵？</h3><p>目前可以先这样理解： <code>sentinel</code>是功能特殊的<code>redis</code>服务器，它能执行的命令不同于主从服务器。</p><h3 id="如何感知主服务器故障？"><a href="#如何感知主服务器故障？" class="headerlink" title="如何感知主服务器故障？"></a>如何感知主服务器故障？</h3><p>简单的概括是： 主观下线 + 客观下线</p><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p>在<code>sentinel.conf</code>中有如下配置，指定了<code>sentinel</code>判断主观下线的策略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br></pre></td></tr></table></figure><p>在默认情况下,<code>sentinel</code>会以每秒一次的频率向所有与它创建了命令连接的实例(包含主、从、sentinel)发送<code>ping</code>命令。通过实例的返回判断实例是否在线。<br>实例对<code>ping</code>命令的返回有两种：</p><ol><li>有效回复：实例返回<code>+PONG| -LOADING | -MASTERDOWN</code>三种回复中的一种。 </li><li>无效回复：上述三种外的回复，或者在指定时限内没有任何回复。<br>如果超出<code>down-after-milliseconds</code>未有有效回复，则<code>sentinel</code>会将该实例的<code>flags</code>状态修改为<code>SRI_S_DOWN</code>。</li></ol><p>上述配置不仅仅是<code>sentinel</code>判断主服务器的标准，同样是判断从服务器、其他<code>sentinel</code>是否主观下线的标准。</p><p>另外，要注意的是：对于监控同一个主服务器的多个<code>sentienl</code>而言，每个<code>sentinel</code>所设置的<code>down-after-milliseconds</code>可能不同，即不同<code>sentinel</code>判断主观下线的时长可能不同。</p><h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>当<code>sentinel</code>判断某个主服务器主观下线后，会确认是否这个主服务器真的下线了。于是，它会向其他监视该主服务器的其他<code>sentinel</code>发送请求，检查是否其他<code>sentinel</code>也认为该主服务器是否主观下线了。如果认为主服务器主观下线的<code>sentinel</code>数量超过配置值，则将进行后续的故障恢复操作。</p><p>判断客观下线的配置值是在<code>sentinel</code>启动时指定的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure><p>由于每个<code>sentinel</code>启动配置并不一致，所以会导致由不同的<code>sentinel</code>判断某主服务器主观下线的判断条件是不同的。</p><h3 id="如何进行故障恢复"><a href="#如何进行故障恢复" class="headerlink" title="如何进行故障恢复"></a>如何进行故障恢复</h3><p>当一个主服务器被标记为<code>客观下线</code>之后，监控该主服务器的各个<code>sentinel</code>会进行协商，选出一个 <code>leader sentinel</code>，由它完成下线主服务器的故障转移操作。</p><h4 id="如何选取leader-sentinel"><a href="#如何选取leader-sentinel" class="headerlink" title="如何选取leader sentinel"></a>如何选取leader sentinel</h4><p>所有<code>sentinel</code>都有可能成为领头<code>sentinel</code>。每次进行<code>leader sentinel</code>选举后，不论是否成功，所有<code>sentinel</code>的配置纪元<code>configuration epoch</code>的值都会自增。<br>在一个配置纪元里，所有<code>sentinel</code>都有一次将某个<code>sentinel</code>设置为局部领头<code>sentinel</code>的机会，且局部领头<code>sentinel</code>一旦被设置，在这个配置纪元里不能被更改。<br>发现主服务器客观下线的<code>sentinel</code>都会要求其他<code>sentinel</code>将自己设置为局部领头<code>sentinel</code>。发送的命令格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel is-master-down-by-addr ip port epoch run_id</span><br></pre></td></tr></table></figure><p>如果 <code>run_id != *</code>而是源<code>sentinel</code>的运行id时，则表明源<code>sentinel</code>要求目标<code>sentinel</code>将它设置为局部领头<code>sentinel</code><br><code>sentinel</code>设置局部领头<code>sentinel</code>的规则是先到先得，最先向<code>sentinel</code>发送请求要求设置为局部领头<code>sentinel</code>的将成为目标<code>sentinel</code>的局部领头<code>sentinel</code>，之后收到的设置要求都将被拒绝。</p><p>源<code>sentinel</code>收到上述命令的返回后，会检查回复中的<code>leader_epoch</code>的值是否和自己的相同，相同则继续比对<code>run_id</code>，如果相同则表示目标<code>sentinel</code>将源<code>sentinel</code>设置为了局部领头<code>sentinel</code>。<br>如果某个<code>sentinel</code>被超过半数<code>sentinel</code>选举为局部领头<code>sentinel</code>，则该<code>sentinel</code>为 <code>leader sentinel</code>。<br>一个配置纪元里，可能产生多个局部领头<code>sentinel</code>，但是只会产生一个 <code>leader sentinel</code>。 如果本次配置纪元无法选出 <code>leader sentinel</code>，则继续下一轮，知道选出  <code>leader sentinel</code>。</p><p>疑惑： 如果某一个sentinel挂了呢？似乎也不影响选主sentinel，只需要保障&gt; sentinel_nums &#x2F; 2 + 1即可 ，<code>sentinel_nums</code>为在线数量。  </p><p>在选出 <code>leader sentinel</code>后正式开始故障恢复过程。</p><h4 id="选取新的主服务器"><a href="#选取新的主服务器" class="headerlink" title="选取新的主服务器"></a>选取新的主服务器</h4><p>由 <code>leader sentinel</code> 从已下线主服务器的从服务器中，找出状态良好、数据完整的从服务器。然后向这个从服务器发送<code>slave no one</code>命令，将这个从服务器转换为主服务器。</p><p>选主的过程是，先将下线主服务器的从服务器保存在列表中，然后按照如下条件过滤：</p><ul><li>剔除所有正处于下线状态或者断线状态的从服务器。</li><li>删除列表中所有最近5min没有回复过<code>leader sentinel</code>发送的<code>INFO</code>命令的从服务器，保障所有剩下的从服务器和<code>leader sentinel</code>正常通信。</li><li>删除所有与下线主服务器连接断开超过 <code>down-after-millseconds * 10</code>的从服务器，以保障从服务器的数据库状态与下线主服务器状态尽可能一致。</li><li>根据从服务器的优先级，对列表中剩余的从服务器排序，选出优先级最高的从服务器。</li><li>如果优先级最高的从服务器有多个，则对比从服务器中的复制偏移量，最终选出偏移量最大的从服务器。</li><li>如果偏移量也存在一致的，则按照从服务器的<code>run_id</code>进行排序，选择<code>run_id</code>最小的从服务器。</li></ul><h4 id="剩从切换新主"><a href="#剩从切换新主" class="headerlink" title="剩从切换新主"></a>剩从切换新主</h4><p><code>leader sentinel</code>向剩余的从服务器发送<code>slave of &lt;new_master_ip&gt; &lt;new_master_port&gt;</code>。</p><h4 id="结合源码对应-故障转移状态"><a href="#结合源码对应-故障转移状态" class="headerlink" title="结合源码对应 故障转移状态"></a>结合源码对应 故障转移状态</h4><h5 id="旧主变新从"><a href="#旧主变新从" class="headerlink" title="旧主变新从"></a>旧主变新从</h5><p>最后，修改旧主服务器的实例结构，将其主服务器设置为 <code>&lt;new_master&gt;</code></p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="main函数中启动sentinel"><a href="#main函数中启动sentinel" class="headerlink" title="main函数中启动sentinel"></a>main函数中启动sentinel</h3><p>在<code>server.h</code>中有这样一段代码，用以检测当前是否是<code>sentinel</code>模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    ... </span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv, exec_name);</span><br><span class="line">    initServerConfig(); <span class="comment">// 初始化服务器配置</span></span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) &#123;</span><br><span class="line">        initSentinelConfig();</span><br><span class="line">        initSentinel();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    loadServerConfig(server.configfile, config_from_stdin, options);</span><br><span class="line">    <span class="comment">// 如果指定了配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (server.sentinel_mode) loadSentinelConfigFromQueue();</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) sentinelCheckConfigFile();</span><br><span class="line">    ...</span><br><span class="line">    initServer(); <span class="comment">// void initServer(void)</span></span><br><span class="line">    ...</span><br><span class="line">    initListeners();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode)&#123;</span><br><span class="line">        <span class="comment">// 非 sentinel模式，正常模式里的功能。--&gt; 可以对比 sentinel和 其他模式的差异！此处按下不表</span></span><br><span class="line">        aofLoadManifestFromDisk();</span><br><span class="line">        loadDataFromDisk();</span><br><span class="line">        aofOpenIfNeededOnServerStart();</span><br><span class="line">        aofDelHistoryFiles();</span><br><span class="line">        ...</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sentinelIsRunning();</span><br><span class="line">        <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">            redisCommunicateSystemd(<span class="string">&quot;STATUS=Ready to accept connections\n&quot;</span>);</span><br><span class="line">            redisCommunicateSystemd(<span class="string">&quot;READY=1\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main-checkForSentinelMode"><a href="#main-checkForSentinelMode" class="headerlink" title="main checkForSentinelMode"></a>main checkForSentinelMode</h4><p>通过<code>sentinel</code>的两种启动命令来判断是否是<code>sentinel</code>模式。<br><code>checkForSentinelMode</code>的 判断逻辑是：</p><ul><li>程序使用<code>redis-sentinel</code>可执行文件启动</li><li>启动配置中是否有配置项<code>--sentinel</code></li></ul><p>分别对应了<code>sentinel</code>的两种启动命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf // redis-sentinel程序</span><br><span class="line">redis-server /path/to/sentinel.conf --sentinel // redis-server程序</span><br></pre></td></tr></table></figure><p>具体的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">checkForSentinelMode</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> *exec_name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(exec_name,<span class="string">&quot;redis-sentinel&quot;</span>) != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; argc; j++)</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[j],<span class="string">&quot;--sentinel&quot;</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="main-initSentinelConfig"><a href="#main-initSentinelConfig" class="headerlink" title="main initSentinelConfig"></a>main initSentinelConfig</h4><p>如果是<code>sentinel</code>模式，则执行初始化操作：<br>在<code>initSentinelConfig</code>函数中使用<code>26379</code>代替<code>6379</code>作为服务的端口号，同时禁用服务器运行保护模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function overwrites a few normal Redis config default with Sentinel</span></span><br><span class="line"><span class="comment"> * specific defaults. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initSentinelConfig</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    server.port = REDIS_SENTINEL_PORT; <span class="comment">// #define REDIS_SENTINEL_PORT 26379</span></span><br><span class="line">    server.protected_mode = <span class="number">0</span>; <span class="comment">/* Sentinel must be exposed. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main-initSentinel"><a href="#main-initSentinel" class="headerlink" title="main initSentinel"></a>main initSentinel</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform the Sentinel mode initialization. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initSentinel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* Initialize various data structures. */</span></span><br><span class="line">    sentinel.current_epoch = <span class="number">0</span>;</span><br><span class="line">    sentinel.masters = dictCreate(&amp;instancesDictType); </span><br><span class="line">    sentinel.tilt = <span class="number">0</span>;</span><br><span class="line">    sentinel.tilt_start_time = <span class="number">0</span>;</span><br><span class="line">    sentinel.previous_time = mstime();</span><br><span class="line">    sentinel.running_scripts = <span class="number">0</span>;</span><br><span class="line">    sentinel.scripts_queue = listCreate(); <span class="comment">// 初始化一个列表</span></span><br><span class="line">    sentinel.announce_ip = <span class="literal">NULL</span>;</span><br><span class="line">    sentinel.announce_port = <span class="number">0</span>;</span><br><span class="line">    sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;</span><br><span class="line">    sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;</span><br><span class="line">    sentinel.sentinel_auth_pass = <span class="literal">NULL</span>;</span><br><span class="line">    sentinel.sentinel_auth_user = <span class="literal">NULL</span>;</span><br><span class="line">    sentinel.resolve_hostnames = SENTINEL_DEFAULT_RESOLVE_HOSTNAMES;</span><br><span class="line">    sentinel.announce_hostnames = SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES;</span><br><span class="line">    <span class="built_in">memset</span>(sentinel.myid,<span class="number">0</span>,<span class="keyword">sizeof</span>(sentinel.myid));</span><br><span class="line">    server.sentinel_config = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initSentinel</code>函数中使用<code>dict.h/dictCreate</code>初始化一个哈希表，用以保存<code>sentinelRedisInstance名称</code>和<code>sentinelRedisInstance</code>的映射。（后文中使用<code>sri</code>替代<code>sentinelRedisInstance</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Instance name (sds) -&gt; instance (sentinelRedisInstance pointer)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * also used for: sentinelRedisInstance-&gt;sentinels dictionary that maps</span></span><br><span class="line"><span class="comment"> * sentinels ip:port to last seen time in Pub/Sub hello message. */</span></span><br><span class="line">dictType instancesDictType = &#123;</span><br><span class="line">    dictSdsHash,               <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,         <span class="comment">/* key compare */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key destructor */</span></span><br><span class="line">    dictInstancesValDestructor,<span class="comment">/* val destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                       <span class="comment">/* allow to expand */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意到<code>initSentinel</code>执行完毕之后，诸多参数类似<code>sentinel_config</code>都还是空值。</p><h4 id="main-loadSentinelConfigFromQueue"><a href="#main-loadSentinelConfigFromQueue" class="headerlink" title="main -&gt; loadSentinelConfigFromQueue"></a>main -&gt; loadSentinelConfigFromQueue</h4><p><code>sentinelHandleConfiguration</code>函数中多个<code>if-else</code>块分别对应不同的执行命令。其中最主要的就是通过调用<code>sentinelHandleConfiguration</code>处理<code>sentinel</code>配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is used for loading the sentinel configuration from</span></span><br><span class="line"><span class="comment"> * pre_monitor_cfg, monitor_cfg and post_monitor_cfg list */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">loadSentinelConfigFromQueue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *err = <span class="literal">NULL</span>;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="type">int</span> linenum = <span class="number">0</span>;</span><br><span class="line">    sds line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if there is no sentinel_config entry, we can return immediately */</span></span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_config == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span> *sentinel_configs[<span class="number">3</span>] = &#123;</span><br><span class="line">        server.sentinel_config-&gt;pre_monitor_cfg,</span><br><span class="line">        server.sentinel_config-&gt;monitor_cfg,</span><br><span class="line">        server.sentinel_config-&gt;post_monitor_cfg</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* loading from pre monitor config queue first to avoid dependency issues</span></span><br><span class="line"><span class="comment">     * loading from monitor config queue</span></span><br><span class="line"><span class="comment">     * loading from the post monitor config queue */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(sentinel_configs) / <span class="keyword">sizeof</span>(sentinel_configs[<span class="number">0</span>]); j++) &#123;</span><br><span class="line">        listRewind(sentinel_configs[j],&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sentinelLoadQueueEntry</span> *<span class="title">entry</span> =</span> ln-&gt;value;</span><br><span class="line">            err = sentinelHandleConfiguration(entry-&gt;argv,entry-&gt;argc);</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                linenum = entry-&gt;linenum;</span><br><span class="line">                line = entry-&gt;line;</span><br><span class="line">                <span class="keyword">goto</span> loaderr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free sentinel_config when config loading is finished */</span></span><br><span class="line">    freeSentinelConfig();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">loaderr:</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n*** FATAL CONFIG FILE ERROR (Redis %s) ***\n&quot;</span>,</span><br><span class="line">        REDIS_VERSION);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Reading the configuration file, at line %d\n&quot;</span>, linenum);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&gt;&gt;&gt; &#x27;%s&#x27;\n&quot;</span>, line);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>, err);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="loadSentinelConfigFromQueue-sentinelHandleConfiguration"><a href="#loadSentinelConfigFromQueue-sentinelHandleConfiguration" class="headerlink" title="loadSentinelConfigFromQueue -&gt; sentinelHandleConfiguration"></a>loadSentinelConfigFromQueue -&gt; sentinelHandleConfiguration</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">sentinelHandleConfiguration</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> argc)</span> &#123;</span><br><span class="line"></span><br><span class="line">    sentinelRedisInstance *ri;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;monitor&quot;</span>) &amp;&amp; argc == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">/* monitor &lt;name&gt; &lt;host&gt; &lt;port&gt; &lt;quorum&gt; */</span></span><br><span class="line">        <span class="type">int</span> quorum = atoi(argv[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (quorum &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;Quorum must be 1 or greater.&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (createSentinelRedisInstance(argv[<span class="number">1</span>],SRI_MASTER,argv[<span class="number">2</span>],</span><br><span class="line">                                        atoi(argv[<span class="number">3</span>]),quorum,<span class="literal">NULL</span>) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sentinelCheckCreateInstanceErrors(SRI_MASTER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;down-after-milliseconds&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* down-after-milliseconds &lt;name&gt; &lt;milliseconds&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        ri-&gt;down_after_period = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;down_after_period &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;negative or zero time parameter.&quot;</span>;</span><br><span class="line">        sentinelPropagateDownAfterPeriod(ri);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;failover-timeout&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* failover-timeout &lt;name&gt; &lt;milliseconds&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        ri-&gt;failover_timeout = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;failover_timeout &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;negative or zero time parameter.&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;parallel-syncs&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* parallel-syncs &lt;name&gt; &lt;milliseconds&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        ri-&gt;parallel_syncs = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;notification-script&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* notification-script &lt;name&gt; &lt;path&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (access(argv[<span class="number">2</span>],X_OK) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Notification script seems non existing or non executable.&quot;</span>;</span><br><span class="line">        ri-&gt;notification_script = sdsnew(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;client-reconfig-script&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* client-reconfig-script &lt;name&gt; &lt;path&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (access(argv[<span class="number">2</span>],X_OK) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Client reconfiguration script seems non existing or &quot;</span></span><br><span class="line">                   <span class="string">&quot;non executable.&quot;</span>;</span><br><span class="line">        ri-&gt;client_reconfig_script = sdsnew(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;auth-pass&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* auth-pass &lt;name&gt; &lt;password&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        ri-&gt;auth_pass = sdsnew(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;auth-user&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* auth-user &lt;name&gt; &lt;username&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        ri-&gt;auth_user = sdsnew(argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;current-epoch&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* current-epoch &lt;epoch&gt; */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> current_epoch = strtoull(argv[<span class="number">1</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (current_epoch &gt; sentinel.current_epoch)</span><br><span class="line">            sentinel.current_epoch = current_epoch;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;myid&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != CONFIG_RUN_ID_SIZE)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Malformed Sentinel id in myid option.&quot;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(sentinel.myid,argv[<span class="number">1</span>],CONFIG_RUN_ID_SIZE);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;config-epoch&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* config-epoch &lt;name&gt; &lt;epoch&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        ri-&gt;config_epoch = strtoull(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">/* The following update of current_epoch is not really useful as</span></span><br><span class="line"><span class="comment">         * now the current epoch is persisted on the config file, but</span></span><br><span class="line"><span class="comment">         * we leave this check here for redundancy. */</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;config_epoch &gt; sentinel.current_epoch)</span><br><span class="line">            sentinel.current_epoch = ri-&gt;config_epoch;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;leader-epoch&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* leader-epoch &lt;name&gt; &lt;epoch&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        ri-&gt;leader_epoch = strtoull(argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;known-slave&quot;</span>) ||</span><br><span class="line">                !strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;known-replica&quot;</span>)) &amp;&amp; argc == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sentinelRedisInstance *slave;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* known-replica &lt;name&gt; &lt;ip&gt; &lt;port&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> ((slave = createSentinelRedisInstance(<span class="literal">NULL</span>,SRI_SLAVE,argv[<span class="number">2</span>],</span><br><span class="line">                    atoi(argv[<span class="number">3</span>]), ri-&gt;quorum, ri)) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sentinelCheckCreateInstanceErrors(SRI_SLAVE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;known-sentinel&quot;</span>) &amp;&amp;</span><br><span class="line">               (argc == <span class="number">4</span> || argc == <span class="number">5</span>)) &#123;</span><br><span class="line">        sentinelRedisInstance *si;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">5</span>) &#123; <span class="comment">/* Ignore the old form without runid. */</span></span><br><span class="line">            <span class="comment">/* known-sentinel &lt;name&gt; &lt;ip&gt; &lt;port&gt; [runid] */</span></span><br><span class="line">            ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> ((si = createSentinelRedisInstance(argv[<span class="number">4</span>],SRI_SENTINEL,argv[<span class="number">2</span>],</span><br><span class="line">                        atoi(argv[<span class="number">3</span>]), ri-&gt;quorum, ri)) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> sentinelCheckCreateInstanceErrors(SRI_SENTINEL);</span><br><span class="line">            &#125;</span><br><span class="line">            si-&gt;runid = sdsnew(argv[<span class="number">4</span>]);</span><br><span class="line">            sentinelTryConnectionSharing(si);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;rename-command&quot;</span>) &amp;&amp; argc == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">/* rename-command &lt;name&gt; &lt;command&gt; &lt;renamed-command&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        sds oldcmd = sdsnew(argv[<span class="number">2</span>]);</span><br><span class="line">        sds newcmd = sdsnew(argv[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">if</span> (dictAdd(ri-&gt;renamed_commands,oldcmd,newcmd) != DICT_OK) &#123;</span><br><span class="line">            sdsfree(oldcmd);</span><br><span class="line">            sdsfree(newcmd);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Same command renamed multiple times with rename-command.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;announce-ip&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* announce-ip &lt;ip-address&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span><br><span class="line">            sentinel.announce_ip = sdsnew(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;announce-port&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* announce-port &lt;port&gt; */</span></span><br><span class="line">        sentinel.announce_port = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;deny-scripts-reconfig&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* deny-scripts-reconfig &lt;yes|no&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((sentinel.deny_scripts_reconfig = yesnotoi(argv[<span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Please specify yes or no for the &quot;</span></span><br><span class="line">                   <span class="string">&quot;deny-scripts-reconfig options.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;sentinel-user&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* sentinel-user &lt;user-name&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span><br><span class="line">            sentinel.sentinel_auth_user = sdsnew(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;sentinel-pass&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* sentinel-pass &lt;password&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(argv[<span class="number">1</span>]))</span><br><span class="line">            sentinel.sentinel_auth_pass = sdsnew(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;resolve-hostnames&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* resolve-hostnames &lt;yes|no&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((sentinel.resolve_hostnames = yesnotoi(argv[<span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Please specify yes or no for the resolve-hostnames option.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;announce-hostnames&quot;</span>) &amp;&amp; argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* announce-hostnames &lt;yes|no&gt; */</span></span><br><span class="line">        <span class="keyword">if</span> ((sentinel.announce_hostnames = yesnotoi(argv[<span class="number">1</span>])) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Please specify yes or no for the announce-hostnames option.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(argv[<span class="number">0</span>],<span class="string">&quot;master-reboot-down-after-period&quot;</span>) &amp;&amp; argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* master-reboot-down-after-period &lt;name&gt; &lt;milliseconds&gt; */</span></span><br><span class="line">        ri = sentinelGetMasterByName(argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!ri) <span class="keyword">return</span> <span class="string">&quot;No such master with specified name.&quot;</span>;</span><br><span class="line">        ri-&gt;master_reboot_down_after_period = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;master_reboot_down_after_period &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;negative time parameter.&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unrecognized sentinel configuration statement.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一处<code>if-else</code>语句对应了<code>monitor &lt;name&gt; &lt;host&gt; &lt;port&gt; &lt;quorum&gt;</code>，从配置中读取 客观下线配置<code>quorum</code>，如果小于0，则直接退出。<br>而后调用<code>createSentinelRedisInstance</code>函数尝试创建<code>rsi</code>实例：</p><h6 id="sentinelHandleConfiguration-createSentinelRedisInstance"><a href="#sentinelHandleConfiguration-createSentinelRedisInstance" class="headerlink" title="sentinelHandleConfiguration -&gt; createSentinelRedisInstance"></a>sentinelHandleConfiguration -&gt; createSentinelRedisInstance</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用者</span></span><br><span class="line">createSentinelRedisInstance(argv[<span class="number">1</span>],SRI_MASTER,argv[<span class="number">2</span>],atoi(argv[<span class="number">3</span>]),quorum,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">sentinelRedisInstance *<span class="title function_">createSentinelRedisInstance</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> flags, <span class="type">char</span> *hostname, <span class="type">int</span> port, <span class="type">int</span> quorum, sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ri;</span><br><span class="line">    sentinelAddr *addr;</span><br><span class="line">    dict *table = <span class="literal">NULL</span>;</span><br><span class="line">    sds sdsname;</span><br><span class="line"></span><br><span class="line">    serverAssert(flags &amp; (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));</span><br><span class="line">    serverAssert((flags &amp; SRI_MASTER) || master != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check address validity. */</span></span><br><span class="line">    addr = createSentinelAddr(hostname,port,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For slaves use ip/host:port as name. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SRI_SLAVE)</span><br><span class="line">        sdsname = announceSentinelAddrAndPort(addr);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sdsname = sdsnew(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查以防止master、slave、sentinel重复添加</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SRI_MASTER) table = sentinel.masters; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; SRI_SLAVE) table = master-&gt;slaves;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; SRI_SENTINEL) table = master-&gt;sentinels;</span><br><span class="line">    <span class="keyword">if</span> (dictFind(table,sdsname)) &#123;</span><br><span class="line">        releaseSentinelAddr(addr);</span><br><span class="line">        sdsfree(sdsname);</span><br><span class="line">        errno = EBUSY;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 rsi 实例，并赋初值</span></span><br><span class="line">    ri = zmalloc(<span class="keyword">sizeof</span>(*ri));</span><br><span class="line">    <span class="comment">/* Note that all the instances are started in the disconnected state,</span></span><br><span class="line"><span class="comment">     * the event loop will take care of connecting them. */</span></span><br><span class="line">    ri-&gt;flags = flags;</span><br><span class="line">    ri-&gt;name = sdsname;</span><br><span class="line">    ri-&gt;runid = <span class="literal">NULL</span>;</span><br><span class="line">    ri-&gt;config_epoch = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;addr = addr;</span><br><span class="line">    ri-&gt;link = createInstanceLink();  <span class="comment">// 这个要重点关注</span></span><br><span class="line">    ri-&gt;last_pub_time = mstime();</span><br><span class="line">    ri-&gt;last_hello_time = mstime();</span><br><span class="line">    ri-&gt;last_master_down_reply_time = mstime();</span><br><span class="line">    ri-&gt;s_down_since_time = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;o_down_since_time = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;down_after_period = master ? master-&gt;down_after_period : sentinel_default_down_after;</span><br><span class="line">    ri-&gt;master_reboot_down_after_period = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;master_link_down_time = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;auth_pass = <span class="literal">NULL</span>;</span><br><span class="line">    ri-&gt;auth_user = <span class="literal">NULL</span>;</span><br><span class="line">    ri-&gt;slave_priority = SENTINEL_DEFAULT_SLAVE_PRIORITY;</span><br><span class="line">    ri-&gt;replica_announced = <span class="number">1</span>;</span><br><span class="line">    ri-&gt;slave_reconf_sent_time = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;slave_master_host = <span class="literal">NULL</span>;</span><br><span class="line">    ri-&gt;slave_master_port = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;slave_master_link_status = SENTINEL_MASTER_LINK_STATUS_DOWN;</span><br><span class="line">    ri-&gt;slave_repl_offset = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;sentinels = dictCreate(&amp;instancesDictType);</span><br><span class="line">    ri-&gt;quorum = quorum;</span><br><span class="line">    ri-&gt;parallel_syncs = SENTINEL_DEFAULT_PARALLEL_SYNCS;</span><br><span class="line">    ri-&gt;master = master;</span><br><span class="line">    ri-&gt;slaves = dictCreate(&amp;instancesDictType);</span><br><span class="line">    ri-&gt;info_refresh = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;renamed_commands = dictCreate(&amp;renamedCommandsDictType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 故障恢复 相关功能配置</span></span><br><span class="line">    ri-&gt;leader = <span class="literal">NULL</span>;</span><br><span class="line">    ri-&gt;leader_epoch = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;failover_epoch = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_NONE;</span><br><span class="line">    ri-&gt;failover_state_change_time = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;failover_start_time = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;failover_timeout = sentinel_default_failover_timeout;</span><br><span class="line">    ri-&gt;failover_delay_logged = <span class="number">0</span>;</span><br><span class="line">    ri-&gt;promoted_slave = <span class="literal">NULL</span>;</span><br><span class="line">    ri-&gt;notification_script = <span class="literal">NULL</span>;</span><br><span class="line">    ri-&gt;client_reconfig_script = <span class="literal">NULL</span>;</span><br><span class="line">    ri-&gt;info = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前 rsi的实例角色</span></span><br><span class="line">    ri-&gt;role_reported = ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE);</span><br><span class="line">    ri-&gt;role_reported_time = mstime();</span><br><span class="line">    ri-&gt;slave_conf_change_time = mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add into the right table. */</span></span><br><span class="line">    dictAdd(table, ri-&gt;name, ri);</span><br><span class="line">    <span class="keyword">return</span> ri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>createSentinelRedisInstance</code>函数时需要传入：</p><ol><li>runid： 设置为null，将在第一次收到<code>info</code>的响应时填充。</li><li>info_refresh: 如果置为0，则说明尚未收到<code>info</code>响应。</li><li>如果设置为<code>SRI_MASTER</code>，它将被加入到<code>sentinel.masters</code>中；如果是<code>SRI_SLAVE</code>或者<code>SRI_SENTINEL</code>，则<code>master！=null</code>且将会被加入到<code>master-&gt;slaves</code>或者<code>master-&gt;sentinels</code>中。</li><li>在<code>SRI_SLAVE</code>时，传入的<code>name</code>字段将会被忽略，创建出的<code>sri</code>中的名称将自动创建，形如<code>ip/hostname:port</code>。</li><li><code>createSentinelRedisInstance</code>创建失败的场景包括：<ul><li>hostname无法被解析。</li><li>端口超出范围。</li><li>master重名，slave地址重复或者 sentinel id重复等。</li></ul></li></ol><p><code>createSentinelRedisInstance</code>中主要包含如下逻辑：</p><ol><li>检查地址有效性</li><li>为slave等分配name</li><li>对比table， 保障实例不会被反复添加</li><li>创建<code>rsi</code>并赋初值 <ul><li>sentinel配置</li><li>故障恢复配置</li><li>sentinel 角色配置</li></ul></li><li>name-rsi table更新</li></ol><p>而后调用栈返回，抵达<code>loadSentinelConfigFromQueue</code>，释放<code>sentinel_config</code>配置。</p><h3 id="main-sentinelCheckConfigFile"><a href="#main-sentinelCheckConfigFile" class="headerlink" title="main -&gt; sentinelCheckConfigFile"></a>main -&gt; sentinelCheckConfigFile</h3><p>此时程序返回，继续执行<code>server.c/sentinelCheckConfigFile</code>中，检查<code>sentinel</code>是否被设置以及检查该配置为简是否有写权限，如果异常则返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is for checking whether sentinel config file has been set,</span></span><br><span class="line"><span class="comment"> * also checking whether we have write permissions. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelCheckConfigFile</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// server.configfile 在 server.c 中已被赋值</span></span><br><span class="line">    <span class="keyword">if</span> (server.configfile == <span class="literal">NULL</span>) &#123; </span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Sentinel needs config file on disk to save state. Exiting...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (access(server.configfile,W_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Sentinel config file %s is not writable: %s. Exiting...&quot;</span>,</span><br><span class="line">            server.configfile,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-sentinelIsRunning"><a href="#main-sentinelIsRunning" class="headerlink" title="main -&gt; sentinelIsRunning"></a>main -&gt; sentinelIsRunning</h3><p>完成<code>rsi</code>初始化以及<code>initServer</code>和<code>initListeners</code>之后，还会检查是否<code>sentinel</code>状态，如果是<code>sentinel模式</code>，则调用<code>sentinelIsRunning</code>检查其运行状态；否则，开启额外配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelIsRunning</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CONFIG_RUN_ID_SIZE; j++)</span><br><span class="line">        <span class="keyword">if</span> (sentinel.myid[j] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">        <span class="comment">/* Pick ID and persist the config. */</span></span><br><span class="line">        getRandomHexChars(sentinel.myid,CONFIG_RUN_ID_SIZE);</span><br><span class="line">        sentinelFlushConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Log its ID to make debugging of issues simpler. */</span></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Sentinel ID is %s&quot;</span>, sentinel.myid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We want to generate a +monitor event for every configured master</span></span><br><span class="line"><span class="comment">     * at startup. */</span></span><br><span class="line">    sentinelGenerateInitialMonitorEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sentinelIsRunning</code>中检查该<code>rsi</code>是否有<code>runid</code>，如果没有则随机生成一个并刷入到磁盘文件中。然后调用<code>sentinelGenerateInitialMonitorEvents</code>函数生成监听事件。</p><h4 id="sentinelIsRunning-sentinelGenerateInitialMonitorEvents"><a href="#sentinelIsRunning-sentinelGenerateInitialMonitorEvents" class="headerlink" title="sentinelIsRunning -&gt; sentinelGenerateInitialMonitorEvents"></a>sentinelIsRunning -&gt; sentinelGenerateInitialMonitorEvents</h4><p><code>sentinelGenerateInitialMonitorEvents</code>函数遍历<code>sentinel.masters</code>，为每一个待监听的<code>sentinel</code>创建<code>+monitor</code>事件。<br>该方法在每次调用<code>sentinel monitor master ip port quorum</code>命令时触发，用以为每一个配置的<code>master</code>创建<code>+monitor event</code>事件。<br><code>sentinel monitor</code>命令的作用是让<code>sentinel</code>监听主节点配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called only at startup and is used to generate a</span></span><br><span class="line"><span class="comment"> * +monitor event for every configured master. The same events are also</span></span><br><span class="line"><span class="comment"> * generated when a master to monitor is added at runtime via the</span></span><br><span class="line"><span class="comment"> * SENTINEL MONITOR command. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelGenerateInitialMonitorEvents</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    di = dictGetIterator(sentinel.masters); </span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;+monitor&quot;</span>,ri,<span class="string">&quot;%@ quorum %d&quot;</span>,ri-&gt;quorum);</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sentinelEvent</code>函数的逻辑如下：<br>如果日志级别非<code>LL_DEBUG</code>，则调用<code>pubsubPublishMessage</code>传递该事件通知。其实现位于<code>pubsub.c</code>中。<br>如果日志级别为<code>LL_DEBUG</code>且<code>ri！=null</code>，且指定了通知脚本，则调用<code>sentinelScheduleScriptExecution</code>传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelEvent</span><span class="params">(<span class="type">int</span> level, <span class="type">char</span> *type, sentinelRedisInstance *ri,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">char</span> msg[LOG_MAX_LEN];</span><br><span class="line">    robj *channel, *payload;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle %@ */</span></span><br><span class="line">    <span class="keyword">if</span> (fmt[<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span> &amp;&amp; fmt[<span class="number">1</span>] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ?</span><br><span class="line">                                         <span class="literal">NULL</span> : ri-&gt;master;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (master) &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(msg, <span class="keyword">sizeof</span>(msg), <span class="string">&quot;%s %s %s %d @ %s %s %d&quot;</span>,</span><br><span class="line">                sentinelRedisInstanceTypeStr(ri),</span><br><span class="line">                ri-&gt;name, announceSentinelAddr(ri-&gt;addr), ri-&gt;addr-&gt;port,</span><br><span class="line">                master-&gt;name, announceSentinelAddr(master-&gt;addr), master-&gt;addr-&gt;port);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(msg, <span class="keyword">sizeof</span>(msg), <span class="string">&quot;%s %s %s %d&quot;</span>,</span><br><span class="line">                sentinelRedisInstanceTypeStr(ri),</span><br><span class="line">                ri-&gt;name, announceSentinelAddr(ri-&gt;addr), ri-&gt;addr-&gt;port);</span><br><span class="line">        &#125;</span><br><span class="line">        fmt += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use vsprintf for the rest of the formatting if any. */</span></span><br><span class="line">    <span class="keyword">if</span> (fmt[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        vsnprintf(msg+<span class="built_in">strlen</span>(msg), <span class="keyword">sizeof</span>(msg)-<span class="built_in">strlen</span>(msg), fmt, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Log the message if the log level allows it to be logged. */</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt;= server.verbosity)</span><br><span class="line">        serverLog(level,<span class="string">&quot;%s %s&quot;</span>,type,msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Publish the message via Pub/Sub if it&#x27;s not a debugging one. */</span></span><br><span class="line">    <span class="keyword">if</span> (level != LL_DEBUG) &#123;</span><br><span class="line">        channel = createStringObject(type,<span class="built_in">strlen</span>(type));</span><br><span class="line">        payload = createStringObject(msg,<span class="built_in">strlen</span>(msg));</span><br><span class="line">        pubsubPublishMessage(channel,payload,<span class="number">0</span>);</span><br><span class="line">        decrRefCount(channel);</span><br><span class="line">        decrRefCount(payload);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the notification script if applicable. */</span></span><br><span class="line">    <span class="keyword">if</span> (level == LL_WARNING &amp;&amp; ri != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ?</span><br><span class="line">                                         ri : ri-&gt;master;</span><br><span class="line">        <span class="keyword">if</span> (master &amp;&amp; master-&gt;notification_script) &#123;</span><br><span class="line">            sentinelScheduleScriptExecution(master-&gt;notification_script,</span><br><span class="line">                type,msg,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此<code>rsi</code>就创建完毕了，但是各实例间是如何通信的呢？来看下面这段代码：</p><h3 id="serverCron"><a href="#serverCron" class="headerlink" title="serverCron"></a>serverCron</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">serverCron</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.sentinel_mode) sentinelTimer();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="serverCron-sentinelTimer"><a href="#serverCron-sentinelTimer" class="headerlink" title="serverCron -&gt; sentinelTimer"></a>serverCron -&gt; sentinelTimer</h4><p>在<code>server.c/main</code>代码块的末尾，会注册事件循环，每次注册事件的时会调用<code>aeCreateTimeEvent</code>创建时间事件。<br>来看<code>sentinelTimer</code>函数具体做了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelTimer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    sentinelCheckTiltCondition();</span><br><span class="line">    sentinelHandleDictOfRedisInstances(sentinel.masters);</span><br><span class="line">    sentinelRunPendingScripts();</span><br><span class="line">    sentinelCollectTerminatedScripts();</span><br><span class="line">    sentinelKillTimedoutScripts();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We continuously change the frequency of the Redis &quot;timer interrupt&quot;</span></span><br><span class="line"><span class="comment">     * in order to desynchronize every Sentinel from every other.</span></span><br><span class="line"><span class="comment">     * This non-determinism avoids that Sentinels started at the same time</span></span><br><span class="line"><span class="comment">     * exactly continue to stay synchronized asking to be voted at the</span></span><br><span class="line"><span class="comment">     * same time again and again (resulting in nobody likely winning the</span></span><br><span class="line"><span class="comment">     * election because of split brain voting). */</span></span><br><span class="line">    server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>sentinelTimer</code>中主要分为三部分：</p><ol><li>检查是否处于<code>titl</code>静默模式中</li><li>处理<code>rsi</code>实例</li><li>处理脚本</li></ol><h4 id="sentinelTimer-sentinelCheckTiltCondition"><a href="#sentinelTimer-sentinelCheckTiltCondition" class="headerlink" title="sentinelTimer -&gt;  sentinelCheckTiltCondition"></a>sentinelTimer -&gt;  sentinelCheckTiltCondition</h4><p>下面逐一来看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelCheckTiltCondition</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">mstime_t</span> now = mstime();</span><br><span class="line">    <span class="type">mstime_t</span> delta = now - sentinel.previous_time;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span> || delta &gt; sentinel_tilt_trigger) &#123;</span><br><span class="line">        sentinel.tilt = <span class="number">1</span>;</span><br><span class="line">        sentinel.tilt_start_time = mstime();</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;+tilt&quot;</span>,<span class="literal">NULL</span>,<span class="string">&quot;#tilt mode entered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sentinel.previous_time = mstime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sentinelCheckTiltCondition</code>函数检查当前<code>sentinel</code>是否进入<code>TILT</code>状态: 如果检测到两次时间任务的返回值为负数或者非常大的数，则将进入<code>TILT</code>模式。在进入<code>TITL</code>模式后，等待<code>SENTINEL_TILT_PERIOD </code>再执行操作。<br>出现如上现象的原因有：</p><ol><li><code>sentinel</code>在处理某些任务时阻塞了，可能原因是加载过大的数据，主机io异常，进程接收到信号stop。</li><li>系统时钟发生了重大变化。</li></ol><h4 id="sentinelTimer-sentinelHandleDictOfRedisInstances"><a href="#sentinelTimer-sentinelHandleDictOfRedisInstances" class="headerlink" title="sentinelTimer -&gt;  sentinelHandleDictOfRedisInstances"></a>sentinelTimer -&gt;  sentinelHandleDictOfRedisInstances</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform scheduled operations for all the instances in the dictionary.</span></span><br><span class="line"><span class="comment"> * Recursively call the function against dictionaries of slaves. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelHandleDictOfRedisInstances</span><span class="params">(dict *instances)</span> &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    sentinelRedisInstance *switch_to_promoted = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There are a number of things we need to perform against every master. */</span></span><br><span class="line">    di = dictGetIterator(instances);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        sentinelHandleRedisInstance(ri);</span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line">            sentinelHandleDictOfRedisInstances(ri-&gt;slaves);</span><br><span class="line">            sentinelHandleDictOfRedisInstances(ri-&gt;sentinels);</span><br><span class="line">            <span class="keyword">if</span> (ri-&gt;failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) &#123;</span><br><span class="line">                switch_to_promoted = ri;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (switch_to_promoted)</span><br><span class="line">        sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sentinelHandleDictOfRedisInstances</code>函数执行时传参为<code>sentinel.masters</code>,该值在<code>initSentinel</code>时初始化，在<code>createSentinelRedisInstance</code>中完成赋值。<br>遍历当前模式中的所有主服务器，执行<code>sentinelHandleRedisInstance</code>操作。<br>如果当前遍历到的服务器是主服务器，则还需要对其<code>sentinels</code>和<code>slaves</code>进行相同的处理。<br><code>sentinelHandleDictOfRedisInstances</code>中递归处理<code>rsi</code>实例，并判断是否需要故障恢复并完成<code>主节点的选举</code>。</p><h5 id="sentinelHandleDictOfRedisInstances-sentinelHandleRedisInstance"><a href="#sentinelHandleDictOfRedisInstances-sentinelHandleRedisInstance" class="headerlink" title="sentinelHandleDictOfRedisInstances -&gt; sentinelHandleRedisInstance"></a>sentinelHandleDictOfRedisInstances -&gt; sentinelHandleRedisInstance</h5><p><code>sentinelHandleRedisInstance</code>函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform scheduled operations for the specified Redis instance. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelHandleRedisInstance</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="comment">/* ========== MONITORING HALF ============ */</span></span><br><span class="line">    <span class="comment">/* Every kind of instance */</span></span><br><span class="line">    sentinelReconnectInstance(ri);</span><br><span class="line">    sentinelSendPeriodicCommands(ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ============== ACTING HALF ============= */</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t proceed with the acting half if we are in TILT mode.</span></span><br><span class="line"><span class="comment">     * TILT happens when we find something odd with the time, like a</span></span><br><span class="line"><span class="comment">     * sudden change in the clock. */</span></span><br><span class="line">    <span class="keyword">if</span> (sentinel.tilt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mstime()-sentinel.tilt_start_time &lt; sentinel_tilt_period) <span class="keyword">return</span>;</span><br><span class="line">        sentinel.tilt = <span class="number">0</span>;</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;-tilt&quot;</span>,<span class="literal">NULL</span>,<span class="string">&quot;#tilt mode exited&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Every kind of instance */</span></span><br><span class="line">    sentinelCheckSubjectivelyDown(ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Masters and slaves */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &#123;</span><br><span class="line">        <span class="comment">/* Nothing so far. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only masters */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line">        sentinelCheckObjectivelyDown(ri);</span><br><span class="line">        <span class="keyword">if</span> (sentinelStartFailoverIfNeeded(ri))</span><br><span class="line">            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</span><br><span class="line">        sentinelFailoverStateMachine(ri);</span><br><span class="line">        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要包含如下操作：</p><ol><li>sentinel重连其他实例。  </li><li>sentinel向其他实例发送定期任务。  </li><li>判断是否titl模式，如果是则发送<code>-titl</code>事件。</li><li>对每种类型的实例判断是否主观下线。</li><li>针对<code>master</code>，判断是否客观下线。<ul><li>如果需要进行故障恢复，向其他<code>sentinel</code>询问<code>master</code>的状态。</li><li>选出执行故障恢复的 <code>leader sentinel</code>。</li><li>向其他<code>sentinel</code>询问<code>master</code>的状态。</li></ul></li></ol><p>如果当前已经变为保护模式，则执行<code>sentinelFailoverSwitchToPromotedSlave</code>函数。</p><p>这部分代码逻辑不在此处展开，放到后面的具体场景中介绍。</p><h6 id="sentinelHandleRedisInstance-sentinelReconnectInstance"><a href="#sentinelHandleRedisInstance-sentinelReconnectInstance" class="headerlink" title="sentinelHandleRedisInstance -&gt; sentinelReconnectInstance"></a>sentinelHandleRedisInstance -&gt; sentinelReconnectInstance</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create the async connections for the instance link if the link</span></span><br><span class="line"><span class="comment"> * is disconnected. Note that link-&gt;disconnected is true even if just</span></span><br><span class="line"><span class="comment"> * one of the two links (commands and pub/sub) is missing. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelReconnectInstance</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;addr-&gt;port == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* port == 0 means invalid address. */</span></span><br><span class="line">    instanceLink *link = ri-&gt;link;</span><br><span class="line">    <span class="type">mstime_t</span> now = mstime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now - ri-&gt;link-&gt;last_reconn_time &lt; sentinel_ping_period) <span class="keyword">return</span>;</span><br><span class="line">    ri-&gt;link-&gt;last_reconn_time = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Commands connection. */</span></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;cc == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* It might be that the instance is disconnected because it wasn&#x27;t available earlier when the instance</span></span><br><span class="line"><span class="comment">         * allocated, say during failover, and therefore we failed to resolve its ip.</span></span><br><span class="line"><span class="comment">         * Another scenario is that the instance restarted with new ip, and we should resolve its new ip based on</span></span><br><span class="line"><span class="comment">         * its hostname */</span></span><br><span class="line">        <span class="keyword">if</span> (sentinel.resolve_hostnames) &#123;</span><br><span class="line">            sentinelAddr *tryResolveAddr = createSentinelAddr(ri-&gt;addr-&gt;hostname, ri-&gt;addr-&gt;port, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (tryResolveAddr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                releaseSentinelAddr(ri-&gt;addr);</span><br><span class="line">                ri-&gt;addr = tryResolveAddr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        link-&gt;cc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port,server.bind_source_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (link-&gt;cc &amp;&amp; !link-&gt;cc-&gt;err) anetCloexec(link-&gt;cc-&gt;c.fd);</span><br><span class="line">        <span class="keyword">if</span> (!link-&gt;cc) &#123;</span><br><span class="line">            sentinelEvent(LL_DEBUG,<span class="string">&quot;-cmd-link-reconnection&quot;</span>,ri,<span class="string">&quot;%@ #Failed to establish connection&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!link-&gt;cc-&gt;err &amp;&amp; server.tls_replication &amp;&amp;</span><br><span class="line">                (instanceLinkNegotiateTLS(link-&gt;cc) == C_ERR)) &#123;</span><br><span class="line">            sentinelEvent(LL_DEBUG,<span class="string">&quot;-cmd-link-reconnection&quot;</span>,ri,<span class="string">&quot;%@ #Failed to initialize TLS&quot;</span>);</span><br><span class="line">            instanceLinkCloseConnection(link,link-&gt;cc);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (link-&gt;cc-&gt;err) &#123;</span><br><span class="line">            sentinelEvent(LL_DEBUG,<span class="string">&quot;-cmd-link-reconnection&quot;</span>,ri,<span class="string">&quot;%@ #%s&quot;</span>,</span><br><span class="line">                link-&gt;cc-&gt;errstr);</span><br><span class="line">            instanceLinkCloseConnection(link,link-&gt;cc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            link-&gt;pending_commands = <span class="number">0</span>;</span><br><span class="line">            link-&gt;cc_conn_time = mstime();</span><br><span class="line">            link-&gt;cc-&gt;data = link;</span><br><span class="line">            redisAeAttach(server.el,link-&gt;cc);</span><br><span class="line">            redisAsyncSetConnectCallback(link-&gt;cc,</span><br><span class="line">                    sentinelLinkEstablishedCallback);</span><br><span class="line">            redisAsyncSetDisconnectCallback(link-&gt;cc,</span><br><span class="line">                    sentinelDisconnectCallback);</span><br><span class="line">            sentinelSendAuthIfNeeded(ri,link-&gt;cc);</span><br><span class="line">            sentinelSetClientName(ri,link-&gt;cc,<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Send a PING ASAP when reconnecting. */</span></span><br><span class="line">            sentinelSendPing(ri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Pub / Sub */</span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &amp;&amp; link-&gt;pc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        link-&gt;pc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip,ri-&gt;addr-&gt;port,server.bind_source_addr);</span><br><span class="line">        <span class="keyword">if</span> (link-&gt;pc &amp;&amp; !link-&gt;pc-&gt;err) anetCloexec(link-&gt;pc-&gt;c.fd);</span><br><span class="line">        <span class="keyword">if</span> (!link-&gt;pc) &#123;</span><br><span class="line">            sentinelEvent(LL_DEBUG,<span class="string">&quot;-pubsub-link-reconnection&quot;</span>,ri,<span class="string">&quot;%@ #Failed to establish connection&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!link-&gt;pc-&gt;err &amp;&amp; server.tls_replication &amp;&amp;</span><br><span class="line">                (instanceLinkNegotiateTLS(link-&gt;pc) == C_ERR)) &#123;</span><br><span class="line">            sentinelEvent(LL_DEBUG,<span class="string">&quot;-pubsub-link-reconnection&quot;</span>,ri,<span class="string">&quot;%@ #Failed to initialize TLS&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (link-&gt;pc-&gt;err) &#123;</span><br><span class="line">            sentinelEvent(LL_DEBUG,<span class="string">&quot;-pubsub-link-reconnection&quot;</span>,ri,<span class="string">&quot;%@ #%s&quot;</span>,</span><br><span class="line">                link-&gt;pc-&gt;errstr);</span><br><span class="line">            instanceLinkCloseConnection(link,link-&gt;pc);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line">            link-&gt;pc_conn_time = mstime();</span><br><span class="line">            link-&gt;pc-&gt;data = link;</span><br><span class="line">            redisAeAttach(server.el,link-&gt;pc);</span><br><span class="line">            redisAsyncSetConnectCallback(link-&gt;pc,</span><br><span class="line">                    sentinelLinkEstablishedCallback);</span><br><span class="line">            redisAsyncSetDisconnectCallback(link-&gt;pc,</span><br><span class="line">                    sentinelDisconnectCallback);</span><br><span class="line">            sentinelSendAuthIfNeeded(ri,link-&gt;pc);</span><br><span class="line">            sentinelSetClientName(ri,link-&gt;pc,<span class="string">&quot;pubsub&quot;</span>);</span><br><span class="line">            <span class="comment">/* Now we subscribe to the Sentinels &quot;Hello&quot; channel. */</span></span><br><span class="line">            retval = redisAsyncCommand(link-&gt;pc,</span><br><span class="line">                sentinelReceiveHelloMessages, ri, <span class="string">&quot;%s %s&quot;</span>,</span><br><span class="line">                sentinelInstanceMapCommand(ri,<span class="string">&quot;SUBSCRIBE&quot;</span>),</span><br><span class="line">                SENTINEL_HELLO_CHANNEL);</span><br><span class="line">            <span class="keyword">if</span> (retval != C_OK) &#123;</span><br><span class="line">                <span class="comment">/* If we can&#x27;t subscribe, the Pub/Sub connection is useless</span></span><br><span class="line"><span class="comment">                 * and we can simply disconnect it and try again. */</span></span><br><span class="line">                instanceLinkCloseConnection(link,link-&gt;pc);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Clear the disconnected status only if we have both the connections</span></span><br><span class="line"><span class="comment">     * (or just the commands connection if this is a sentinel instance). */</span></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;cc &amp;&amp; (ri-&gt;flags &amp; SRI_SENTINEL || link-&gt;pc))</span><br><span class="line">        link-&gt;disconnected = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="sentinelHandleRedisInstance-sentinelSendPeriodicCommands"><a href="#sentinelHandleRedisInstance-sentinelSendPeriodicCommands" class="headerlink" title="sentinelHandleRedisInstance -&gt; sentinelSendPeriodicCommands"></a>sentinelHandleRedisInstance -&gt; sentinelSendPeriodicCommands</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send periodic PING, INFO, and PUBLISH to the Hello channel to</span></span><br><span class="line"><span class="comment"> * the specified master or slave instance. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelSendPeriodicCommands</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="type">mstime_t</span> now = mstime();</span><br><span class="line">    <span class="type">mstime_t</span> info_period, ping_period;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if we have already a PING or INFO already pending, or</span></span><br><span class="line"><span class="comment">     * in the case the instance is not properly connected. */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For INFO, PING, PUBLISH that are not critical commands to send we</span></span><br><span class="line"><span class="comment">     * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don&#x27;t</span></span><br><span class="line"><span class="comment">     * want to use a lot of memory just because a link is not working</span></span><br><span class="line"><span class="comment">     * properly (note that anyway there is a redundant protection about this,</span></span><br><span class="line"><span class="comment">     * that is, the link will be disconnected and reconnected if a long</span></span><br><span class="line"><span class="comment">     * timeout condition is detected. */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;pending_commands &gt;=</span><br><span class="line">        SENTINEL_MAX_PENDING_COMMANDS * ri-&gt;link-&gt;refcount) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a slave of a master in O_DOWN condition we start sending</span></span><br><span class="line"><span class="comment">     * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD</span></span><br><span class="line"><span class="comment">     * period. In this state we want to closely monitor slaves in case they</span></span><br><span class="line"><span class="comment">     * are turned into masters by another Sentinel, or by the sysadmin.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Similarly we monitor the INFO output more often if the slave reports</span></span><br><span class="line"><span class="comment">     * to be disconnected from the master, so that we can have a fresh</span></span><br><span class="line"><span class="comment">     * disconnection time figure. */</span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp;</span><br><span class="line">        ((ri-&gt;master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS)) ||</span><br><span class="line">         (ri-&gt;master_link_down_time != <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        info_period = <span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        info_period = sentinel_info_period;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We ping instances every time the last received pong is older than</span></span><br><span class="line"><span class="comment">     * the configured &#x27;down-after-milliseconds&#x27; time, but every second</span></span><br><span class="line"><span class="comment">     * anyway if &#x27;down-after-milliseconds&#x27; is greater than 1 second. */</span></span><br><span class="line">    ping_period = ri-&gt;down_after_period;</span><br><span class="line">    <span class="keyword">if</span> (ping_period &gt; sentinel_ping_period) ping_period = sentinel_ping_period;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send INFO to masters and slaves, not sentinels. */</span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_SENTINEL) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (ri-&gt;info_refresh == <span class="number">0</span> ||</span><br><span class="line">        (now - ri-&gt;info_refresh) &gt; info_period))</span><br><span class="line">    &#123;</span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">            sentinelInfoReplyCallback, ri, <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">            sentinelInstanceMapCommand(ri,<span class="string">&quot;INFO&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send PING to all the three kinds of instances. */</span></span><br><span class="line">    <span class="keyword">if</span> ((now - ri-&gt;link-&gt;last_pong_time) &gt; ping_period &amp;&amp;</span><br><span class="line">               (now - ri-&gt;link-&gt;last_ping_time) &gt; ping_period/<span class="number">2</span>) &#123;</span><br><span class="line">        sentinelSendPing(ri);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PUBLISH hello messages to all the three kinds of instances. */</span></span><br><span class="line">    <span class="keyword">if</span> ((now - ri-&gt;last_pub_time) &gt; sentinel_publish_period) &#123;</span><br><span class="line">        sentinelSendHello(ri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sentinelTimer-sentinelRunPendingScripts"><a href="#sentinelTimer-sentinelRunPendingScripts" class="headerlink" title="sentinelTimer -&gt; sentinelRunPendingScripts"></a>sentinelTimer -&gt; sentinelRunPendingScripts</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelRunPendingScripts</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    <span class="type">mstime_t</span> now = mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find jobs that are not running and run them, from the top to the</span></span><br><span class="line"><span class="comment">     * tail of the queue, so we run older jobs first. */</span></span><br><span class="line">    listRewind(sentinel.scripts_queue,&amp;li);</span><br><span class="line">    <span class="keyword">while</span> (sentinel.running_scripts &lt; SENTINEL_SCRIPT_MAX_RUNNING &amp;&amp;</span><br><span class="line">           (ln = listNext(&amp;li)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sentinelScriptJob *sj = ln-&gt;value;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Skip if already running. */</span></span><br><span class="line">        <span class="keyword">if</span> (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Skip if it&#x27;s a retry, but not enough time has elapsed. */</span></span><br><span class="line">        <span class="keyword">if</span> (sj-&gt;start_time &amp;&amp; sj-&gt;start_time &gt; now) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        sj-&gt;flags |= SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">        sj-&gt;start_time = mstime();</span><br><span class="line">        sj-&gt;retry_num++;</span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Parent (fork error).</span></span><br><span class="line"><span class="comment">             * We report fork errors as signal 99, in order to unify the</span></span><br><span class="line"><span class="comment">             * reporting with other kind of errors. */</span></span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;-script-error&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">                          <span class="string">&quot;%s %d %d&quot;</span>, sj-&gt;argv[<span class="number">0</span>], <span class="number">99</span>, <span class="number">0</span>);</span><br><span class="line">            sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">            sj-&gt;pid = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Child */</span></span><br><span class="line">            connTypeCleanupAll();</span><br><span class="line">            execve(sj-&gt;argv[<span class="number">0</span>],sj-&gt;argv,environ);</span><br><span class="line">            <span class="comment">/* If we are here an error occurred. */</span></span><br><span class="line">            _exit(<span class="number">2</span>); <span class="comment">/* Don&#x27;t retry execution. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sentinel.running_scripts++;</span><br><span class="line">            sj-&gt;pid = pid;</span><br><span class="line">            sentinelEvent(LL_DEBUG,<span class="string">&quot;+script-child&quot;</span>,<span class="literal">NULL</span>,<span class="string">&quot;%ld&quot;</span>,(<span class="type">long</span>)pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sentinelTimer-sentinelCollectTerminatedScripts"><a href="#sentinelTimer-sentinelCollectTerminatedScripts" class="headerlink" title="sentinelTimer -&gt; sentinelCollectTerminatedScripts"></a>sentinelTimer -&gt; sentinelCollectTerminatedScripts</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check for scripts that terminated, and remove them from the queue if the</span></span><br><span class="line"><span class="comment"> * script terminated successfully. If instead the script was terminated by</span></span><br><span class="line"><span class="comment"> * a signal, or returned exit code &quot;1&quot;, it is scheduled to run again if</span></span><br><span class="line"><span class="comment"> * the max number of retries did not already elapsed. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelCollectTerminatedScripts</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> statloc;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;statloc, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> exitcode = WEXITSTATUS(statloc);</span><br><span class="line">        <span class="type">int</span> bysignal = <span class="number">0</span>;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        sentinelScriptJob *sj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</span><br><span class="line">        sentinelEvent(LL_DEBUG,<span class="string">&quot;-script-child&quot;</span>,<span class="literal">NULL</span>,<span class="string">&quot;%ld %d %d&quot;</span>,</span><br><span class="line">            (<span class="type">long</span>)pid, exitcode, bysignal);</span><br><span class="line"></span><br><span class="line">        ln = sentinelGetScriptListNodeByPid(pid);</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;waitpid() returned a pid (%ld) we can&#x27;t find in our scripts execution queue!&quot;</span>, (<span class="type">long</span>)pid);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sj = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the script was terminated by a signal or returns an</span></span><br><span class="line"><span class="comment">         * exit code of &quot;1&quot; (that means: please retry), we reschedule it</span></span><br><span class="line"><span class="comment">         * if the max number of retries is not already reached. */</span></span><br><span class="line">        <span class="keyword">if</span> ((bysignal || exitcode == <span class="number">1</span>) &amp;&amp;</span><br><span class="line">            sj-&gt;retry_num != SENTINEL_SCRIPT_MAX_RETRY)</span><br><span class="line">        &#123;</span><br><span class="line">            sj-&gt;flags &amp;= ~SENTINEL_SCRIPT_RUNNING;</span><br><span class="line">            sj-&gt;pid = <span class="number">0</span>;</span><br><span class="line">            sj-&gt;start_time = mstime() +</span><br><span class="line">                             sentinelScriptRetryDelay(sj-&gt;retry_num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Otherwise let&#x27;s remove the script, but log the event if the</span></span><br><span class="line"><span class="comment">             * execution did not terminated in the best of the ways. */</span></span><br><span class="line">            <span class="keyword">if</span> (bysignal || exitcode != <span class="number">0</span>) &#123;</span><br><span class="line">                sentinelEvent(LL_WARNING,<span class="string">&quot;-script-error&quot;</span>,<span class="literal">NULL</span>,</span><br><span class="line">                              <span class="string">&quot;%s %d %d&quot;</span>, sj-&gt;argv[<span class="number">0</span>], bysignal, exitcode);</span><br><span class="line">            &#125;</span><br><span class="line">            listDelNode(sentinel.scripts_queue,ln);</span><br><span class="line">            sentinelReleaseScriptJob(sj);</span><br><span class="line">        &#125;</span><br><span class="line">        sentinel.running_scripts--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sentinelTimer-sentinelKillTimedoutScripts"><a href="#sentinelTimer-sentinelKillTimedoutScripts" class="headerlink" title="sentinelTimer -&gt; sentinelKillTimedoutScripts"></a>sentinelTimer -&gt; sentinelKillTimedoutScripts</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Kill scripts in timeout, they&#x27;ll be collected by the</span></span><br><span class="line"><span class="comment"> * sentinelCollectTerminatedScripts() function. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelKillTimedoutScripts</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    <span class="type">mstime_t</span> now = mstime();</span><br><span class="line"></span><br><span class="line">    listRewind(sentinel.scripts_queue,&amp;li);</span><br><span class="line">    <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelScriptJob *sj = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sj-&gt;flags &amp; SENTINEL_SCRIPT_RUNNING &amp;&amp;</span><br><span class="line">            (now - sj-&gt;start_time) &gt; sentinel_script_max_runtime)</span><br><span class="line">        &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;-script-timeout&quot;</span>,<span class="literal">NULL</span>,<span class="string">&quot;%s %ld&quot;</span>,</span><br><span class="line">                sj-&gt;argv[<span class="number">0</span>], (<span class="type">long</span>)sj-&gt;pid);</span><br><span class="line">            kill(sj-&gt;pid,SIGKILL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sentinel-创建过程"><a href="#sentinel-创建过程" class="headerlink" title="sentinel 创建过程"></a>sentinel 创建过程</h3><h4 id="启动并初始化sentinel"><a href="#启动并初始化sentinel" class="headerlink" title="启动并初始化sentinel"></a>启动并初始化sentinel</h4><h4 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h4><h4 id="初始化-sentinel状态"><a href="#初始化-sentinel状态" class="headerlink" title="初始化 sentinel状态"></a>初始化 sentinel状态</h4><h4 id="初始化sentinel状态和masters属性"><a href="#初始化sentinel状态和masters属性" class="headerlink" title="初始化sentinel状态和masters属性"></a>初始化sentinel状态和masters属性</h4><h4 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h4><h3 id="sentinel、server之间如何通信？"><a href="#sentinel、server之间如何通信？" class="headerlink" title="sentinel、server之间如何通信？"></a>sentinel、server之间如何通信？</h3><h4 id="通信过程中的命令？"><a href="#通信过程中的命令？" class="headerlink" title="通信过程中的命令？"></a>通信过程中的命令？</h4><h4 id="sentinel如何应对脑裂？"><a href="#sentinel如何应对脑裂？" class="headerlink" title="sentinel如何应对脑裂？"></a>sentinel如何应对脑裂？</h4><p><code>sentinelSendPeriodicCommands</code>函数中定义了通信过程中使用的命令</p><h4 id="什么是TILT-mode？"><a href="#什么是TILT-mode？" class="headerlink" title="什么是TILT mode？"></a>什么是TILT mode？</h4><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Only masters */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line">        sentinelCheckObjectivelyDown(ri);</span><br><span class="line">        <span class="keyword">if</span> (sentinelStartFailoverIfNeeded(ri))</span><br><span class="line">            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</span><br><span class="line">        sentinelFailoverStateMachine(ri);</span><br><span class="line">        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="如何检测主观下线"><a href="#如何检测主观下线" class="headerlink" title="如何检测主观下线"></a>如何检测主观下线</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Is this instance down from our point of view? */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelCheckSubjectivelyDown</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="type">mstime_t</span> elapsed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;act_ping_time)</span><br><span class="line">        elapsed = mstime() - ri-&gt;link-&gt;act_ping_time;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected)</span><br><span class="line">        elapsed = mstime() - ri-&gt;link-&gt;last_avail_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are in need for a reconnection of one of the</span></span><br><span class="line"><span class="comment">     * links, because we are detecting low activity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Check if the command link seems connected, was connected not less</span></span><br><span class="line"><span class="comment">     *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have a</span></span><br><span class="line"><span class="comment">     *    pending ping for more than half the timeout. */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;cc &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;cc_conn_time) &gt;</span><br><span class="line">        sentinel_min_link_reconnect_period &amp;&amp;</span><br><span class="line">        ri-&gt;link-&gt;act_ping_time != <span class="number">0</span> &amp;&amp; <span class="comment">/* There is a pending ping... */</span></span><br><span class="line">        <span class="comment">/* The pending ping is delayed, and we did not receive</span></span><br><span class="line"><span class="comment">         * error replies as well. */</span></span><br><span class="line">        (mstime() - ri-&gt;link-&gt;act_ping_time) &gt; (ri-&gt;down_after_period/<span class="number">2</span>) &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;last_pong_time) &gt; (ri-&gt;down_after_period/<span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;cc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2) Check if the pubsub link seems connected, was connected not less</span></span><br><span class="line"><span class="comment">     *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have no</span></span><br><span class="line"><span class="comment">     *    activity in the Pub/Sub channel for more than</span></span><br><span class="line"><span class="comment">     *    SENTINEL_PUBLISH_PERIOD * 3.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;pc &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;pc_conn_time) &gt;</span><br><span class="line">         sentinel_min_link_reconnect_period &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;pc_last_activity) &gt; (sentinel_publish_period*<span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;pc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the SDOWN flag. We believe the instance is SDOWN if:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) It is not replying.</span></span><br><span class="line"><span class="comment">     * 2) We believe it is a master, it reports to be a slave for enough time</span></span><br><span class="line"><span class="comment">     *    to meet the down_after_period, plus enough time to get two times</span></span><br><span class="line"><span class="comment">     *    INFO report from the instance. */</span></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; ri-&gt;down_after_period ||</span><br><span class="line">        (ri-&gt;flags &amp; SRI_MASTER &amp;&amp;</span><br><span class="line">         ri-&gt;role_reported == SRI_SLAVE &amp;&amp;</span><br><span class="line">         mstime() - ri-&gt;role_reported_time &gt;</span><br><span class="line">          (ri-&gt;down_after_period+sentinel_info_period*<span class="number">2</span>)) ||</span><br><span class="line">          (ri-&gt;flags &amp; SRI_MASTER_REBOOT &amp;&amp; </span><br><span class="line">           mstime()-ri-&gt;master_reboot_since_time &gt; ri-&gt;master_reboot_down_after_period))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Is subjectively down */</span></span><br><span class="line">        <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_S_DOWN) == <span class="number">0</span>) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;+sdown&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            ri-&gt;s_down_since_time = mstime();</span><br><span class="line">            ri-&gt;flags |= SRI_S_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Is subjectively up */</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;-sdown&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            ri-&gt;flags &amp;= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何检测客观下线"><a href="#如何检测客观下线" class="headerlink" title="如何检测客观下线"></a>如何检测客观下线</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelCheckObjectivelyDown</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> quorum = <span class="number">0</span>, odown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">        <span class="comment">/* Is down for enough sentinels? */</span></span><br><span class="line">        quorum = <span class="number">1</span>; <span class="comment">/* the current sentinel. */</span></span><br><span class="line">        <span class="comment">/* Count all the other sentinels. */</span></span><br><span class="line">        di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER_DOWN) quorum++;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        <span class="keyword">if</span> (quorum &gt;= master-&gt;quorum) odown = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the flag accordingly to the outcome. */</span></span><br><span class="line">    <span class="keyword">if</span> (odown) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((master-&gt;flags &amp; SRI_O_DOWN) == <span class="number">0</span>) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;+odown&quot;</span>,master,<span class="string">&quot;%@ #quorum %d/%d&quot;</span>,</span><br><span class="line">                quorum, master-&gt;quorum);</span><br><span class="line">            master-&gt;flags |= SRI_O_DOWN;</span><br><span class="line">            master-&gt;o_down_since_time = mstime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;flags &amp; SRI_O_DOWN) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;-odown&quot;</span>,master,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            master-&gt;flags &amp;= ~SRI_O_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sentinelFailoverStateMachine"><a href="#sentinelFailoverStateMachine" class="headerlink" title="sentinelFailoverStateMachine"></a>sentinelFailoverStateMachine</h5><p>根据<code>rsi</code>当前的故障恢复状态，进行不同的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverStateMachine</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    serverAssert(ri-&gt;flags &amp; SRI_MASTER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(ri-&gt;failover_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_START:</span><br><span class="line">            sentinelFailoverWaitStart(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE:</span><br><span class="line">            sentinelFailoverSelectSlave(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:</span><br><span class="line">            sentinelFailoverSendSlaveOfNoOne(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:</span><br><span class="line">            sentinelFailoverWaitPromotion(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES:</span><br><span class="line">            sentinelFailoverReconfNextSlave(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sentinelAskMasterStateToOtherSentinels"><a href="#sentinelAskMasterStateToOtherSentinels" class="headerlink" title="sentinelAskMasterStateToOtherSentinels"></a>sentinelAskMasterStateToOtherSentinels</h5><p>向其他<code>sentinel</code>询问<code>master</code>的状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we think the master is down, we start sending</span></span><br><span class="line"><span class="comment"> * SENTINEL IS-MASTER-DOWN-BY-ADDR requests to other sentinels</span></span><br><span class="line"><span class="comment"> * in order to get the replies that allow to reach the quorum</span></span><br><span class="line"><span class="comment"> * needed to mark the master in ODOWN state and trigger a failover. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_ASK_FORCED (1&lt;&lt;0)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelAskMasterStateToOtherSentinels</span><span class="params">(sentinelRedisInstance *master, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">        <span class="type">mstime_t</span> elapsed = mstime() - ri-&gt;last_master_down_reply_time;</span><br><span class="line">        <span class="type">char</span> port[<span class="number">32</span>];</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the master state from other sentinel is too old, we clear it. */</span></span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt; sentinel_ask_period*<span class="number">5</span>) &#123;</span><br><span class="line">            ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;</span><br><span class="line">            sdsfree(ri-&gt;leader);</span><br><span class="line">            ri-&gt;leader = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only ask if master is down to other sentinels if:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1) We believe it is down, or there is a failover in progress.</span></span><br><span class="line"><span class="comment">         * 2) Sentinel is connected.</span></span><br><span class="line"><span class="comment">         * 3) We did not receive the info within SENTINEL_ASK_PERIOD ms. */</span></span><br><span class="line">        <span class="keyword">if</span> ((master-&gt;flags &amp; SRI_S_DOWN) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; SENTINEL_ASK_FORCED) &amp;&amp;</span><br><span class="line">            mstime() - ri-&gt;last_master_down_reply_time &lt; sentinel_ask_period)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Ask */</span></span><br><span class="line">        ll2string(port,<span class="keyword">sizeof</span>(port),master-&gt;addr-&gt;port);</span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">                    sentinelReceiveIsMasterDownReply, ri,</span><br><span class="line">                    <span class="string">&quot;%s is-master-down-by-addr %s %s %llu %s&quot;</span>,</span><br><span class="line">                    sentinelInstanceMapCommand(ri,<span class="string">&quot;SENTINEL&quot;</span>),</span><br><span class="line">                    announceSentinelAddr(master-&gt;addr), port,</span><br><span class="line">                    sentinel.current_epoch,</span><br><span class="line">                    (master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE) ?</span><br><span class="line">                    sentinel.myid : <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="sentinelHandleDictOfRedisInstances-sentinelFailoverSwitchToPromotedSlave"><a href="#sentinelHandleDictOfRedisInstances-sentinelFailoverSwitchToPromotedSlave" class="headerlink" title="sentinelHandleDictOfRedisInstances -&gt; sentinelFailoverSwitchToPromotedSlave"></a>sentinelHandleDictOfRedisInstances -&gt; sentinelFailoverSwitchToPromotedSlave</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called when the slave is in</span></span><br><span class="line"><span class="comment"> * SENTINEL_FAILOVER_STATE_UPDATE_CONFIG state. In this state we need</span></span><br><span class="line"><span class="comment"> * to remove it from the master table and add the promoted slave instead. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverSwitchToPromotedSlave</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ref = master-&gt;promoted_slave ?</span><br><span class="line">                                 master-&gt;promoted_slave : master;</span><br><span class="line"></span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">&quot;+switch-master&quot;</span>,master,<span class="string">&quot;%s %s %d %s %d&quot;</span>,</span><br><span class="line">        master-&gt;name, announceSentinelAddr(master-&gt;addr), master-&gt;addr-&gt;port,</span><br><span class="line">        announceSentinelAddr(ref-&gt;addr), ref-&gt;addr-&gt;port);</span><br><span class="line"></span><br><span class="line">    sentinelResetMasterAndChangeAddress(master,ref-&gt;addr-&gt;hostname,ref-&gt;addr-&gt;port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called when the slave is in</span></span><br><span class="line"><span class="comment"> * SENTINEL_FAILOVER_STATE_UPDATE_CONFIG state. In this state we need</span></span><br><span class="line"><span class="comment"> * to remove it from the master table and add the promoted slave instead. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverSwitchToPromotedSlave</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ref = master-&gt;promoted_slave ?</span><br><span class="line">                                 master-&gt;promoted_slave : master;</span><br><span class="line"></span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">&quot;+switch-master&quot;</span>,master,<span class="string">&quot;%s %s %d %s %d&quot;</span>,</span><br><span class="line">        master-&gt;name, announceSentinelAddr(master-&gt;addr), master-&gt;addr-&gt;port,</span><br><span class="line">        announceSentinelAddr(ref-&gt;addr), ref-&gt;addr-&gt;port);</span><br><span class="line"></span><br><span class="line">    sentinelResetMasterAndChangeAddress(master,ref-&gt;addr-&gt;hostname,ref-&gt;addr-&gt;port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverStateMachine</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    serverAssert(ri-&gt;flags &amp; SRI_MASTER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(ri-&gt;failover_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_START:</span><br><span class="line">            sentinelFailoverWaitStart(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE:</span><br><span class="line">            sentinelFailoverSelectSlave(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:</span><br><span class="line">            sentinelFailoverSendSlaveOfNoOne(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:</span><br><span class="line">            sentinelFailoverWaitPromotion(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES:</span><br><span class="line">            sentinelFailoverReconfNextSlave(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sentinelFailoverSwitchToPromotedSlave</code>函数首先发起<code>+switch-master</code>事件，并通知所有<code>sentinel</code>。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://juejin.cn/post/7072740438452469774">1. redis设计与实现</a><br><a href="https://cloud.tencent.com/developer/article/1021467">2. Raft协议实战之Redis Sentinel的选举Leader源码解析</a><br><a href="https://time.geekbang.org/column/article/275337">3. 极客时间-关于哨兵模式的讨论</a><br><a href="https://z.itpub.net/article/detail/61F53FE9A1487984804DB48AAB9EF262">4. Redis主从、哨兵、 Cluster集群一锅端！</a><br><a href="https://bbs.huaweicloud.com/blogs/detail/234846">5. Redis Sentinel 源码分析（1）Sentinel的初始化</a><br><a href="https://cloud.tencent.com/developer/article/1021467">6. Raft协议实战之Redis Sentinel的选举Leader源码解析</a><br><a href="http://redisdoc.com/topic/sentinel.html">7. sentinel命令参考</a><br><a href="https://bbs.huaweicloud.com/blogs/242476">8. Redis Sentinel 源码：Redis的高可用模型分析</a><br><a href="https://www.modb.pro/db/221414">9. Redis专题：深入解读哨兵模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;前文&lt;a href=&quot;https://mqrayblog.cn/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%</summary>
      
    
    
    
    <category term="databases" scheme="https://mqrayblog.cn/categories/databases/"/>
    
    
    <category term="redis" scheme="https://mqrayblog.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis之主从复制</title>
    <link href="https://mqrayblog.cn/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://mqrayblog.cn/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2023-08-07T15:13:18.000Z</published>
    <updated>2023-10-24T04:46:09.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><p>主从结构是常用的计算机系统架构，通常被用于分布式系统中，其中一个节点<code>master</code>拥有最新的数据，其他节点<code>slave</code>复制并同步主节点的数据。  </p><p>主从结构中，主节点负责写入数据，并将这些数据同步到从节点中；从节点只能读取数据。主从节点键通过网络连接，完成数据同步。  </p><p>主从模式也常被用于数据库系统中，提供高可用能力。当主节点发生故障或者失效时，从节点可以被选举为新的主节点，保证系统的可用性。 </p><img src="/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/redis_master_slave_arch.png">  <h3 id="主从模式的优点"><a href="#主从模式的优点" class="headerlink" title="主从模式的优点"></a>主从模式的优点</h3><ol><li>负载均衡：读写分离：提高服务器的性能。</li><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的数据冗余手段。</li><li>高可用基石：主从模式是哨兵模式和集群模式的基础。</li></ol><h3 id="主从模式的缺点？"><a href="#主从模式的缺点？" class="headerlink" title="主从模式的缺点？"></a>主从模式的缺点？</h3><ol><li>主从模式不具备自动容错和恢复功能，主节点故障，集群无法工作，可用性较低。从节点升为主节点需要人工手动干预。</li></ol><h2 id="为什么redis要使用主从模式？"><a href="#为什么redis要使用主从模式？" class="headerlink" title="为什么redis要使用主从模式？"></a>为什么redis要使用主从模式？</h2><p>在了解<code>redis</code>主从结构的原理前，先来了解一下分布式系统的理论基石 <code>CAP</code>原理：</p><ol><li>C, Consistent, 即一致性；</li><li>A, Availability, 即可用性；</li><li>P, Partition， 即分区容忍性。</li></ol><p>redis复制过程主从节点之间网络故障时，不能满足强一致性，故而只能满足AP。</p><h3 id="如何使用主从复制？"><a href="#如何使用主从复制？" class="headerlink" title="如何使用主从复制？"></a>如何使用主从复制？</h3><p><code>redis 2.8</code>对主从复制功能进行了优化，早先的版本主从复制功能的实现包含两个步骤：</p><ol><li>同步： 用于将从服务器的服务器状态更新至主服务器当前的数据库状态。</li><li>命令传播：用于将 主从同步过程中发生的主服务器的修改命令同步至从服务器，以防止主从数据库状态不一致的情况。</li></ol><p>slave of ip port<br>该命令的作用？</p><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><h4 id="主从服务器建立链接"><a href="#主从服务器建立链接" class="headerlink" title="主从服务器建立链接"></a>主从服务器建立链接</h4><p>从服务器作为客户端向主服务器发送<code>slaveof  master_ip master_port</code></p><h4 id="旧版本复制功能的实现？"><a href="#旧版本复制功能的实现？" class="headerlink" title="旧版本复制功能的实现？"></a>旧版本复制功能的实现？</h4><p>旧版本主从复制包含<code>同步</code>和<code>命令传播</code>两个部分，如下是整体流程：<br><img src="/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/master_slave_copy.png"></p><h4 id="旧版复制的缺陷？"><a href="#旧版复制的缺陷？" class="headerlink" title="旧版复制的缺陷？"></a>旧版复制的缺陷？</h4><p>主从复制过程有如下两个场景：</p><ol><li>初次复制： slave未同步过任何master，或者当前待复制的主服务器和上一次复制的主服务器不同</li><li>断线后复制：处于命令传播阶段主从服务器因为网络故障而中断，而后网络恢复后继续同步数据库状态。<br>在旧版复制功能中，主从服务器发生网络故障后，主从服务器之间数据库状态不一致，slave会向主服务器发送<code>sync</code>命令，主服务器再次生成包含当前数据库状态的<code>rdb</code>文件，而后发送给从服务器，从服务器载入<code>rbd</code>文件后继续执行主服务器发来的写命令。<br>上述过程的缺陷是，已经同步过的主从节点断联之后，再次连接时需要主服务器生成包含其当前数据库状态的<code>rdb</code>文件，更为关键的是，此网络故障期间，主节点可能只执行了少数写命令，而需要付出全量更新的开销。</li></ol><h4 id="sync命令的开销"><a href="#sync命令的开销" class="headerlink" title="sync命令的开销"></a>sync命令的开销</h4><p><code>sync</code>命令，主从服务器需要执行以下动作：</p><ol><li>主服务器需要执行<code>bgsave</code>命令生成<code>rdb</code>文件，此操作会耗费主服务器的大量cpu、内存和磁盘io资源。</li><li>主服务器将生成的<code>RDB</code>文件发送给从服务器，此操作耗费主从服务器的大量网络资源，并对主服务器的命令响应事件产生影响。</li><li>从服务器载入收到的<code>rdb</code>文件前，无法处理读请求。</li></ol><h4 id="全量复制过程？"><a href="#全量复制过程？" class="headerlink" title="全量复制过程？"></a>全量复制过程？</h4><p>redis 2.8之前?</p><p>sync</p><h4 id="旧版本复制的缺陷？"><a href="#旧版本复制的缺陷？" class="headerlink" title="旧版本复制的缺陷？"></a>旧版本复制的缺陷？</h4><p>为了解决旧版本复制功能在处理断线重复复制时的低效问题，<code>redis 2.8</code>之后使用<code>psync</code>命令代替<code>sync</code>来执行复制时的同步操作。<br><code>psync</code>命令提供两种模式：</p><ol><li>完整重同步： 主服务器创建并发送rdb文件，向从服务器发送保存在缓冲区中的写命令进行同步。</li><li>部分重同步：用于处理断线后的复制情况。断线重连后，如果情况允许，主服务器将主从断联期间执行的写命令发送给从服务器，从服务器接收并执行写命令，完成数据库状态同步。</li></ol><p>那么，<code>psync</code>的改进即是感知主从是断联场景，这是如何实现的呢？</p><h3 id="部分重同步的实现？"><a href="#部分重同步的实现？" class="headerlink" title="部分重同步的实现？"></a>部分重同步的实现？</h3><p>部分重同步功能的实现依赖三个结构：</p><ol><li>主从服务器的复制偏移量 和从服务器的 复制偏移量。</li><li>主服务器的复制积压缓冲区。</li><li>服务器的运行id。<br>相应的定义在<code>server.h</code>，注意到，在<code>server</code>中，与主从复制相关的结构定义包含两部分，分别是主服务器配置和从服务器配置。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replication (master) */</span></span><br><span class="line">    <span class="type">char</span> replid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];  <span class="comment">/* My current replication ID. */</span></span><br><span class="line">    <span class="type">char</span> replid2[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* replid inherited from master*/</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> master_repl_offset;   <span class="comment">/* My current replication offset */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> second_replid_offset; <span class="comment">/* Accept offsets up to this for replid2. */</span></span><br><span class="line">    redisAtomic <span class="type">long</span> <span class="type">long</span> fsynced_reploff_pending;<span class="comment">/* Largest replication offset to</span></span><br><span class="line"><span class="comment">                                     * potentially have been fsynced, applied to</span></span><br><span class="line"><span class="comment">                                       fsynced_reploff only when AOF state is AOF_ON</span></span><br><span class="line"><span class="comment">                                       (not during the initial rewrite) */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fsynced_reploff;      <span class="comment">/* Largest replication offset that has been confirmed to be fsynced */</span></span><br><span class="line">    <span class="type">int</span> slaveseldb;                 <span class="comment">/* Last SELECTed DB in replication output */</span></span><br><span class="line">    <span class="type">int</span> repl_ping_slave_period;     <span class="comment">/* Master pings the slave every N seconds */</span></span><br><span class="line">    replBacklog *repl_backlog;      <span class="comment">/* Replication backlog for partial syncs */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_backlog_size;    <span class="comment">/* Backlog circular buffer size */</span></span><br><span class="line">    <span class="type">time_t</span> repl_backlog_time_limit; <span class="comment">/* Time without slaves after the backlog</span></span><br><span class="line"><span class="comment">                                       gets released. */</span></span><br><span class="line">    <span class="type">time_t</span> repl_no_slaves_since;    <span class="comment">/* We have no slaves since that time.</span></span><br><span class="line"><span class="comment">                                       Only valid if server.slaves len is 0. */</span></span><br><span class="line">    <span class="type">int</span> repl_min_slaves_to_write;   <span class="comment">/* Min number of slaves to write. */</span></span><br><span class="line">    <span class="type">int</span> repl_min_slaves_max_lag;    <span class="comment">/* Max lag of &lt;count&gt; slaves to write. */</span></span><br><span class="line">    <span class="type">int</span> repl_good_slaves_count;     <span class="comment">/* Number of slaves with lag &lt;= max_lag. */</span></span><br><span class="line">    <span class="type">int</span> repl_diskless_sync;         <span class="comment">/* Master send RDB to slaves sockets directly. */</span></span><br><span class="line">    <span class="type">int</span> repl_diskless_load;         <span class="comment">/* Slave parse RDB directly from the socket.</span></span><br><span class="line"><span class="comment">                                     * see REPL_DISKLESS_LOAD_* enum */</span></span><br><span class="line">    <span class="type">int</span> repl_diskless_sync_delay;   <span class="comment">/* Delay to start a diskless repl BGSAVE. */</span></span><br><span class="line">    <span class="type">int</span> repl_diskless_sync_max_replicas;<span class="comment">/* Max replicas for diskless repl BGSAVE</span></span><br><span class="line"><span class="comment">                                         * delay (start sooner if they all connect). */</span></span><br><span class="line">    <span class="type">size_t</span> repl_buffer_mem;         <span class="comment">/* The memory of replication buffer. */</span></span><br><span class="line">    <span class="built_in">list</span> *repl_buffer_blocks;       <span class="comment">/* Replication buffers blocks list</span></span><br><span class="line"><span class="comment">                                     * (serving replica clients and repl backlog) */</span></span><br></pre></td></tr></table></figure><p>从服务器配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replication (slave) */</span></span><br><span class="line">    <span class="type">char</span> *masteruser;               <span class="comment">/* AUTH with this user and masterauth with master */</span></span><br><span class="line">    sds masterauth;                 <span class="comment">/* AUTH with this password with master */</span></span><br><span class="line">    <span class="type">char</span> *masterhost;               <span class="comment">/* Hostname of master */</span></span><br><span class="line">    <span class="type">int</span> masterport;                 <span class="comment">/* Port of master */</span></span><br><span class="line">    <span class="type">int</span> repl_timeout;               <span class="comment">/* Timeout after N seconds of master idle */</span></span><br><span class="line">    client *master;     <span class="comment">/* Client that is master for this slave */</span></span><br><span class="line">    client *cached_master; <span class="comment">/* Cached master to be reused for PSYNC. */</span></span><br><span class="line">    <span class="type">int</span> repl_syncio_timeout; <span class="comment">/* Timeout for synchronous I/O calls */</span></span><br><span class="line">    <span class="type">int</span> repl_state;          <span class="comment">/* Replication status if the instance is a slave */</span></span><br><span class="line">    <span class="type">off_t</span> repl_transfer_size; <span class="comment">/* Size of RDB to read from master during sync. */</span></span><br><span class="line">    <span class="type">off_t</span> repl_transfer_read; <span class="comment">/* Amount of RDB read from master during sync. */</span></span><br><span class="line">    <span class="type">off_t</span> repl_transfer_last_fsync_off; <span class="comment">/* Offset when we fsync-ed last time. */</span></span><br><span class="line">    connection *repl_transfer_s;     <span class="comment">/* Slave -&gt; Master SYNC connection */</span></span><br><span class="line">    <span class="type">int</span> repl_transfer_fd;    <span class="comment">/* Slave -&gt; Master SYNC temp file descriptor */</span></span><br><span class="line">    <span class="type">char</span> *repl_transfer_tmpfile; <span class="comment">/* Slave-&gt; master SYNC temp file name */</span></span><br><span class="line">    <span class="type">time_t</span> repl_transfer_lastio; <span class="comment">/* Unix time of the latest read, for timeout */</span></span><br><span class="line">    <span class="type">int</span> repl_serve_stale_data; <span class="comment">/* Serve stale data when link is down? */</span></span><br><span class="line">    <span class="type">int</span> repl_slave_ro;          <span class="comment">/* Slave is read only? */</span></span><br><span class="line">    <span class="type">int</span> repl_slave_ignore_maxmemory;    <span class="comment">/* If true slaves do not evict. */</span></span><br><span class="line">    <span class="type">time_t</span> repl_down_since; <span class="comment">/* Unix time at which link with master went down */</span></span><br><span class="line">    <span class="type">int</span> repl_disable_tcp_nodelay;   <span class="comment">/* Disable TCP_NODELAY after SYNC? */</span></span><br><span class="line">    <span class="type">int</span> slave_priority;             <span class="comment">/* Reported in INFO and used by Sentinel. */</span></span><br><span class="line">    <span class="type">int</span> replica_announced;          <span class="comment">/* If true, replica is announced by Sentinel */</span></span><br><span class="line">    <span class="type">int</span> slave_announce_port;        <span class="comment">/* Give the master this listening port. */</span></span><br><span class="line">    <span class="type">char</span> *slave_announce_ip;        <span class="comment">/* Give the master this ip address. */</span></span><br><span class="line">    <span class="type">int</span> propagation_error_behavior; <span class="comment">/* Configures the behavior of the replica</span></span><br><span class="line"><span class="comment">                                     * when it receives an error on the replication stream */</span></span><br><span class="line">    <span class="type">int</span> repl_ignore_disk_write_error;   <span class="comment">/* Configures whether replicas panic when unable to</span></span><br><span class="line"><span class="comment">                                         * persist writes to AOF. */</span></span><br><span class="line">    <span class="comment">/* The following two fields is where we store master PSYNC replid/offset</span></span><br><span class="line"><span class="comment">     * while the PSYNC is in progress. At the end we&#x27;ll copy the fields into</span></span><br><span class="line"><span class="comment">     * the server-&gt;master client structure. */</span></span><br><span class="line">    <span class="type">char</span> master_replid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];  <span class="comment">/* Master PSYNC runid. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> master_initial_offset;           <span class="comment">/* Master PSYNC offset. */</span></span><br><span class="line">    <span class="type">int</span> repl_slave_lazy_flush;          <span class="comment">/* Lazy FLUSHALL before loading DB? */</span></span><br><span class="line">    <span class="comment">/* Synchronous replication. */</span></span><br><span class="line">    <span class="built_in">list</span> *clients_waiting_acks;         <span class="comment">/* Clients waiting in WAIT or WAITAOF. */</span></span><br><span class="line">    <span class="type">int</span> get_ack_from_slaves;            <span class="comment">/* If true we send REPLCONF GETACK. */</span></span><br></pre></td></tr></table></figure><h4 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h4><p>执行复制的双方分别维护一个复制偏移量。[主服务器应当维护多个？]</p><ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量+N </li><li>从服务器每次收到主服务器的N个字节的数据时，将自身的复制偏移量+N<br>通过对比主从服务器的复制偏移量，可以得出主从节点是否处于一致状态。<br>如果偏移量一致，则主从服务器处于抑制状态；否则处于非一致状态。<br>注意，主服务器配置中复制偏移量为<code>master_repl_offset</code>，而从服务器中，</li></ul><p>关于下笔时的问题，主服务器中是否应当维护多个复制偏移量，答案是否定的，在源码定义中未找到对应的定义。可以理解为，一主多从时，服务器会将当前数据库状态传递给多个从服务器，并同步复制偏移量。<br>而<code>redis 4.0</code>之后，所有的从服务器都会从主服务器接收完全相同的复制量，但是由每队主从之间的网络不一定相同，所以需要从服务器自身维护其当前的复制偏移量。那么问题来了，如何保障下一次同步呢？<br>这里从节点之间的不一致会影响集群同步状态，主节点向从节点发送主从差别状态时就会变得繁琐。</p><h4 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个<code>固定长度的FIFO</code>队列，默认大小为<code>1MB</code>。<br>当主服务器进行命令传播时，不仅仅会将写命令发送给从服务器，还会讲命令写入到复制积压缓冲区中。复制积压缓冲区会记录每个字节记记录相对应的复制偏移量。</p><p>如果主从断联一段时间后，从服务器重新连上主服务器，则从服务器会通过<code>PSYNC</code>命令将自己的复制偏移量发送给主服务器，主服务器根据从服务器的复制偏移量决定接下来该如何同步。</p><ol><li>如果offset偏移量之后的数据依然存在于复制积压缓冲区中，那么主服务器将对从服务器执行部分重同步操作，即主服务器向从节点发送断联期间执行的命令。 <code>CONTINUE</code></li><li>如果offset之后逇数据不存在复制积压缓冲区中，则主服务器对当前的从服务器执行完整的重同步操作。</li></ol><h5 id="复制积压缓冲区大小？"><a href="#复制积压缓冲区大小？" class="headerlink" title="复制积压缓冲区大小？"></a>复制积压缓冲区大小？</h5><p>默认为<code>1MB</code>，如果主服务器需要执行大量写命令或者主从断联时间较长，则可能需要考虑设置合理的复制积压缓冲区大小。<br>有这样的计算公式： <code>second * write_size_per_second</code><br>即对每秒写入数据量和主从断联恢复时长有一定的预估。<br>为了安全期间，还需要将复制积压缓冲区的大小进行<code>double</code>处理。</p><h5 id="复制积压缓冲区实现"><a href="#复制积压缓冲区实现" class="headerlink" title="复制积压缓冲区实现"></a>复制积压缓冲区实现</h5><p>复制积压缓冲区由一个环形队列实现。的相关定义包含两部分:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replBacklog *repl_backlog;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> repl_backlog_size;</span><br></pre></td></tr></table></figure><ol><li><code>repl_backlog_size</code>： 指定复制积压缓冲区的大小；</li><li><code>replBacklog *repl_backlog</code>: 所有从服务器共享的复制积压缓冲区。</li></ol><h4 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h4><p>实现部分重同步的过程需要用到服务器运行ID</p><ul><li>每个服务器(主从)都有自己的运行ID</li><li>运行ID在服务器启动时生成，由40位随机十六进制的字符串组成。</li></ul><p>主从服务器初次进行同步时，主服务器将自身的运行ID传递给从服务器，从服务器将其保存至<br><code>master_replid</code>中，同时保存初次同步的<code>offset</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主服务器配置</span><br><span class="line"><span class="type">char</span> replid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];  <span class="comment">/* My current replication ID. */</span></span><br><span class="line"><span class="type">char</span> replid2[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* replid inherited from master*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">从服务器配置</span><br><span class="line"><span class="type">char</span> master_replid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];  <span class="comment">/* Master PSYNC runid. */</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> master_initial_offset;           <span class="comment">/* Master PSYNC offset. */</span></span><br></pre></td></tr></table></figure><p>主从重连时，从服务器向当前连接的主服务器发送之前保存的运行ID，如果匹配且offset任保存在主服务器的复制积压缓冲区中，则执行部分重同步。若不再则执行完整重同步；否则执行完整重同步操作。</p><h3 id="PSYNC实现"><a href="#PSYNC实现" class="headerlink" title="PSYNC实现"></a>PSYNC实现</h3><h4 id="PSYNC的调用方式"><a href="#PSYNC的调用方式" class="headerlink" title="PSYNC的调用方式"></a>PSYNC的调用方式</h4><ol><li>从服务器未复制过任何主服务器，或者执行过<code>slave no one</code>，则从服务器再执行第一次复制时将向主服务器发送<code>PSYNC ? -1</code>，主动向主服务器请求完整重同步。</li><li>已复制过，则开始新的复制时向主服务器发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>， 主服务器判断进行何种操作。</li></ol><p>主服务器有三种响应：</p><ol><li>返回<code>+FULLSYNC &lt;runid&gt; &lt;offset&gt;</code> 回复，则表示主从服务器之间将进行完整重同步过程；</li><li>返回<code>+CONTINUE</code>，则主从服务器之间将执行部分重同步操作，从服务器将等待主服务器发送复制积压缓冲区中堆积的写命令，接收后执行即可。</li><li>返回<code>-ERR</code>，则表示主服务器版本低于<code>redis 2.8</code>无法识别<code>PSYNC</code>命令。从服务器将向主服务器发送<code>SYNC</code>命令，执行完整同步过程。</li></ol><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><img src="/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/master_slave_1_copy.webp"><img src="/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/master-_slave_second_copy.webp"><h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h4><p>心跳检测是指，在命令传播阶段，从服务器会以默认每秒一次的频率向服务器发送命令：<br><code>replconf ack &lt;replication_offset&gt;</code>， <code>replication_offset</code>是从服务器当前的复制偏移量。<br>上述命令包含三个作用：</p><ol><li>检测主从服务器之间的网络连接状态。</li><li>辅助实现<code>min-slaves</code>选项。</li><li>检测命令丢失。</li></ol><h5 id="检测主从网络连接状态"><a href="#检测主从网络连接状态" class="headerlink" title="检测主从网络连接状态"></a>检测主从网络连接状态</h5><p>如果主服务器超过一秒钟未收到从服务器发来的<code>replconf ack</code>命令，那么服务器则知道两者的网络连接出问题了。<br>在主服务器上执行<code>info replication</code>命令，tag栏能反映出当前从服务器最后一次向主服务器发送<code>replconf ack</code>距此时过了多久：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">182.168.106.129:6379&gt; info replication</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:637b9e49e28c5c17d2a4d43abd7cea4434cc91ae</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>注意上述返回中从节点数为0是因为本人所使用的redis的模式为集群模式。在后续内容中将补充redis的架构模式。</p><h5 id="辅助实现min-slaves选项"><a href="#辅助实现min-slaves选项" class="headerlink" title="辅助实现min-slaves选项"></a>辅助实现<code>min-slaves</code>选项</h5><p>redis中如下两个配置可以防止主服务器在不安全的情况下执行写命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write <span class="number">3</span></span><br><span class="line">min-slaves-max-lag <span class="number">10</span></span><br></pre></td></tr></table></figure><p>分别对应<code>server</code>中的配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> repl_min_slaves_to_write;   <span class="comment">/* Min number of slaves to write. */</span></span><br><span class="line">   <span class="type">int</span> repl_min_slaves_max_lag;</span><br></pre></td></tr></table></figure><p>其含义为：在从服务器少于3个或者三个从服务器的延迟大于等于10秒时，主服务器将拒绝少执行命令。</p><h5 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h5><p>如果因为网络故障，主服务器传播给从服务器的写命令半路丢失，那么当从服务器向主服务器发送<code>replconf ack</code>时，主服务器将识别到主从之间的复制偏移量存在差异，而后主服务器就根据从服务器提交的偏移量，在复制积压缓冲区中找到从服务器缺少的数据，讲这些数据重新发给从服务器。</p><p>乍看起来，这个过程和部分重同步非常相似，但是两者还是有些差异：<br>补发缺失数据操作在主从服务器之间没有断线时执行；而部分重同步发生在断线重连之后。</p><p>注意到 <code>redis 2.8</code>之前没有<code>replconf ack</code>和 <code>复制积压缓冲区</code>，即使命令在传播过程中丢失，主从都不会意识到,主服务器也不会向从服务器补发丢失的数据。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="无盘复制是什么？"><a href="#无盘复制是什么？" class="headerlink" title="无盘复制是什么？"></a>无盘复制是什么？</h4><p><code>redis</code>默认是磁盘复制，但是如果使用低速磁盘，复制操作会给主服务器带来较大压力。所以<code>redis 2.8.18</code>后开始支持<code>无盘复制</code>。在这种模式下，子进程直接将<code>rdb</code>文件通过网络发送给从服务器，不适用磁盘作为中间存储。</p><h4 id="redis主从复制过程为什么选择rdb，而非aof"><a href="#redis主从复制过程为什么选择rdb，而非aof" class="headerlink" title="redis主从复制过程为什么选择rdb，而非aof"></a>redis主从复制过程为什么选择rdb，而非aof</h4><ul><li><code>rdb</code>文件内容是经过压缩的二进制数据，同时<code>redis</code>针对不同的数据类型做了针对性优化，文件较小。而<code>aof</code>文件记录的是每一次写操作的命令，写操作越多文件越大，而且包含对重复key的冗余操作。在主从全量同步时，传输<code>rdb</code>文件可以降低对主从服务器的网络带宽开销。从库在加载<code>RDB</code>文件时，文件小，读取快。同时从库按照rdb协议解析还原数据即可。而<code>aof</code>需要依次重放每个写命令，恢复速度比<code>rdb</code>慢很多。</li><li>假设使用<code>AOF</code>做全量复制，则服务器必须打开<code>aof</code>功能，必须选择文件刷盘的策略，选择不当会严重影响<code>redis</code>性能。而<code>RDB</code>只有在需要定时备份和主从全量复制时才会触发，生成快照。在很多丢失数据不敏感的业务场景，其实是不需要开启<code>AOF</code>的。</li></ul><h4 id="如何理解主-从-从模式"><a href="#如何理解主-从-从模式" class="headerlink" title="如何理解主-从-从模式"></a>如何理解主-从-从模式</h4><p>如果是主从模式，一主多从的情况下，如果多个从服务器向主服务器请求全量复制，在主库中需要完成多次<code>fork</code>子进程生成<code>RDB</code>文件，进行全量复制，fork操作会阻塞主线程处理正常请求。另外传输<code>RDB</code>文件也会占用主库网络带宽。<br>可以通过主-从-从模式建立多级主从模式，以缓解顶级主服务器的压力。<br><img src="/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/master_slave_slave.jpg">  </p><h4 id="如何理解redis的高可用"><a href="#如何理解redis的高可用" class="headerlink" title="如何理解redis的高可用"></a>如何理解redis的高可用</h4><ol><li>数据不能丢失或尽量减少丢失。</li><li>redis服务不中断。<br>相对应的，第一点由<code>持久化机制aof和rdb</code>保障；第二点则要求<code>redis</code>不能单点部署。</li></ol><h4 id="主从不一致的原因？"><a href="#主从不一致的原因？" class="headerlink" title="主从不一致的原因？"></a>主从不一致的原因？</h4><ol><li>主从网络时延大&#x2F;断联</li><li>从库收到主库发来的命令，但从库正在执行阻塞式命令，如<code>hgetall</code>。</li></ol><h3 id="redis-主从模式如何选主？"><a href="#redis-主从模式如何选主？" class="headerlink" title="redis 主从模式如何选主？"></a>redis 主从模式如何选主？</h3><p>在主从模式中，主节点故障后，需要人工干预将从节点设置为主节点，同时还需要通知应用方更新主节点地址。故而有了另一种架构模式：<code>哨兵模式</code></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html">1. redis复制</a><br><a href="https://www.cnblogs.com/better-farther-world2099/articles/16159844.html">2. 详解Redis 主从复制原理</a><br><a href="https://www.51cto.com/article/640170.html">3. </a><br><a href="https://blog.csdn.net/John_Like_Girl/article/details/107161725">4. Redis主从模式的优缺点</a><br><a href="https://www.ruanyifeng.com/blog/2018/07/cap.html">5. CAP 定理的含义</a><br><a href="https://time.geekbang.org/column/article/272852">6. 极客时间：主从库如何实现数据一致</a><br><a href="https://z.itpub.net/article/detail/61F53FE9A1487984804DB48AAB9EF262">7. redis主从</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主从模式&quot;&gt;&lt;a href=&quot;#主从模式&quot; class=&quot;headerlink&quot; title=&quot;主从模式&quot;&gt;&lt;/a&gt;主从模式&lt;/h2&gt;&lt;p&gt;主从结构是常用的计算机系统架构，通常被用于分布式系统中，其中一个节点&lt;code&gt;master&lt;/code&gt;拥有最新的数据，其</summary>
      
    
    
    
    <category term="databases" scheme="https://mqrayblog.cn/categories/databases/"/>
    
    
    <category term="redis" scheme="https://mqrayblog.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis之客户端</title>
    <link href="https://mqrayblog.cn/2023/08/05/redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://mqrayblog.cn/2023/08/05/redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2023-08-05T10:13:32.000Z</published>
    <updated>2023-10-24T04:46:09.788Z</updated>
    
    <content type="html"><![CDATA[<p><code>redis</code>服务器是典型的一对多服务器程序，一个服务器可以和多个客户端建立网络请求，每个客户端可以向服务器发送命令请求，服务器接收并处理客户端发送的命令请求，并向客户端返回命令回复。<br>通过使用由<code>IO多路复用技术</code>实现的文件事件处理器，<code>redis</code>服务器使用单线程单进程的方式处理命令请求，并与多个客户端进行网络通信。6.0之后，IO多路复用处使用多线程实现。<br>与服务器建立连接的客户端将以链表的形式被保存在<code>redisServer</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="built_in">list</span> *clients;  <span class="comment">// 链表保存各客户端状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端状态包含的属性可以分为两类：</p><ol><li>比较通用的属性，无论客户端执行什么工作，都需要使用这些属性</li><li>和特定功能相关的属性，比如操作数据库时需要用到的<code>db</code>属性和<code>dictid</code>属性，执行时需要用到<code>mstate</code>属性等。</li></ol><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">     <span class="type">uint64_t</span> id; <span class="comment">// 自增客户端唯一id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">     <span class="type">uint64_t</span> flags; <span class="comment">// 客户端标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>flags</code>占8个字节，该属性记录了客户端角色以及当前所处的状态，标志值比较多，详见：<a href="https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/src/server.h">server.h</a><br>主从服务器进行复制时，主服务器会成为从服务器的客户端；从服务器也会成为主服务器的客户端</p><ol><li>CLIENT_SLAVE (1&lt;&lt;0)  0000 0001，客户端代表的是一个从服务器。</li><li>CLIENT_MASTER (1&lt;&lt;1) 0000 0010, 客户端代表的是一个主服务器。</li><li>CLIENT_MONITOR (1&lt;&lt;2)  0000 0100，客户端正在执行<code>monitor</code>命令</li><li>CLIENT_MULTI (1&lt;&lt;3) 0000 1000， 客户端正在执行事务。</li><li>CLIENT_BLOCKED (1&lt;&lt;4) 0001 0000，客户端正在被<code>BRPOP/BLPOP</code>等命令阻塞。</li><li>CLIENT_SCRIPT (1&lt;&lt;8)，标识这个客户端是专门用于执行lua脚本的客户端，并没有真正的网络连接。</li><li>CLIENT_UNIX_SOCKET (1&lt;&lt;11) ，标识该客户端通过unix域套接字进行连接。</li><li>CLIENT_FORCE_AOF (1&lt;&lt;14)， 标识该客户端，正在执行<code>aof</code>操作。</li><li>CLIENT_READONLY (1&lt;&lt;17)， 标识客户端当前处于只读状态。</li><li>CLIENT_PUBSUB (1&lt;&lt;18)，标识客户端正处于发布订阅模式下。</li></ol><h4 id="连接信息"><a href="#连接信息" class="headerlink" title="连接信息"></a>连接信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    connection *conn; <span class="comment">// 保存此客户端的连接信息</span></span><br><span class="line">    user *user;       <span class="comment">// 与当前连接绑定的用户</span></span><br><span class="line">    <span class="type">int</span> authenticated; <span class="comment">// 默认用户是否需要身份认证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>authenticated=0</code>表示无需认证，<code>authenticated=1</code>则需要认证。</p><h4 id="RESP-协议版本"><a href="#RESP-协议版本" class="headerlink" title="RESP 协议版本"></a>RESP 协议版本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> resp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即RESP协议版本，基于TCP的应用层协议 RESP(REdis Serialization Protocol)。</p><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">     redisDb *db; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端当前指向的数据库指针。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    robj *name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此客户端的名称，默认为空。可以通过<code>client list</code>命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">182.168.168.226:6379&gt; client list</span><br><span class="line">id=764370 addr=182.168.106.129:34520 laddr=182.168.168.226:6379 fd=27 name= age=932860 idle=932860 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20504 events=r cmd=hgetall user=default redir=-1</span><br></pre></td></tr></table></figure><h4 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    sds querybuf;  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> qb_pos; <span class="comment">// 用以标识输入缓冲区中已读位置</span></span><br><span class="line">    <span class="type">size_t</span> querybuf_peak; <span class="comment">// 最近100ms+输入缓冲区的峰值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端输入缓冲区用于保存客户端发送的命令请求。输入缓冲区大小会根据输入内容动态的缩小或者扩大，但最多不能超过1G，否则服务器将关闭此客户端。</p><h4 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缓冲区大小由一个链表和任意多个字符串对象组成，但是为了避免客户端回复过大，占用过多的服务器资源，服务器会检查客户端的输出缓冲区大小，并在缓冲区大小超限时，执行相应的操作。服务器使用两种模式来限制客户端输出缓冲区的大小：</p><ol><li>硬性限制: 如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端；</li><li>软性限制: 如果输出缓冲区大小超过软性限制所设置的大小，但是没超过硬性限制，则服务器使用客户端结构体中<code>obuf_soft_limit_reached_time</code>属性记录客户端到达软性限制的起始时间，而后继续监视客户端，如果输出缓冲区大小一直超出软性限制，且持续时长超过服务器中设定的时长，则服务器关闭客户端。<br>使用<code>client-output-buffer-limit</code>可以为普通客户端、从服务器客户端、执行发布订阅功能的客户端分别设置不同的软性限制和硬性限制：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit &lt;<span class="class"><span class="keyword">class</span>&gt;</span> &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">// 将普通客户端的软性限制和硬性限制都设置为0，即不限制客户端输出缓冲区大小</span></span><br><span class="line">client-output-buffer-limit replica <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span> <span class="comment">// 将从服务器客户端的硬性限制为256m，软性限制为64m，软性限制时长为60s</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span> <span class="comment">// 将执行发布订阅功能客户端的硬性限制为32m, 软性限制为8m，软性限制时长为60s</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">// 当前命令的参数个数</span></span><br><span class="line">    robj **argv;            <span class="comment">// 当前命令 的参数</span></span><br><span class="line">    <span class="type">int</span> argv_len;           <span class="comment">// argv数组的长度，可能会大于argc</span></span><br><span class="line">    <span class="type">int</span> original_argc;      <span class="comment">// 在命令被重写时，记录命令原始参数个数</span></span><br><span class="line">    robj **original_argv;   <span class="comment">// 命令重写前，原始的参数</span></span><br><span class="line">    <span class="type">size_t</span> argv_len_sum;    <span class="comment">// 命令参数长度之和</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">// 上次执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">realcmd</span>;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，<code>lastcmd</code>使用<code>redisCommand</code>记录了上次执行的命令，<code>redisCommand</code>的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="comment">// 声明类数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *declared_name; <span class="comment">// 标识命令名，之所以定义为指针是为了兼容原生命令和sds命令</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *summary; <span class="comment">// 命令概要，可选</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *complexity; <span class="comment">// 复杂度描述， 可选</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *since; <span class="comment">// 命令的首次发布版本，可选</span></span><br><span class="line">    <span class="type">int</span> doc_flags; <span class="comment">/* Flags for documentation (see CMD_DOC_*). */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *replaced_by; <span class="comment">// 如果命令被废弃，则填写其继任者</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *deprecated_since; <span class="comment">// 命令何时被废弃</span></span><br><span class="line">    redisCommandGroup group; <span class="comment">// 命令组</span></span><br><span class="line">    commandHistory *history; <span class="comment">// 命令历史</span></span><br><span class="line">    <span class="type">int</span> num_history;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> **tips; <span class="comment">/* An array of strings that are meant to be tips for clients/proxies regarding this command */</span></span><br><span class="line">    <span class="type">int</span> num_tips;</span><br><span class="line">    redisCommandProc *proc; <span class="comment">// 命令实现</span></span><br><span class="line">    <span class="type">int</span> arity; <span class="comment">// 参数个数</span></span><br><span class="line">    <span class="type">uint64_t</span> flags; <span class="comment">/* Command flags, see CMD_*. */</span></span><br><span class="line">    <span class="type">uint64_t</span> acl_categories; <span class="comment">// ACL分类</span></span><br><span class="line">    keySpec *key_specs;</span><br><span class="line">    <span class="type">int</span> key_specs_num;</span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * Used for Redis Cluster redirect (may be NULL) */</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc; <span class="comment">// 使用函数确定命令行中的键参数</span></span><br><span class="line">    <span class="type">int</span> num_args; <span class="comment">// 命令参数数组长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">subcommands</span>;</span> <span class="comment">// 子命令数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommandArg</span> *<span class="title">args</span>;</span> <span class="comment">// 命令参数数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOG_REQ_RES</span></span><br><span class="line">    <span class="comment">/* Reply schema */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jsonObject</span> *<span class="title">reply_schema</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行时填充的数据</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> microseconds, calls, rejected_calls, failed_calls;</span><br><span class="line">    <span class="type">int</span> id;   <span class="comment">// 命令id，从0开始，在运行时分配，用于acl检查；如果当前连接的用户具有此命令位，则此连接能执行给定的命令。[位图]</span></span><br><span class="line">    sds fullname; <span class="comment">// sds描述的命令全名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hdr_histogram</span>* <span class="title">latency_histogram</span>;</span> <span class="comment">/*points to the command latency command histogram (unit of time nanosecond) */</span></span><br><span class="line">    keySpec legacy_range_key_spec; <span class="comment">/* The legacy (first,last,step) key spec is</span></span><br><span class="line"><span class="comment">                                     * still maintained (if applicable) so that</span></span><br><span class="line"><span class="comment">                                     * we can still support the reply format of</span></span><br><span class="line"><span class="comment">                                     * COMMAND INFO and COMMAND GETKEYS */</span></span><br><span class="line">    dict *subcommands_dict; <span class="comment">// 保留子命令的字典，键是子命令的sds名称(非全名)，值为redisCommand的指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RedisModuleCommand</span> *<span class="title">module_cmd</span>;</span> <span class="comment">/* A pointer to the module command data (NULL if native command) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<code>redisCommandTable</code>的实现使用python实现的，详见<a href="https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/utils/generate-command-code.py#L613">redisCommand初始化</a><br>另外这个链接可以方便查看<code>redis</code>提供的命令的复杂度: <a href="https://github.com/redis/redis/tree/1b6bdff48dcc333affab02b945821eb865529de2/src/commands">commands</a></p><h4 id="时间参数"><a href="#时间参数" class="headerlink" title="时间参数"></a>时间参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> ctime;           <span class="comment">// 客户端创建时间</span></span><br><span class="line">    <span class="type">long</span> duration;          <span class="comment">// 当前命令的执行时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction; <span class="comment">// 上次交互时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="client结构体详情"><a href="#client结构体详情" class="headerlink" title="client结构体详情"></a>client结构体详情</h4><p>redis客户端的结构体定义在<code>redis.h/client</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    <span class="type">uint64_t</span> flags;         <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line">    connection *conn;</span><br><span class="line">    <span class="type">int</span> resp;               <span class="comment">/* RESP protocol version. Can be 2 or 3. */</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME. */</span></span><br><span class="line">    robj *lib_name;         <span class="comment">/* The client library name as set by CLIENT SETINFO. */</span></span><br><span class="line">    robj *lib_ver;          <span class="comment">/* The client library version as set by CLIENT SETINFO. */</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="type">size_t</span> qb_pos;          <span class="comment">/* The position we have read in querybuf. */</span></span><br><span class="line">    <span class="type">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size. */</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="type">int</span> argv_len;           <span class="comment">/* Size of argv array (may be more than argc) */</span></span><br><span class="line">    <span class="type">int</span> original_argc;      <span class="comment">/* Num of arguments of original command if arguments were rewritten. */</span></span><br><span class="line">    robj **original_argv;   <span class="comment">/* Arguments of original command if arguments were rewritten. */</span></span><br><span class="line">    <span class="type">size_t</span> argv_len_sum;    <span class="comment">/* Sum of lengths of objects in argv list. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">realcmd</span>;</span> <span class="comment">/* The original command that was executed by the client,</span></span><br><span class="line"><span class="comment">                                     Used to update error stats in case the c-&gt;cmd was modified</span></span><br><span class="line"><span class="comment">                                     during the command invocation (like on GEOADD for example). */</span></span><br><span class="line">    user *user;             <span class="comment">/* User associated with this connection. If the</span></span><br><span class="line"><span class="comment">                               user is set to NULL the connection can do</span></span><br><span class="line"><span class="comment">                               anything (admin). */</span></span><br><span class="line">    <span class="type">int</span> reqtype;            <span class="comment">/* Request protocol type: PROTO_REQ_* */</span></span><br><span class="line">    <span class="type">int</span> multibulklen;       <span class="comment">/* Number of multi bulk arguments left to read. */</span></span><br><span class="line">    <span class="type">long</span> bulklen;           <span class="comment">/* Length of bulk argument in multi bulk request. */</span></span><br><span class="line">    <span class="built_in">list</span> *reply;            <span class="comment">/* List of reply objects to send to the client. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list. */</span></span><br><span class="line">    <span class="built_in">list</span> *deferred_reply_errors;    <span class="comment">/* Used for module thread safe contexts. */</span></span><br><span class="line">    <span class="type">size_t</span> sentlen;         <span class="comment">/* Amount of bytes already sent in the current</span></span><br><span class="line"><span class="comment">                               buffer or object being sent. */</span></span><br><span class="line">    <span class="type">time_t</span> ctime;           <span class="comment">/* Client creation time. */</span></span><br><span class="line">    <span class="type">long</span> duration;          <span class="comment">/* Current command duration. Used for measuring latency of blocking/non-blocking cmds */</span></span><br><span class="line">    <span class="type">int</span> slot;               <span class="comment">/* The slot the client is executing against. Set to -1 if no slot is being used */</span></span><br><span class="line">    dictEntry *cur_script;  <span class="comment">/* Cached pointer to the dictEntry of the script being executed. */</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction; <span class="comment">/* Time of the last interaction, used for timeout */</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="type">int</span> authenticated;      <span class="comment">/* Needed when the default user requires auth. */</span></span><br><span class="line">    <span class="type">int</span> replstate;          <span class="comment">/* Replication state if this is a slave. */</span></span><br><span class="line">    <span class="type">int</span> repl_start_cmd_stream_on_ack; <span class="comment">/* Install slave write handler on first ACK. */</span></span><br><span class="line">    <span class="type">int</span> repldbfd;           <span class="comment">/* Replication DB file descriptor. */</span></span><br><span class="line">    <span class="type">off_t</span> repldboff;        <span class="comment">/* Replication DB file offset. */</span></span><br><span class="line">    <span class="type">off_t</span> repldbsize;       <span class="comment">/* Replication DB file size. */</span></span><br><span class="line">    sds replpreamble;       <span class="comment">/* Replication DB preamble. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> read_reploff; <span class="comment">/* Read replication offset if this is a master. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> reploff;      <span class="comment">/* Applied replication offset if this is a master. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_applied; <span class="comment">/* Applied replication data count in querybuf, if this is a replica. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_off; <span class="comment">/* Replication ack offset, if this is a slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_aof_off; <span class="comment">/* Replication AOF fsync ack offset, if this is a slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_time;<span class="comment">/* Replication ack time, if this is a slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_last_partial_write; <span class="comment">/* The last time the server did a partial write from the RDB child pipe to this replica  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> psync_initial_offset; <span class="comment">/* FULLRESYNC reply offset other slaves</span></span><br><span class="line"><span class="comment">                                       copying this slave output buffer</span></span><br><span class="line"><span class="comment">                                       should use. */</span></span><br><span class="line">    <span class="type">char</span> replid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* Master replication ID (if master). */</span></span><br><span class="line">    <span class="type">int</span> slave_listening_port; <span class="comment">/* As configured with: REPLCONF listening-port */</span></span><br><span class="line">    <span class="type">char</span> *slave_addr;       <span class="comment">/* Optionally given by REPLCONF ip-address */</span></span><br><span class="line">    <span class="type">int</span> slave_capa;         <span class="comment">/* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span></span><br><span class="line">    <span class="type">int</span> slave_req;          <span class="comment">/* Slave requirements: SLAVE_REQ_* */</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line">    blockingState bstate;     <span class="comment">/* blocking state */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> woff;         <span class="comment">/* Last write global replication offset. */</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* channels a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    dict *pubsub_patterns;  <span class="comment">/* patterns a client is interested in (PSUBSCRIBE) */</span></span><br><span class="line">    dict *pubsubshard_channels;  <span class="comment">/* shard level channels a client is interested in (SSUBSCRIBE) */</span></span><br><span class="line">    sds peerid;             <span class="comment">/* Cached peer ID. */</span></span><br><span class="line">    sds sockname;           <span class="comment">/* Cached connection target address. */</span></span><br><span class="line">    listNode *client_list_node; <span class="comment">/* list node in client list */</span></span><br><span class="line">    listNode *postponed_list_node; <span class="comment">/* list node within the postponed list */</span></span><br><span class="line">    listNode *pending_read_list_node; <span class="comment">/* list node in clients pending read list */</span></span><br><span class="line">    <span class="type">void</span> *module_blocked_client; <span class="comment">/* Pointer to the RedisModuleBlockedClient associated with this</span></span><br><span class="line"><span class="comment">                                  * client. This is set in case of module authentication before the</span></span><br><span class="line"><span class="comment">                                  * unblocked client is reprocessed to handle reply callbacks. */</span></span><br><span class="line">    <span class="type">void</span> *module_auth_ctx; <span class="comment">/* Ongoing / attempted module based auth callback&#x27;s ctx.</span></span><br><span class="line"><span class="comment">                            * This is only tracked within the context of the command attempting</span></span><br><span class="line"><span class="comment">                            * authentication. If not NULL, it means module auth is in progress. */</span></span><br><span class="line">    RedisModuleUserChangedFunc auth_callback; <span class="comment">/* Module callback to execute</span></span><br><span class="line"><span class="comment">                                               * when the authenticated user</span></span><br><span class="line"><span class="comment">                                               * changes. */</span></span><br><span class="line">    <span class="type">void</span> *auth_callback_privdata; <span class="comment">/* Private data that is passed when the auth</span></span><br><span class="line"><span class="comment">                                   * changed callback is executed. Opaque for</span></span><br><span class="line"><span class="comment">                                   * Redis Core. */</span></span><br><span class="line">    <span class="type">void</span> *auth_module;      <span class="comment">/* The module that owns the callback, which is used</span></span><br><span class="line"><span class="comment">                             * to disconnect the client if the module is</span></span><br><span class="line"><span class="comment">                             * unloaded for cleanup. Opaque for Redis Core.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this client is in tracking mode and this field is non zero,</span></span><br><span class="line"><span class="comment">     * invalidation messages for keys fetched by this client will be sent to</span></span><br><span class="line"><span class="comment">     * the specified client ID. */</span></span><br><span class="line">    <span class="type">uint64_t</span> client_tracking_redirection;</span><br><span class="line">    rax *client_tracking_prefixes; <span class="comment">/* A dictionary of prefixes we are already</span></span><br><span class="line"><span class="comment">                                      subscribed to in BCAST mode, in the</span></span><br><span class="line"><span class="comment">                                      context of client side caching. */</span></span><br><span class="line">    <span class="comment">/* In updateClientMemoryUsage() we track the memory usage of</span></span><br><span class="line"><span class="comment">     * each client and add it to the sum of all the clients of a given type,</span></span><br><span class="line"><span class="comment">     * however we need to remember what was the old contribution of each</span></span><br><span class="line"><span class="comment">     * client, and in which category the client was, in order to remove it</span></span><br><span class="line"><span class="comment">     * before adding it the new value. */</span></span><br><span class="line">    <span class="type">size_t</span> last_memory_usage;</span><br><span class="line">    <span class="type">int</span> last_memory_type;</span><br><span class="line"></span><br><span class="line">    listNode *mem_usage_bucket_node;</span><br><span class="line">    clientMemUsageBucket *mem_usage_bucket;</span><br><span class="line"></span><br><span class="line">    listNode *ref_repl_buf_node; <span class="comment">/* Referenced node of replication buffer blocks,</span></span><br><span class="line"><span class="comment">                                  * see the definition of replBufBlock. */</span></span><br><span class="line">    <span class="type">size_t</span> ref_block_pos;        <span class="comment">/* Access position of referenced buffer block,</span></span><br><span class="line"><span class="comment">                                  * i.e. the next offset to send. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* list node in clients_pending_write list */</span></span><br><span class="line">    listNode clients_pending_write_node;</span><br><span class="line">    <span class="comment">/* Response buffer */</span></span><br><span class="line">    <span class="type">size_t</span> buf_peak; <span class="comment">/* Peak used size of buffer in last 5 sec interval. */</span></span><br><span class="line">    <span class="type">mstime_t</span> buf_peak_last_reset_time; <span class="comment">/* keeps the last time the buffer peak value was reset */</span></span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">    <span class="type">size_t</span> buf_usable_size; <span class="comment">/* Usable size of buffer. */</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOG_REQ_RES</span></span><br><span class="line">    clientReqResInfo reqres;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/src/server.h">1. server.h</a><br><a href="https://zhuanlan.zhihu.com/p/607693207">2. Redis 源码剖析 3 – redisCommand</a><br><a href="https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/utils/generate-command-code.py#L613">3. redisCommand初始化</a><br><a href="https://github.com/redis/redis/tree/1b6bdff48dcc333affab02b945821eb865529de2/src/commands">4. commands</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;redis&lt;/code&gt;服务器是典型的一对多服务器程序，一个服务器可以和多个客户端建立网络请求，每个客户端可以向服务器发送命令请求，服务器接收并处理客户端发送的命令请求，并向客户端返回命令回复。&lt;br&gt;通过使用由&lt;code&gt;IO多路复用技术&lt;/code&gt;实现的文</summary>
      
    
    
    
    <category term="databases" scheme="https://mqrayblog.cn/categories/databases/"/>
    
    
    <category term="redis" scheme="https://mqrayblog.cn/tags/redis/"/>
    
  </entry>
  
</feed>
