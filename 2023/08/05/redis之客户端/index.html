<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>redis之客户端 | mqray&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="redis服务器是典型的一对多服务器程序，一个服务器可以和多个客户端建立网络请求，每个客户端可以向服务器发送命令请求，服务器接收并处理客户端发送的命令请求，并向客户端返回命令回复。通过使用由IO多路复用技术实现的文件事件处理器，redis服务器使用单线程单进程的方式处理命令请求，并与多个客户端进行网络通信。6.0之后，IO多路复用处使用多线程实现。与服务器建立连接的客户端将以链表的形式被保存在re">
<meta property="og:type" content="article">
<meta property="og:title" content="redis之客户端">
<meta property="og:url" content="https://mqrayblog.cn/2023/08/05/redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/index.html">
<meta property="og:site_name" content="mqray&#39;s blog">
<meta property="og:description" content="redis服务器是典型的一对多服务器程序，一个服务器可以和多个客户端建立网络请求，每个客户端可以向服务器发送命令请求，服务器接收并处理客户端发送的命令请求，并向客户端返回命令回复。通过使用由IO多路复用技术实现的文件事件处理器，redis服务器使用单线程单进程的方式处理命令请求，并与多个客户端进行网络通信。6.0之后，IO多路复用处使用多线程实现。与服务器建立连接的客户端将以链表的形式被保存在re">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-08-05T10:13:32.000Z">
<meta property="article:modified_time" content="2023-10-30T16:35:07.233Z">
<meta property="article:author" content="mqray">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="mqray's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">mqray&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mqrayblog.cn"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-redis之客户端" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/05/redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/" class="article-date">
  <time class="dt-published" datetime="2023-08-05T10:13:32.000Z" itemprop="datePublished">2023-08-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/databases/">databases</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      redis之客户端
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>redis</code>服务器是典型的一对多服务器程序，一个服务器可以和多个客户端建立网络请求，每个客户端可以向服务器发送命令请求，服务器接收并处理客户端发送的命令请求，并向客户端返回命令回复。<br>通过使用由<code>IO多路复用技术</code>实现的文件事件处理器，<code>redis</code>服务器使用单线程单进程的方式处理命令请求，并与多个客户端进行网络通信。6.0之后，IO多路复用处使用多线程实现。<br>与服务器建立连接的客户端将以链表的形式被保存在<code>redisServer</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="built_in">list</span> *clients;  <span class="comment">// 链表保存各客户端状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h3><p>客户端状态包含的属性可以分为两类：</p>
<ol>
<li>比较通用的属性，无论客户端执行什么工作，都需要使用这些属性</li>
<li>和特定功能相关的属性，比如操作数据库时需要用到的<code>db</code>属性和<code>dictid</code>属性，执行时需要用到<code>mstate</code>属性等。</li>
</ol>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">     <span class="type">uint64_t</span> id; <span class="comment">// 自增客户端唯一id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">     <span class="type">uint64_t</span> flags; <span class="comment">// 客户端标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>flags</code>占8个字节，该属性记录了客户端角色以及当前所处的状态，标志值比较多，详见：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/src/server.h">server.h</a><br>主从服务器进行复制时，主服务器会成为从服务器的客户端；从服务器也会成为主服务器的客户端</p>
<ol>
<li>CLIENT_SLAVE (1&lt;&lt;0)  0000 0001，客户端代表的是一个从服务器。</li>
<li>CLIENT_MASTER (1&lt;&lt;1) 0000 0010, 客户端代表的是一个主服务器。</li>
<li>CLIENT_MONITOR (1&lt;&lt;2)  0000 0100，客户端正在执行<code>monitor</code>命令</li>
<li>CLIENT_MULTI (1&lt;&lt;3) 0000 1000， 客户端正在执行事务。</li>
<li>CLIENT_BLOCKED (1&lt;&lt;4) 0001 0000，客户端正在被<code>BRPOP/BLPOP</code>等命令阻塞。</li>
<li>CLIENT_SCRIPT (1&lt;&lt;8)，标识这个客户端是专门用于执行lua脚本的客户端，并没有真正的网络连接。</li>
<li>CLIENT_UNIX_SOCKET (1&lt;&lt;11) ，标识该客户端通过unix域套接字进行连接。</li>
<li>CLIENT_FORCE_AOF (1&lt;&lt;14)， 标识该客户端，正在执行<code>aof</code>操作。</li>
<li>CLIENT_READONLY (1&lt;&lt;17)， 标识客户端当前处于只读状态。</li>
<li>CLIENT_PUBSUB (1&lt;&lt;18)，标识客户端正处于发布订阅模式下。</li>
</ol>
<h4 id="连接信息"><a href="#连接信息" class="headerlink" title="连接信息"></a>连接信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    connection *conn; <span class="comment">// 保存此客户端的连接信息</span></span><br><span class="line">    user *user;       <span class="comment">// 与当前连接绑定的用户</span></span><br><span class="line">    <span class="type">int</span> authenticated; <span class="comment">// 默认用户是否需要身份认证</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>authenticated=0</code>表示无需认证，<code>authenticated=1</code>则需要认证。</p>
<h4 id="RESP-协议版本"><a href="#RESP-协议版本" class="headerlink" title="RESP 协议版本"></a>RESP 协议版本</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> resp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即RESP协议版本，基于TCP的应用层协议 RESP(REdis Serialization Protocol)。</p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">     redisDb *db; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端当前指向的数据库指针。</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    robj *name; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此客户端的名称，默认为空。可以通过<code>client list</code>命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">182.168.168.226:6379&gt; client list</span><br><span class="line">id=764370 addr=182.168.106.129:34520 laddr=182.168.168.226:6379 fd=27 name= age=932860 idle=932860 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 argv-mem=0 obl=0 oll=0 omem=0 tot-mem=20504 events=r cmd=hgetall user=default redir=-1</span><br></pre></td></tr></table></figure>


<h4 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    sds querybuf;  <span class="comment">// 输入缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> qb_pos; <span class="comment">// 用以标识输入缓冲区中已读位置</span></span><br><span class="line">    <span class="type">size_t</span> querybuf_peak; <span class="comment">// 最近100ms+输入缓冲区的峰值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端输入缓冲区用于保存客户端发送的命令请求。输入缓冲区大小会根据输入内容动态的缩小或者扩大，但最多不能超过1G，否则服务器将关闭此客户端。</p>
<h4 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>缓冲区大小由一个链表和任意多个字符串对象组成，但是为了避免客户端回复过大，占用过多的服务器资源，服务器会检查客户端的输出缓冲区大小，并在缓冲区大小超限时，执行相应的操作。服务器使用两种模式来限制客户端输出缓冲区的大小：</p>
<ol>
<li>硬性限制: 如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端；</li>
<li>软性限制: 如果输出缓冲区大小超过软性限制所设置的大小，但是没超过硬性限制，则服务器使用客户端结构体中<code>obuf_soft_limit_reached_time</code>属性记录客户端到达软性限制的起始时间，而后继续监视客户端，如果输出缓冲区大小一直超出软性限制，且持续时长超过服务器中设定的时长，则服务器关闭客户端。<br>使用<code>client-output-buffer-limit</code>可以为普通客户端、从服务器客户端、执行发布订阅功能的客户端分别设置不同的软性限制和硬性限制：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit &lt;<span class="class"><span class="keyword">class</span>&gt;</span> &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br><span class="line">client-output-buffer-limit normal <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">// 将普通客户端的软性限制和硬性限制都设置为0，即不限制客户端输出缓冲区大小</span></span><br><span class="line">client-output-buffer-limit replica <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span> <span class="comment">// 将从服务器客户端的硬性限制为256m，软性限制为64m，软性限制时长为60s</span></span><br><span class="line">client-output-buffer-limit pubsub <span class="number">32</span>mb <span class="number">8</span>mb <span class="number">60</span> <span class="comment">// 将执行发布订阅功能客户端的硬性限制为32m, 软性限制为8m，软性限制时长为60s</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="命令与命令参数"><a href="#命令与命令参数" class="headerlink" title="命令与命令参数"></a>命令与命令参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">// 当前命令的参数个数</span></span><br><span class="line">    robj **argv;            <span class="comment">// 当前命令 的参数</span></span><br><span class="line">    <span class="type">int</span> argv_len;           <span class="comment">// argv数组的长度，可能会大于argc</span></span><br><span class="line">    <span class="type">int</span> original_argc;      <span class="comment">// 在命令被重写时，记录命令原始参数个数</span></span><br><span class="line">    robj **original_argv;   <span class="comment">// 命令重写前，原始的参数</span></span><br><span class="line">    <span class="type">size_t</span> argv_len_sum;    <span class="comment">// 命令参数长度之和</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">// 上次执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">realcmd</span>;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，<code>lastcmd</code>使用<code>redisCommand</code>记录了上次执行的命令，<code>redisCommand</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="comment">// 声明类数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *declared_name; <span class="comment">// 标识命令名，之所以定义为指针是为了兼容原生命令和sds命令</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *summary; <span class="comment">// 命令概要，可选</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *complexity; <span class="comment">// 复杂度描述， 可选</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *since; <span class="comment">// 命令的首次发布版本，可选</span></span><br><span class="line">    <span class="type">int</span> doc_flags; <span class="comment">/* Flags for documentation (see CMD_DOC_*). */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *replaced_by; <span class="comment">// 如果命令被废弃，则填写其继任者</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *deprecated_since; <span class="comment">// 命令何时被废弃</span></span><br><span class="line">    redisCommandGroup group; <span class="comment">// 命令组</span></span><br><span class="line">    commandHistory *history; <span class="comment">// 命令历史</span></span><br><span class="line">    <span class="type">int</span> num_history;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> **tips; <span class="comment">/* An array of strings that are meant to be tips for clients/proxies regarding this command */</span></span><br><span class="line">    <span class="type">int</span> num_tips;</span><br><span class="line">    redisCommandProc *proc; <span class="comment">// 命令实现</span></span><br><span class="line">    <span class="type">int</span> arity; <span class="comment">// 参数个数</span></span><br><span class="line">    <span class="type">uint64_t</span> flags; <span class="comment">/* Command flags, see CMD_*. */</span></span><br><span class="line">    <span class="type">uint64_t</span> acl_categories; <span class="comment">// ACL分类</span></span><br><span class="line">    keySpec *key_specs;</span><br><span class="line">    <span class="type">int</span> key_specs_num;</span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * Used for Redis Cluster redirect (may be NULL) */</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc; <span class="comment">// 使用函数确定命令行中的键参数</span></span><br><span class="line">    <span class="type">int</span> num_args; <span class="comment">// 命令参数数组长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">subcommands</span>;</span> <span class="comment">// 子命令数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommandArg</span> *<span class="title">args</span>;</span> <span class="comment">// 命令参数数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOG_REQ_RES</span></span><br><span class="line">    <span class="comment">/* Reply schema */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">jsonObject</span> *<span class="title">reply_schema</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行时填充的数据</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> microseconds, calls, rejected_calls, failed_calls;</span><br><span class="line">    <span class="type">int</span> id;   <span class="comment">// 命令id，从0开始，在运行时分配，用于acl检查；如果当前连接的用户具有此命令位，则此连接能执行给定的命令。[位图]</span></span><br><span class="line">    sds fullname; <span class="comment">// sds描述的命令全名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hdr_histogram</span>* <span class="title">latency_histogram</span>;</span> <span class="comment">/*points to the command latency command histogram (unit of time nanosecond) */</span></span><br><span class="line">    keySpec legacy_range_key_spec; <span class="comment">/* The legacy (first,last,step) key spec is</span></span><br><span class="line"><span class="comment">                                     * still maintained (if applicable) so that</span></span><br><span class="line"><span class="comment">                                     * we can still support the reply format of</span></span><br><span class="line"><span class="comment">                                     * COMMAND INFO and COMMAND GETKEYS */</span></span><br><span class="line">    dict *subcommands_dict; <span class="comment">// 保留子命令的字典，键是子命令的sds名称(非全名)，值为redisCommand的指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RedisModuleCommand</span> *<span class="title">module_cmd</span>;</span> <span class="comment">/* A pointer to the module command data (NULL if native command) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>redisCommandTable</code>的实现使用python实现的，详见<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/utils/generate-command-code.py#L613">redisCommand初始化</a><br>另外这个链接可以方便查看<code>redis</code>提供的命令的复杂度: <a target="_blank" rel="noopener" href="https://github.com/redis/redis/tree/1b6bdff48dcc333affab02b945821eb865529de2/src/commands">commands</a></p>
<h4 id="时间参数"><a href="#时间参数" class="headerlink" title="时间参数"></a>时间参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> ctime;           <span class="comment">// 客户端创建时间</span></span><br><span class="line">    <span class="type">long</span> duration;          <span class="comment">// 当前命令的执行时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction; <span class="comment">// 上次交互时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="client结构体详情"><a href="#client结构体详情" class="headerlink" title="client结构体详情"></a>client结构体详情</h4><p>redis客户端的结构体定义在<code>redis.h/client</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    <span class="type">uint64_t</span> flags;         <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line">    connection *conn;</span><br><span class="line">    <span class="type">int</span> resp;               <span class="comment">/* RESP protocol version. Can be 2 or 3. */</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME. */</span></span><br><span class="line">    robj *lib_name;         <span class="comment">/* The client library name as set by CLIENT SETINFO. */</span></span><br><span class="line">    robj *lib_ver;          <span class="comment">/* The client library version as set by CLIENT SETINFO. */</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="type">size_t</span> qb_pos;          <span class="comment">/* The position we have read in querybuf. */</span></span><br><span class="line">    <span class="type">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size. */</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="type">int</span> argv_len;           <span class="comment">/* Size of argv array (may be more than argc) */</span></span><br><span class="line">    <span class="type">int</span> original_argc;      <span class="comment">/* Num of arguments of original command if arguments were rewritten. */</span></span><br><span class="line">    robj **original_argv;   <span class="comment">/* Arguments of original command if arguments were rewritten. */</span></span><br><span class="line">    <span class="type">size_t</span> argv_len_sum;    <span class="comment">/* Sum of lengths of objects in argv list. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">realcmd</span>;</span> <span class="comment">/* The original command that was executed by the client,</span></span><br><span class="line"><span class="comment">                                     Used to update error stats in case the c-&gt;cmd was modified</span></span><br><span class="line"><span class="comment">                                     during the command invocation (like on GEOADD for example). */</span></span><br><span class="line">    user *user;             <span class="comment">/* User associated with this connection. If the</span></span><br><span class="line"><span class="comment">                               user is set to NULL the connection can do</span></span><br><span class="line"><span class="comment">                               anything (admin). */</span></span><br><span class="line">    <span class="type">int</span> reqtype;            <span class="comment">/* Request protocol type: PROTO_REQ_* */</span></span><br><span class="line">    <span class="type">int</span> multibulklen;       <span class="comment">/* Number of multi bulk arguments left to read. */</span></span><br><span class="line">    <span class="type">long</span> bulklen;           <span class="comment">/* Length of bulk argument in multi bulk request. */</span></span><br><span class="line">    <span class="built_in">list</span> *reply;            <span class="comment">/* List of reply objects to send to the client. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list. */</span></span><br><span class="line">    <span class="built_in">list</span> *deferred_reply_errors;    <span class="comment">/* Used for module thread safe contexts. */</span></span><br><span class="line">    <span class="type">size_t</span> sentlen;         <span class="comment">/* Amount of bytes already sent in the current</span></span><br><span class="line"><span class="comment">                               buffer or object being sent. */</span></span><br><span class="line">    <span class="type">time_t</span> ctime;           <span class="comment">/* Client creation time. */</span></span><br><span class="line">    <span class="type">long</span> duration;          <span class="comment">/* Current command duration. Used for measuring latency of blocking/non-blocking cmds */</span></span><br><span class="line">    <span class="type">int</span> slot;               <span class="comment">/* The slot the client is executing against. Set to -1 if no slot is being used */</span></span><br><span class="line">    dictEntry *cur_script;  <span class="comment">/* Cached pointer to the dictEntry of the script being executed. */</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction; <span class="comment">/* Time of the last interaction, used for timeout */</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="type">int</span> authenticated;      <span class="comment">/* Needed when the default user requires auth. */</span></span><br><span class="line">    <span class="type">int</span> replstate;          <span class="comment">/* Replication state if this is a slave. */</span></span><br><span class="line">    <span class="type">int</span> repl_start_cmd_stream_on_ack; <span class="comment">/* Install slave write handler on first ACK. */</span></span><br><span class="line">    <span class="type">int</span> repldbfd;           <span class="comment">/* Replication DB file descriptor. */</span></span><br><span class="line">    <span class="type">off_t</span> repldboff;        <span class="comment">/* Replication DB file offset. */</span></span><br><span class="line">    <span class="type">off_t</span> repldbsize;       <span class="comment">/* Replication DB file size. */</span></span><br><span class="line">    sds replpreamble;       <span class="comment">/* Replication DB preamble. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> read_reploff; <span class="comment">/* Read replication offset if this is a master. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> reploff;      <span class="comment">/* Applied replication offset if this is a master. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_applied; <span class="comment">/* Applied replication data count in querybuf, if this is a replica. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_off; <span class="comment">/* Replication ack offset, if this is a slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_aof_off; <span class="comment">/* Replication AOF fsync ack offset, if this is a slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_time;<span class="comment">/* Replication ack time, if this is a slave. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_last_partial_write; <span class="comment">/* The last time the server did a partial write from the RDB child pipe to this replica  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> psync_initial_offset; <span class="comment">/* FULLRESYNC reply offset other slaves</span></span><br><span class="line"><span class="comment">                                       copying this slave output buffer</span></span><br><span class="line"><span class="comment">                                       should use. */</span></span><br><span class="line">    <span class="type">char</span> replid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* Master replication ID (if master). */</span></span><br><span class="line">    <span class="type">int</span> slave_listening_port; <span class="comment">/* As configured with: REPLCONF listening-port */</span></span><br><span class="line">    <span class="type">char</span> *slave_addr;       <span class="comment">/* Optionally given by REPLCONF ip-address */</span></span><br><span class="line">    <span class="type">int</span> slave_capa;         <span class="comment">/* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span></span><br><span class="line">    <span class="type">int</span> slave_req;          <span class="comment">/* Slave requirements: SLAVE_REQ_* */</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line">    blockingState bstate;     <span class="comment">/* blocking state */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> woff;         <span class="comment">/* Last write global replication offset. */</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* channels a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    dict *pubsub_patterns;  <span class="comment">/* patterns a client is interested in (PSUBSCRIBE) */</span></span><br><span class="line">    dict *pubsubshard_channels;  <span class="comment">/* shard level channels a client is interested in (SSUBSCRIBE) */</span></span><br><span class="line">    sds peerid;             <span class="comment">/* Cached peer ID. */</span></span><br><span class="line">    sds sockname;           <span class="comment">/* Cached connection target address. */</span></span><br><span class="line">    listNode *client_list_node; <span class="comment">/* list node in client list */</span></span><br><span class="line">    listNode *postponed_list_node; <span class="comment">/* list node within the postponed list */</span></span><br><span class="line">    listNode *pending_read_list_node; <span class="comment">/* list node in clients pending read list */</span></span><br><span class="line">    <span class="type">void</span> *module_blocked_client; <span class="comment">/* Pointer to the RedisModuleBlockedClient associated with this</span></span><br><span class="line"><span class="comment">                                  * client. This is set in case of module authentication before the</span></span><br><span class="line"><span class="comment">                                  * unblocked client is reprocessed to handle reply callbacks. */</span></span><br><span class="line">    <span class="type">void</span> *module_auth_ctx; <span class="comment">/* Ongoing / attempted module based auth callback&#x27;s ctx.</span></span><br><span class="line"><span class="comment">                            * This is only tracked within the context of the command attempting</span></span><br><span class="line"><span class="comment">                            * authentication. If not NULL, it means module auth is in progress. */</span></span><br><span class="line">    RedisModuleUserChangedFunc auth_callback; <span class="comment">/* Module callback to execute</span></span><br><span class="line"><span class="comment">                                               * when the authenticated user</span></span><br><span class="line"><span class="comment">                                               * changes. */</span></span><br><span class="line">    <span class="type">void</span> *auth_callback_privdata; <span class="comment">/* Private data that is passed when the auth</span></span><br><span class="line"><span class="comment">                                   * changed callback is executed. Opaque for</span></span><br><span class="line"><span class="comment">                                   * Redis Core. */</span></span><br><span class="line">    <span class="type">void</span> *auth_module;      <span class="comment">/* The module that owns the callback, which is used</span></span><br><span class="line"><span class="comment">                             * to disconnect the client if the module is</span></span><br><span class="line"><span class="comment">                             * unloaded for cleanup. Opaque for Redis Core.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this client is in tracking mode and this field is non zero,</span></span><br><span class="line"><span class="comment">     * invalidation messages for keys fetched by this client will be sent to</span></span><br><span class="line"><span class="comment">     * the specified client ID. */</span></span><br><span class="line">    <span class="type">uint64_t</span> client_tracking_redirection;</span><br><span class="line">    rax *client_tracking_prefixes; <span class="comment">/* A dictionary of prefixes we are already</span></span><br><span class="line"><span class="comment">                                      subscribed to in BCAST mode, in the</span></span><br><span class="line"><span class="comment">                                      context of client side caching. */</span></span><br><span class="line">    <span class="comment">/* In updateClientMemoryUsage() we track the memory usage of</span></span><br><span class="line"><span class="comment">     * each client and add it to the sum of all the clients of a given type,</span></span><br><span class="line"><span class="comment">     * however we need to remember what was the old contribution of each</span></span><br><span class="line"><span class="comment">     * client, and in which category the client was, in order to remove it</span></span><br><span class="line"><span class="comment">     * before adding it the new value. */</span></span><br><span class="line">    <span class="type">size_t</span> last_memory_usage;</span><br><span class="line">    <span class="type">int</span> last_memory_type;</span><br><span class="line"></span><br><span class="line">    listNode *mem_usage_bucket_node;</span><br><span class="line">    clientMemUsageBucket *mem_usage_bucket;</span><br><span class="line"></span><br><span class="line">    listNode *ref_repl_buf_node; <span class="comment">/* Referenced node of replication buffer blocks,</span></span><br><span class="line"><span class="comment">                                  * see the definition of replBufBlock. */</span></span><br><span class="line">    <span class="type">size_t</span> ref_block_pos;        <span class="comment">/* Access position of referenced buffer block,</span></span><br><span class="line"><span class="comment">                                  * i.e. the next offset to send. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* list node in clients_pending_write list */</span></span><br><span class="line">    listNode clients_pending_write_node;</span><br><span class="line">    <span class="comment">/* Response buffer */</span></span><br><span class="line">    <span class="type">size_t</span> buf_peak; <span class="comment">/* Peak used size of buffer in last 5 sec interval. */</span></span><br><span class="line">    <span class="type">mstime_t</span> buf_peak_last_reset_time; <span class="comment">/* keeps the last time the buffer peak value was reset */</span></span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">    <span class="type">size_t</span> buf_usable_size; <span class="comment">/* Usable size of buffer. */</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOG_REQ_RES</span></span><br><span class="line">    clientReqResInfo reqres;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/src/server.h">1. server.h</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/607693207">2. Redis 源码剖析 3 – redisCommand</a><br><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/1b6bdff48dcc333affab02b945821eb865529de2/utils/generate-command-code.py#L613">3. redisCommand初始化</a><br><a target="_blank" rel="noopener" href="https://github.com/redis/redis/tree/1b6bdff48dcc333affab02b945821eb865529de2/src/commands">4. commands</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mqrayblog.cn/2023/08/05/redis%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AB%AF/" data-id="clod4fl24000wofovfj89f0f4" data-title="redis之客户端" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/08/07/redis%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          redis之主从复制
        
      </div>
    </a>
  
  
    <a href="/2023/07/31/redis%E4%B9%8B%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">redis之事件驱动</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/coding/">coding</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/databases/">databases</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sth/" rel="tag">sth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E9%9A%9C/" rel="tag">排障</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag">源码阅读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/java/" style="font-size: 18px;">java</a> <a href="/tags/linux/" style="font-size: 12px;">linux</a> <a href="/tags/redis/" style="font-size: 20px;">redis</a> <a href="/tags/spring/" style="font-size: 14px;">spring</a> <a href="/tags/sth/" style="font-size: 12px;">sth</a> <a href="/tags/%E6%8E%92%E9%9A%9C/" style="font-size: 10px;">排障</a> <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" style="font-size: 16px;">源码阅读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">七月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/10/31/spring%E4%B9%8Bioc/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/10/31/%E5%BB%BA%E7%AB%99/">github + hexo建站[待补充]</a>
          </li>
        
          <li>
            <a href="/2023/10/17/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B3/">springboot源码之启动流程3</a>
          </li>
        
          <li>
            <a href="/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/">springboot源码之启动流程2</a>
          </li>
        
          <li>
            <a href="/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B1/">springboot源码之启动流程1</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 mqray<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>