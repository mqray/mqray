<hr>
<h2 id="title-springboot源码之启动流程3date-2023-10-17-08-54-15tags-spring-java"><a href="#title-springboot源码之启动流程3date-2023-10-17-08-54-15tags-spring-java" class="headerlink" title="title: springboot源码之启动流程3date: 2023-10-17 08:54:15tags:- spring- java"></a>title: springboot源码之启动流程3<br>date: 2023-10-17 08:54:15<br>tags:<br>- spring<br>- java</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>这个部分提出问题，引发思考</p>
</blockquote>
<ol>
<li>单例bean和原型bean的区别以及创建过程的差别？</li>
</ol>
<p>上文<a href="https://mqrayblog.cn/2023/10/12/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B2/">springboot源码之启动流程2</a>中几乎已经走完<code>spring启动流程</code>，但是遗留了两处逻辑 </p>
<p>todo 回顾启动流程！</p>
<ol>
<li>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</li>
<li>ServletWebServerApplicationContext#finishBeanFactoryInitialization</li>
</ol>
<p>现在来看<code>bean的创建流程</code>：</p>
<h3 id="ServletWebServerApplicationContext-finishBeanFactoryInitialization"><a href="#ServletWebServerApplicationContext-finishBeanFactoryInitialization" class="headerlink" title="ServletWebServerApplicationContext#finishBeanFactoryInitialization"></a>ServletWebServerApplicationContext#finishBeanFactoryInitialization</h3><p>完成bean factory的上下文初始化，初始化所有非懒加载的单例</p>
<pre><code class="java">    /**
     * Finish the initialization of this context&#39;s bean factory,
     * initializing all remaining singleton beans.
     */
    protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        // 初始化 上下文转换服务
        if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
                beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
            beanFactory.setConversionService(
                    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
        }

        // 如果没有BeanFactoryPostProcessor，则注入一个默认的值解析器
        // 主要用于解析注解注入的属性值
        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
        }

        // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
        // 初始化 LoadTimeWeaverAware 以提前注册 转化器
        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        for (String weaverAwareName : weaverAwareNames) {
            getBean(weaverAwareName);
        }

        // 不再使用临时的类加载器做类型匹配
        beanFactory.setTempClassLoader(null);

        // 禁止修改所有bean definition，不允许再修改
        beanFactory.freezeConfiguration();

        // 实例化所有非懒加载的单例
        beanFactory.preInstantiateSingletons();
    }
</code></pre>
<h4 id="DefaultListableBeanFactory-preInstantiateSingletons"><a href="#DefaultListableBeanFactory-preInstantiateSingletons" class="headerlink" title="DefaultListableBeanFactory#preInstantiateSingletons"></a>DefaultListableBeanFactory#preInstantiateSingletons</h4><p>确保所有(包含<code>FactoryBeans</code>)非懒加载的单例被初始化</p>
<p>1.<br>2.<br>3. 获取<code>bean</code>，针对beanfactory是否是<code>SmartFactoryBean</code>接口的实现类进行判断。最后会调用<code>getBean</code>方法。</p>
<pre><code class="java">    @Override
    public void preInstantiateSingletons() throws BeansException {
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Pre-instantiating singletons in &quot; + this);
        }

        // 对副本进行迭代以允许init方法注册新的bean定义
        // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
        List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);

        // 调用 非懒加载的bean的初始化
        for (String beanName : beanNames) {
            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
            if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
                if (isFactoryBean(beanName)) {
                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                    if (bean instanceof FactoryBean) {
                        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
                        boolean isEagerInit;
                        if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                            isEagerInit = AccessController.doPrivileged(
                                    (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                                    getAccessControlContext());
                        }
                        else {
                            isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                                    ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                        }
                        if (isEagerInit) {
                            getBean(beanName);
                        }
                    }
                }
                else {
                    getBean(beanName);
                }
            }
        }

        // 触发后置初始化回调函数
        for (String beanName : beanNames) {
            Object singletonInstance = getSingleton(beanName);
            if (singletonInstance instanceof SmartInitializingSingleton) {
                SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
                if (System.getSecurityManager() != null) {
                    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
                        smartSingleton.afterSingletonsInstantiated();
                        return null;
                    }, getAccessControlContext());
                }
                else {
                    smartSingleton.afterSingletonsInstantiated();
                }
            }
        }
    }
</code></pre>
<p><font color=red>先来看比较常见的方法<code>getMergedLocalBeanDefinition</code>，bean定义的抽象类是<code>AbstractBeanDefinition</code>， 普通的 bean在spring加载bean定义的时候是<code>GenericBeanDefinition</code>，而<code>spring</code>上下文实例化所有bean使用的则是<code>RootBeanDefinition，</code>整个过程由<code>getMergedLocalBeanDefinition</code>完成，将非<code>RootBeanDefinition</code>转化为<code>RootBeanDefinition</code>以供后续操作</font></p>
<p>遍历所有bean，获取其<code>beanDefinition</code>，如果没有就找其父类的<code>beanDefinition</code>。</p>
<p><code>preInstantiateSingletons</code>方法完成所有非懒加载的实例的创建。实例化bean过程需要满足如下三个条件：</p>
<ul>
<li>不是抽象类</li>
<li>是单例对象</li>
<li>非懒加载</li>
</ul>
<p>后续逻辑，先判断一下该<code>bean</code>是否是<code>FacctoryBean</code>的实现，然后进一步判断是否是 <code>SmartFactoryBean</code>实现，其中<code>SmartFactoryBean</code>定义了<code>isEagerInit</code>方法，如果为<code>True</code>则立即实例化该<code>bean</code>。如果该<code>bean</code>不是<code>BeanFactory</code>的实现，也会实例化该<code>bean</code>。</p>
<h5 id="AbstractBeanFactory-isFactoryBean"><a href="#AbstractBeanFactory-isFactoryBean" class="headerlink" title="AbstractBeanFactory#isFactoryBean"></a>AbstractBeanFactory#isFactoryBean</h5><pre><code class="java">    @Override
    public boolean isFactoryBean(String name) throws NoSuchBeanDefinitionException {
        // 获取bean的真实名
        String beanName = transformedBeanName(name);
        // 获取 工厂bean 单例
        Object beanInstance = getSingleton(beanName, false);
        if (beanInstance != null) {
            return (beanInstance instanceof FactoryBean);
        }
        // No singleton instance found -&gt; check bean definition.
        if (!containsBeanDefinition(beanName) &amp;&amp; getParentBeanFactory() instanceof ConfigurableBeanFactory) {
            // No bean definition found in this factory -&gt; delegate to parent.
            return ((ConfigurableBeanFactory) getParentBeanFactory()).isFactoryBean(name);
        }
        return isFactoryBean(beanName, getMergedLocalBeanDefinition(beanName));
    }
</code></pre>
<h5 id="DefaultSingletonBeanRegistry-getSingleton"><a href="#DefaultSingletonBeanRegistry-getSingleton" class="headerlink" title="DefaultSingletonBeanRegistry#getSingleton"></a>DefaultSingletonBeanRegistry#getSingleton</h5><p><code>SingletonBeanRegistry</code>是<code>SingletonBeanRegistry</code>接口定义的方法，如下是<code>DefaultSingletonBeanRegistry</code>的实现</p>
<pre><code class="java">    /**
     * Return the (raw) singleton object registered under the given name.
     * &lt;p&gt;Checks already instantiated singletons and also allows for an early
     * reference to a currently created singleton (resolving a circular reference).
     * @param beanName the name of the bean to look for
     * @param allowEarlyReference whether early references should be created or not
     * @return the registered singleton object, or {@code null} if none found
     */
    @Nullable
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        // Quick check for existing instance without full singleton lock
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null &amp;&amp; allowEarlyReference) {
                synchronized (this.singletonObjects) {
                    // Consistent creation of early reference within full singleton lock
                    singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
                        singletonObject = this.earlySingletonObjects.get(beanName);
                        if (singletonObject == null) {
                            ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);
                            if (singletonFactory != null) {
                                singletonObject = singletonFactory.getObject();
                                this.earlySingletonObjects.put(beanName, singletonObject);
                                this.singletonFactories.remove(beanName);
                            }
                        }
                    }
                }
            }
        }
        return singletonObject;
    }
</code></pre>
<h4 id="AbstractBeanFactory-doGetBean"><a href="#AbstractBeanFactory-doGetBean" class="headerlink" title="AbstractBeanFactory#doGetBean"></a>AbstractBeanFactory#doGetBean</h4><p><code>doGetBean</code>方法由<code>AbstractBeanFactory</code>定义，有不同的实现，用以获取<code>bean</code>，其代码如下：</p>
<pre><code class="java">/**
     * Return an instance, which may be shared or independent, of the specified bean.
     * @param name the name of the bean to retrieve
     * @param requiredType the required type of the bean to retrieve
     * @param args arguments to use when creating a bean instance using explicit arguments
     * (only applied when creating a new instance as opposed to retrieving an existing one)
     * @param typeCheckOnly whether the instance is obtained for a type check,
     * not for actual use
     * @return an instance of the bean
     * @throws BeansException if the bean could not be created
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    protected &lt;T&gt; T doGetBean(
            String name, @Nullable Class&lt;T&gt; requiredType, @Nullable Object[] args, boolean typeCheckOnly)
            throws BeansException {

        String beanName = transformedBeanName(name);
        Object bean;

        // Eagerly check singleton cache for manually registered singletons.
        Object sharedInstance = getSingleton(beanName);
        if (sharedInstance != null &amp;&amp; args == null) {
            if (logger.isTraceEnabled()) {
                if (isSingletonCurrentlyInCreation(beanName)) {
                    logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +
                            &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);
                }
                else {
                    logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);
                }
            }
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
        }

        else {
            // Fail if we&#39;re already creating this bean instance:
            // We&#39;re assumably within a circular reference.
            // 如果已经创建过这个bean实例，那假设处在循环引用 
            // 如果 beanName 正在被通过 原型模式创建，则抛出异常，无法应对循环依赖问题
            if (isPrototypeCurrentlyInCreation(beanName)) {
                throw new BeanCurrentlyInCreationException(beanName);
            }

            // 检查beanfactory中是否已经存在该 bean definition， 如果该 bean factory中没有该bean definition ，
            // 则查找其parent bean factory中是否有该 bean definition
            BeanFactory parentBeanFactory = getParentBeanFactory();
            if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {
                // Not found -&gt; check parent.
                String nameToLookup = originalBeanName(name);
                if (parentBeanFactory instanceof AbstractBeanFactory) {
                    return ((AbstractBeanFactory) parentBeanFactory).doGetBean(
                            nameToLookup, requiredType, args, typeCheckOnly);
                }
                else if (args != null) {
                    // Delegation to parent with explicit args.
                    return (T) parentBeanFactory.getBean(nameToLookup, args);
                }
                else if (requiredType != null) {
                    // No args -&gt; delegate to standard getBean method.
                    return parentBeanFactory.getBean(nameToLookup, requiredType);
                }
                else {
                    return (T) parentBeanFactory.getBean(nameToLookup);
                }
            }

            if (!typeCheckOnly) {
                markBeanAsCreated(beanName);
            }

            try {
                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                // 再次检查该 bean definition 是否是 抽象类，如果是，则抛出异常
                checkMergedBeanDefinition(mbd, beanName, args);

                // 确保 实例化该bean对象所依赖的bean 都已经被注册
                String[] dependsOn = mbd.getDependsOn();
                if (dependsOn != null) {
                    for (String dep : dependsOn) {
                        // 确认指定的依赖bean是否已经注册给该bean，或者任何其可传递项
                        if (isDependent(beanName, dep)) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                    &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);
                        }
                        // 如果没有注册过，则注册依赖的bean
                        registerDependentBean(dep, beanName);
                        try {
                            getBean(dep);
                        }
                        catch (NoSuchBeanDefinitionException ex) {
                            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                    &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);
                        }
                    }
                }

                // 创建 bean 实例， 有两种典型模式
                if (mbd.isSingleton()) {
                    sharedInstance = getSingleton(beanName, () -&gt; {
                        try {
                            return createBean(beanName, mbd, args);
                        }
                        catch (BeansException ex) {
                            // Explicitly remove instance from singleton cache: It might have been put there
                            // eagerly by the creation process, to allow for circular reference resolution.
                            // Also remove any beans that received a temporary reference to the bean.
                            destroySingleton(beanName);
                            throw ex;
                        }
                    });
                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                }

                else if (mbd.isPrototype()) {
                    // It&#39;s a prototype -&gt; create a new instance.
                    Object prototypeInstance = null;
                    try {
                        beforePrototypeCreation(beanName);
                        prototypeInstance = createBean(beanName, mbd, args);
                    }
                    finally {
                        afterPrototypeCreation(beanName);
                    }
                    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                }
                // 其他场景，目前没有实现
                else {
                    String scopeName = mbd.getScope();
                    if (!StringUtils.hasLength(scopeName)) {
                        throw new IllegalStateException(&quot;No scope name defined for bean &#39;&quot; + beanName + &quot;&#39;&quot;);
                    }
                    Scope scope = this.scopes.get(scopeName);
                    if (scope == null) {
                        throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);
                    }
                    try {
                        Object scopedInstance = scope.get(beanName, () -&gt; {
                            beforePrototypeCreation(beanName);
                            try {
                                return createBean(beanName, mbd, args);
                            }
                            finally {
                                afterPrototypeCreation(beanName);
                            }
                        });
                        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
                    }
                    catch (IllegalStateException ex) {
                        throw new BeanCreationException(beanName,
                                &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +
                                &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,
                                ex);
                    }
                }
            }
            catch (BeansException ex) {
                // 在bean创建失败后，对缓存的元数据执行适当的清理。
                cleanupAfterBeanCreationFailure(beanName);
                throw ex;
            }
        }

        // 检查 期望的类型 和 当前bean实例的类型是否匹配
        if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {
            try {
                T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
                if (convertedBean == null) {
                    throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                }
                return convertedBean;
            }
            catch (TypeMismatchException ex) {
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +
                            ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);
                }
                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
            }
        }
        return (T) bean;
    }
</code></pre>
<p>第9行中通过调用<code>getSingleton</code>检查本地的单例缓存是否已经加载过<code>bean</code>，没有则检查<code>earlySingletonObjects</code>中是否已经加载过<code>bean</code>。如果该<code>bean</code>对象不为null则调用<code>getObjectForBeanInstance</code>方法获取bean。否则执行如下逻辑：</p>
<ol>
<li>调用<code> mbd.getDependsOn()</code>保证当前bean 依赖的bean会优先于当前bean被加载。</li>
<li>根据<code>beandefinition</code>的定义，按照单例&#x2F;原型模式来创建bean。单例bean和原型bean的创建过程如下。</li>
</ol>
<h4 id="单例bean的创建过程"><a href="#单例bean的创建过程" class="headerlink" title="单例bean的创建过程"></a>单例bean的创建过程</h4><pre><code class="java">    if (mbd.isSingleton()) {
        sharedInstance = getSingleton(beanName, () -&gt; {
            try {
                return createBean(beanName, mbd, args);
            }
            catch (BeansException ex) {
                // Explicitly remove instance from singleton cache: It might have been put there
                // eagerly by the creation process, to allow for circular reference resolution.
                // Also remove any beans that received a temporary reference to the bean.
                destroySingleton(beanName);
                throw ex;
            }
        });
        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    }
</code></pre>
<p>抽象类<code>AbstractBeanFactory</code>中定义了抽象方法<code>createBean</code>，由子类<code>AbstractAutowireCapableBeanFactory</code>进行重写。</p>
<pre><code class="java">/**
     * Central method of this class: creates a bean instance,
     * populates the bean instance, applies post-processors, etc.
     * @see #doCreateBean
     */
    @Override
    protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
            throws BeanCreationException {

        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);
        }
        RootBeanDefinition mbdToUse = mbd;

        // Make sure bean class is actually resolved at this point, and
        // clone the bean definition in case of a dynamically resolved Class
        // which cannot be stored in the shared merged bean definition.
        Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);
        if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        // Prepare method overrides.
        try {
            mbdToUse.prepareMethodOverrides();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
                    beanName, &quot;Validation of method overrides failed&quot;, ex);
        }

        try {
            // Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
            if (bean != null) {
                return bean;
            }
        }
        catch (Throwable ex) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                    &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
        }

        try {
            Object beanInstance = doCreateBean(beanName, mbdToUse, args);
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);
            }
            return beanInstance;
        }
        catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
            // A previously detected exception with proper bean creation context already,
            // or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanCreationException(
                    mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);
        }
    }
</code></pre>
<p>其中会再次调用<code>doCreateBean</code>的重载方法：</p>
<pre><code class="java">/**
     * Actually create the specified bean. Pre-creation processing has already happened
     * at this point, e.g. checking {@code postProcessBeforeInstantiation} callbacks.
     * &lt;p&gt;Differentiates between default bean instantiation, use of a
     * factory method, and autowiring a constructor.
     * @param beanName the name of the bean
     * @param mbd the merged bean definition for the bean
     * @param args explicit arguments to use for constructor or factory method invocation
     * @return a new instance of the bean
     * @throws BeanCreationException if the bean could not be created
     * @see #instantiateBean
     * @see #instantiateUsingFactoryMethod
     * @see #autowireConstructor
     */
    protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
            throws BeanCreationException {

        // Instantiate the bean.
        BeanWrapper instanceWrapper = null;
        if (mbd.isSingleton()) {
            instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
        }
        if (instanceWrapper == null) {
            instanceWrapper = createBeanInstance(beanName, mbd, args);
        }
        Object bean = instanceWrapper.getWrappedInstance();
        Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();
        if (beanType != NullBean.class) {
            mbd.resolvedTargetType = beanType;
        }

        // Allow post-processors to modify the merged bean definition.
        synchronized (mbd.postProcessingLock) {
            if (!mbd.postProcessed) {
                try {
                    // 允许后置处理器修改合并后的bean definition
                    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            &quot;Post-processing of merged bean definition failed&quot;, ex);
                }
                mbd.postProcessed = true;
            }
        }

        // 如果 bdf是单例且允许循环引用且当前该bean处于创建过程中，则使用三级缓存，预先将该bean创建所使用的beanfactory存入三级缓存中
        boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;
                isSingletonCurrentlyInCreation(beanName));
        if (earlySingletonExposure) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +
                        &quot;&#39; to allow for resolving potential circular references&quot;);
            }
            addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));
        }

        // Initialize the bean instance.
        Object exposedObject = bean;
        try {
            // 填充field属性
            populateBean(beanName, mbd, instanceWrapper);
            // 初始化该bean，包含bean的注入等
            exposedObject = initializeBean(beanName, exposedObject, mbd);
        }
        catch (Throwable ex) {
            if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
                throw (BeanCreationException) ex;
            }
            else {
                throw new BeanCreationException(
                        mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
            }
        }

        if (earlySingletonExposure) {
            Object earlySingletonReference = getSingleton(beanName, false);
            if (earlySingletonReference != null) {
                if (exposedObject == bean) {
                    exposedObject = earlySingletonReference;
                }
                else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {
                    String[] dependentBeans = getDependentBeans(beanName);
                    Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);
                    for (String dependentBean : dependentBeans) {
                        if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                            actualDependentBeans.add(dependentBean);
                        }
                    }
                    if (!actualDependentBeans.isEmpty()) {
                        throw new BeanCurrentlyInCreationException(beanName,
                                &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +
                                StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
                                &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +
                                &quot;wrapped. This means that said other beans do not use the final version of the &quot; +
                                &quot;bean. This is often the result of over-eager type matching - consider using &quot; +
                                &quot;&#39;getBeanNamesForType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);
                    }
                }
            }
        }

        // Register bean as disposable.
        try {
            registerDisposableBeanIfNecessary(beanName, bean, mbd);
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
        }

        return exposedObject;
    }
</code></pre>
<p>根据<code>beandefinition</code>是否是单例，如果是则从<code>factoryBeanInstanceCache</code>移除该<code>instanceWrapper</code>，如果<code>instanceWrapper</code>为空，则调用<code>createBeanInstance</code>创建bean实例并包装为<code>beanwrapper</code>。<code>createBeanInstance</code>函数代码如下：</p>
<pre><code class="java">    protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
        // Make sure bean class is actually resolved at this point.
        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);

        if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                    &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());
        }

        Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();
        if (instanceSupplier != null) {
            return obtainFromSupplier(instanceSupplier, beanName);
        }

        if (mbd.getFactoryMethodName() != null) {
            return instantiateUsingFactoryMethod(beanName, mbd, args);
        }

        // Shortcut when re-creating the same bean...
        boolean resolved = false;
        boolean autowireNecessary = false;
        if (args == null) {
            synchronized (mbd.constructorArgumentLock) {
                if (mbd.resolvedConstructorOrFactoryMethod != null) {
                    resolved = true;
                    autowireNecessary = mbd.constructorArgumentsResolved;
                }
            }
        }
        if (resolved) {
            if (autowireNecessary) {
                return autowireConstructor(beanName, mbd, null, null);
            }
            else {
                return instantiateBean(beanName, mbd);
            }
        }

        // Candidate constructors for autowiring?
        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
        if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
            return autowireConstructor(beanName, mbd, ctors, args);
        }

        // Preferred constructors for default construction?
        ctors = mbd.getPreferredConstructors();
        if (ctors != null) {
            return autowireConstructor(beanName, mbd, ctors, null);
        }

        // No special handling: simply use no-arg constructor.
        return instantiateBean(beanName, mbd);
    }
</code></pre>
<p>继续往下看，<code>instantiateBean</code>函数通过调用<code>instantiate</code>函数根据<code>beanName</code>和<code>beanDefinition</code>创建<code>bean</code>实例并调用<code>initBeanWrapper</code>将该bean包装为为<code>BeanWrapper</code>返回。</p>
<pre><code class="java">/**
     * Instantiate the given bean using its default constructor.
     * @param beanName the name of the bean
     * @param mbd the bean definition for the bean
     * @return a BeanWrapper for the new instance
     */
    protected BeanWrapper instantiateBean(String beanName, RootBeanDefinition mbd) {
        try {
            Object beanInstance;
            if (System.getSecurityManager() != null) {
                beanInstance = AccessController.doPrivileged(
                        (PrivilegedAction&lt;Object&gt;) () -&gt; getInstantiationStrategy().instantiate(mbd, beanName, this),
                        getAccessControlContext());
            }
            else {
                beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, this);
            }
            BeanWrapper bw = new BeanWrapperImpl(beanInstance);
            initBeanWrapper(bw);
            return bw;
        }
        catch (Throwable ex) {
            throw new BeanCreationException(
                    mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);
        }
    }
</code></pre>
<p>SimpleInstantiationStrategy#instantiate  </p>
<pre><code class="java">    @Override
    public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
        // Don&#39;t override the class with CGLIB if no overrides.
        if (!bd.hasMethodOverrides()) {
            Constructor&lt;?&gt; constructorToUse;
            synchronized (bd.constructorArgumentLock) {
                constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;
                if (constructorToUse == null) {
                    final Class&lt;?&gt; clazz = bd.getBeanClass();
                    if (clazz.isInterface()) {
                        throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);
                    }
                    try {
                        if (System.getSecurityManager() != null) {
                            constructorToUse = AccessController.doPrivileged(
                                    (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);
                        }
                        else {
                            constructorToUse = clazz.getDeclaredConstructor();
                        }
                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;
                    }
                    catch (Throwable ex) {
                        throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);
                    }
                }
            }
            return BeanUtils.instantiateClass(constructorToUse);
        }
        else {
            // Must generate CGLIB subclass.
            return instantiateWithMethodInjection(bd, beanName, owner);
        }
    }
</code></pre>
<p>如果该<code>beandefinition</code>没有被重写过，则在调用<code>BeanUtils.instantiateClass</code>创建bean实例之前选择一个构造方法；否则抛出异常。</p>
<p>BeanUtils#instantiateClass </p>
<p>该方法通过反射创建bean实例，通过调用<code>ReflectionUtils.makeAccessible(ctor)</code>，即使该bean的构造方法是私有的也可以用来创建实例。</p>
<pre><code class="java">    /**
     * Convenience method to instantiate a class using the given constructor.
     * &lt;p&gt;Note that this method tries to set the constructor accessible if given a
     * non-accessible (that is, non-public) constructor, and supports Kotlin classes
     * with optional parameters and default values.
     * @param ctor the constructor to instantiate
     * @param args the constructor arguments to apply (use {@code null} for an unspecified
     * parameter, Kotlin optional parameters and Java primitive types are supported)
     * @return the new instance
     * @throws BeanInstantiationException if the bean cannot be instantiated
     * @see Constructor#newInstance
     */
    public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException {
        Assert.notNull(ctor, &quot;Constructor must not be null&quot;);
        try {
            ReflectionUtils.makeAccessible(ctor);
            if (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) {
                return KotlinDelegate.instantiateClass(ctor, args);
            }
            else {
                Class&lt;?&gt;[] parameterTypes = ctor.getParameterTypes();
                Assert.isTrue(args.length &lt;= parameterTypes.length, &quot;Can&#39;t specify more arguments than constructor parameters&quot;);
                Object[] argsWithDefaultValues = new Object[args.length];
                for (int i = 0 ; i &lt; args.length; i++) {
                    if (args[i] == null) {
                        Class&lt;?&gt; parameterType = parameterTypes[i];
                        argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : null);
                    }
                    else {
                        argsWithDefaultValues[i] = args[i];
                    }
                }
                return ctor.newInstance(argsWithDefaultValues);
            }
        }
        catch (InstantiationException ex) {
            throw new BeanInstantiationException(ctor, &quot;Is it an abstract class?&quot;, ex);
        }
        catch (IllegalAccessException ex) {
            throw new BeanInstantiationException(ctor, &quot;Is the constructor accessible?&quot;, ex);
        }
        catch (IllegalArgumentException ex) {
            throw new BeanInstantiationException(ctor, &quot;Illegal arguments for constructor&quot;, ex);
        }
        catch (InvocationTargetException ex) {
            throw new BeanInstantiationException(ctor, &quot;Constructor threw exception&quot;, ex.getTargetException());
        }
    }
</code></pre>
<h4 id="原型bean的创建"><a href="#原型bean的创建" class="headerlink" title="原型bean的创建"></a>原型bean的创建</h4><pre><code class="java">    else if (mbd.isPrototype()) {
        // It&#39;s a prototype -&gt; create a new instance.
        // 如果是原型模式，则创建一个新对象
        Object prototypeInstance = null;
        try {
            beforePrototypeCreation(beanName);
            prototypeInstance = createBean(beanName, mbd, args);
        }
        finally {
            afterPrototypeCreation(beanName);
        }
        bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
    }
</code></pre>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.jianshu.com/p/577906fa2cc2">1. SpringBoot深入学习（一）– refresh()</a>   </p>
<p><a href="https://lucumt.info/post/spring/spring-core/difference-between-factorybean-and-beanfactory/">2. Spring中BeanFactory和FactoryBean的区别以及使用场景</a>  </p>
<p><a href="https://blog.csdn.net/weixin_43944305/article/details/108526186">3. Spring的单例bean与原型bean的区别和创建过程</a>  </p>
<p><a href="https://www.cnblogs.com/xrq730/p/6361578.html">4. <a href="https://www.cnblogs.com/xrq730/p/6361578.html">【Spring源码分析】非懒加载的单例Bean初始化过程（上篇）</a></a></p>
