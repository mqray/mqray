<hr>
<h2 id="title-springboot源码之启动流程2date-2023-10-12-08-12-15tags-spring-java"><a href="#title-springboot源码之启动流程2date-2023-10-12-08-12-15tags-spring-java" class="headerlink" title="title: springboot源码之启动流程2date: 2023-10-12 08:12:15tags:- spring- java"></a>title: springboot源码之启动流程2<br>date: 2023-10-12 08:12:15<br>tags:<br>- spring<br>- java</h2><p><code>spring</code>启动流程比较长，接上回<a href="https://mqrayblog.cn/2023/10/10/springboot%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">springboot源码之启动流程1</a>，接下来继续看<code>refreshContext</code></p>
<h2 id="SpringApplication-refreshContext"><a href="#SpringApplication-refreshContext" class="headerlink" title="SpringApplication#refreshContext"></a>SpringApplication#refreshContext</h2><ol>
<li>创建并初始化 BeanFactory：首先，它会创建一个 BeanFactory 对象，用于管理和创建应用程序中的 Bean。</li>
<li>加载 Bean 定义：接下来，它会加载应用程序中定义的 Bean，包括通过注解、XML 配置文件等方式定义的 Bean。</li>
<li>实例化和初始化 Bean：然后，它会实例化和初始化所有的 Bean，包括依赖注入、AOP 代理等操作。</li>
<li>处理 Bean 生命周期回调：在 Bean 实例化和初始化完成后，<code>refresh</code> 方法会调用各个 Bean 的生命周期回调方法，例如 <code>@PostConstruct</code> 注解标注的方法。</li>
<li>注册 Bean 后置处理器：<code>refresh</code> 方法还会注册 Bean 后置处理器，用于在 Bean 初始化前后进行一些额外的处理操作。</li>
</ol>
<p>通过调用 <code>SpringApplication#refresh</code> 方法，应用程序上下文将完成初始化和刷新，所有的 Bean 将被正确创建和配置，应用程序将进入可用状态，可以响应外部请求。</p>
<pre><code class="JAVA">private void refreshContext(ConfigurableApplicationContext context) {
    refresh((ApplicationContext) context);
    if (this.registerShutdownHook) {
        try {
            // 注册 关闭 钩子
            context.registerShutdownHook();
        }
        catch (AccessControlException ex) {
            // Not allowed in some environments.
        }
    }
}
</code></pre>
<h3 id="SpringApplication-refresh"><a href="#SpringApplication-refresh" class="headerlink" title="SpringApplication#refresh"></a>SpringApplication#refresh</h3><pre><code class="java">@Deprecated
protected void refresh(ApplicationContext applicationContext) {
    Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);
    refresh((ConfigurableApplicationContext) applicationContext);
}

protected void refresh(ConfigurableApplicationContext applicationContext) {
    applicationContext.refresh();
}

@Deprecated
protected void refresh(ApplicationContext applicationContext) {
    Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);
    refresh((ConfigurableApplicationContext) applicationContext);
}
</code></pre>
<p>其中，<code>refresh</code>是<code>ConfigurableApplicationContext</code>中定义的接口，默认有如下实现</p>
<p><img src="C:\Users\User\AppData\Local\Temp\1697068082459.png" alt="1697068082459"></p>
<img src="./springboot源码之启动流程2/SpringApplication_refresh.png">  

<h4 id="AbstractApplicationContext-refresh"><a href="#AbstractApplicationContext-refresh" class="headerlink" title="AbstractApplicationContext#refresh"></a>AbstractApplicationContext#refresh</h4><pre><code class="java">    @Override
    public void refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // 为刷新上下文做准备工作
            prepareRefresh();

            // Tell the subclass to refresh the internal bean factory.
            //  通知子类刷新内部的 bean factory
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context.
            // 准备 bean factory
            prepareBeanFactory(beanFactory);

            try {
                // Allows post-processing of the bean factory in context subclasses.
                // 
                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.
                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.
                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.
                initMessageSource();

                // Initialize event multicaster for this context.
                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.
                onRefresh();

                // Check for listener beans and register them.
                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.
                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.
                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                }

                // Destroy already created singletons to avoid dangling resources.
                destroyBeans();

                // Reset &#39;active&#39; flag.
                cancelRefresh(ex);

                // Propagate exception to caller.
                throw ex;
            }

            finally {
                // Reset common introspection caches in Spring&#39;s core, since we
                // might not ever need metadata for singleton beans anymore...
                resetCommonCaches();
            }
        }
    }
</code></pre>
<h3 id="AbstractApplicationContext-prepareRefresh"><a href="#AbstractApplicationContext-prepareRefresh" class="headerlink" title="AbstractApplicationContext#prepareRefresh"></a>AbstractApplicationContext#prepareRefresh</h3><p>在<code>refresh</code>前做准备工作：</p>
<ol>
<li>设置spring启动事件，开启活跃状态</li>
<li>初始化属性源信息</li>
<li>保存<code>earlyApplicationListeners</code></li>
<li>验证必要的属性</li>
</ol>
<pre><code class="java">    /**
     * Prepare this context for refreshing, setting its startup date and
     * active flag as well as performing any initialization of property sources.
     */
    protected void prepareRefresh() {
        // 设置激活状态
        this.startupDate = System.currentTimeMillis();
        this.closed.set(false);
        this.active.set(true);

        if (logger.isDebugEnabled()) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Refreshing &quot; + this);
            }
            else {
                logger.debug(&quot;Refreshing &quot; + getDisplayName());
            }
        }

        // 初始化 上下文环境中的 所有 PropertySources 调用 initServletPropertySources
        initPropertySources();
        // 校验所有被标识为required 的properties都可以被解析
        getEnvironment().validateRequiredProperties();

        // Store pre-refresh ApplicationListeners...
        if (this.earlyApplicationListeners == null) {
            this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);
        }
        else {
            // Reset local application listeners to pre-refresh state.
            this.applicationListeners.clear();
            this.applicationListeners.addAll(this.earlyApplicationListeners);
        }
        // 存储 应用启动前的 事件 ，在 multicaster可用时发布
        this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();
    }
</code></pre>
<h3 id="AbstractApplicationContext-obtainFreshBeanFactory"><a href="#AbstractApplicationContext-obtainFreshBeanFactory" class="headerlink" title="AbstractApplicationContext#obtainFreshBeanFactory"></a>AbstractApplicationContext#obtainFreshBeanFactory</h3><ol>
<li>通知子类刷新内在的 bean factory</li>
</ol>
<pre><code class="java">/**
     * Tell the subclass to refresh the internal bean factory.
     * @return the fresh BeanFactory instance
     * @see #refreshBeanFactory()
     * @see #getBeanFactory()
     */
    protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
        refreshBeanFactory();
        return getBeanFactory();
    }
</code></pre>
<h4 id="AbstractRefreshableApplicationContext-refreshBeanFactory"><a href="#AbstractRefreshableApplicationContext-refreshBeanFactory" class="headerlink" title="AbstractRefreshableApplicationContext#refreshBeanFactory"></a>AbstractRefreshableApplicationContext#refreshBeanFactory</h4><p>负责刷新<code>beanfactory</code></p>
<pre><code class="java">    @Override
    protected final void refreshBeanFactory() throws BeansException {
        // 如果已经存在 beanfactory，销毁并关闭beanfactory
        if (hasBeanFactory()) {
            destroyBeans();
            closeBeanFactory();
        }
        try {
            // 创建 DefaultListableBeanFactory 类型的 beanfactory。 初始化容器，注册并加载bean基本容器
            DefaultListableBeanFactory beanFactory = createBeanFactory();
            beanFactory.setSerializationId(getId());
            // 设置 beanfactory 属性，比如是否bean名字重复时可否重写、是否允许循环引用
            customizeBeanFactory(beanFactory);
            // 将 beandefinition 注册到 beanfactory
            loadBeanDefinitions(beanFactory);
            this.beanFactory = beanFactory;
        }
        catch (IOException ex) {
            throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);
        }
    }
</code></pre>
<p><img src="C:\Users\User\AppData\Local\Temp\1697111817207.png" alt="1697111817207"></p>
<img src="./springboot源码之启动流程2/createBeanFactory.png">  



<p><img src="C:\Users\User\AppData\Local\Temp\1697073372826.png" alt="1697073372826"></p>
<img src="./springboot源码之启动流程2/AbstractRefreshableApplicationContext_arch.png">   





<h5 id="AbstractRefreshableApplicationContext-loadBeanDefinitions"><a href="#AbstractRefreshableApplicationContext-loadBeanDefinitions" class="headerlink" title="AbstractRefreshableApplicationContext#loadBeanDefinitions"></a>AbstractRefreshableApplicationContext#loadBeanDefinitions</h5><p>有如下四个实现 还要继续看</p>
<p><img src="C:\Users\User\AppData\Local\Temp\1697111477191.png" alt="1697111477191"></p>
<img src="./springboot源码之启动流程2/abstractRefreshableApplicationContext_loadBeanDefinitions.png">   





<h5 id="AbstractApplicationContext-prepareBeanFactory"><a href="#AbstractApplicationContext-prepareBeanFactory" class="headerlink" title="AbstractApplicationContext#prepareBeanFactory"></a>AbstractApplicationContext#prepareBeanFactory</h5><p>上一步获取到新的<code>BeanFactory</code>后，<code>prepareBeanFactory</code>设置其属性。</p>
<ol>
<li>配置<code>BeanClassLoader</code>；</li>
<li>设置<code>BeanExpressionResolver</code> bean名称解析器，主要用来解析<code>EL</code>表达式，在bean初始化完成之后属性填充时会用到；</li>
<li>设置<code>PropertyEditorRegistrar</code>属性解析器</li>
<li>设置<code>BeanPostProcessor</code>, <code>ApplicationContextAwareProcessor</code> 用来处理并回调实现各种<code>Aware</code>接口的bean</li>
<li><code>ignoreDependencyInterface</code>忽略如下类的自动装配  <code>EnvironmentAware| EmbeddedValueResolverAware| ResourceLoaderAware|ApplicationEventPublisherAware|MessageSourceAware|ApplicationContextAware</code> 。</li>
<li><code>registerResolvableDependency</code>设置自动装配规则。</li>
<li>配置<code>ApplicationListenerDetector</code>的<code>BeanPostProcessor</code>;</li>
<li>如果 <code>beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)</code>如果当前的<code>beanFactory</code>包含<code>loadTimeWeaver</code>，则将当前<code>beanFactory</code>交给类加载器<code>BeanPostProcessor</code>的实现类<code>LoadTimeWeaverAwareProcessor</code>处理。从而实现类加载器植入<code>AspectJ</code>的目的。</li>
<li><code>registerSingleton</code> 注册环境相关的 bean</li>
</ol>
<pre><code class="java">    protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // Tell the internal bean factory to use the context&#39;s class loader etc.
        beanFactory.setBeanClassLoader(getClassLoader());
        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

        // Configure the bean factory with context callbacks.
        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

        // BeanFactory interface not registered as resolvable type in a plain factory.
        // MessageSource registered (and found for autowiring) as a bean.
        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
        beanFactory.registerResolvableDependency(ResourceLoader.class, this);
        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
        beanFactory.registerResolvableDependency(ApplicationContext.class, this);

        // Register early post-processor for detecting inner beans as ApplicationListeners.
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

        // Detect a LoadTimeWeaver and prepare for weaving, if found.
        if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            // Set a temporary ClassLoader for type matching.
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }

        // Register default environment beans.
        if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
        }
        if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
            beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
        }
        if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
        }
    }
</code></pre>
<h3 id="AbstractApplicationContext-postProcessBeanFactory"><a href="#AbstractApplicationContext-postProcessBeanFactory" class="headerlink" title="AbstractApplicationContext#postProcessBeanFactory"></a>AbstractApplicationContext#postProcessBeanFactory</h3><ul>
<li>在所有<code>beandefinition</code>加载完之后，<code>bean实例化</code>之前执行；可以理解为<code>prepareBeanFactory</code>的补充或者扩展；<code>spring</code>中不同的子类有不同的实现。</li>
<li>但是不允许在重写的<code>prepareBeanFactory</code>方法中对<code>bean</code>进行实例化操作。</li>
</ul>
<pre><code class="java">    /**
     * Modify the application context&#39;s internal bean factory after its standard
     * initialization. All bean definitions will have been loaded, but no beans
     * will have been instantiated yet. This allows for registering special
     * BeanPostProcessors etc in certain ApplicationContext implementations.
     * @param beanFactory the bean factory used by the application context
     */
    // 所有 beandefinition加载后，实例化之前执行
    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    }
</code></pre>
<p><img src="C:\Users\User\AppData\Local\Temp\1697114653991.png" alt="1697114653991"></p>
<img src="./springboot源码之启动流程2/AbstractApplicationContext_postProcessBeanFactory.png">   







<h4 id="AbstractRefreshableWebApplicationContext-postProcessBeanFactory"><a href="#AbstractRefreshableWebApplicationContext-postProcessBeanFactory" class="headerlink" title="AbstractRefreshableWebApplicationContext#postProcessBeanFactory#"></a>AbstractRefreshableWebApplicationContext#postProcessBeanFactory#</h4><pre><code class="java">    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));
        beanFactory.ignoreDependencyInterface(ServletContextAware.class);
        beanFactory.ignoreDependencyInterface(ServletConfigAware.class);
        WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);
        WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);
    }
</code></pre>
<h3 id="AbstractApplicationContext-invokeBeanFactoryPostProcessors"><a href="#AbstractApplicationContext-invokeBeanFactoryPostProcessors" class="headerlink" title="AbstractApplicationContext#invokeBeanFactoryPostProcessors"></a>AbstractApplicationContext#invokeBeanFactoryPostProcessors</h3><pre><code class="java">/**
     * Instantiate and invoke all registered BeanFactoryPostProcessor beans,
     * respecting explicit order if given.
     * &lt;p&gt;Must be called before singleton instantiation.
     */
    protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
        PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

        // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
        // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
        if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }
    }
</code></pre>
<h4 id="PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors"><a href="#PostProcessorRegistrationDelegate-invokeBeanFactoryPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors"></a>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</h4><pre><code class="java">这段代码也太长了，可以单独起一篇了
</code></pre>
<h3 id="AbstractApplicationContext-registerBeanPostProcessors"><a href="#AbstractApplicationContext-registerBeanPostProcessors" class="headerlink" title="AbstractApplicationContext#registerBeanPostProcessors"></a>AbstractApplicationContext#registerBeanPostProcessors</h3><pre><code class="java">注册拦截bean创建的bean处理器。如果给定顺序则遵循顺序。它必须在 bean 实例化 之前调用

    /**
     * Instantiate and register all BeanPostProcessor beans,
     * respecting explicit order if given.
     * &lt;p&gt;Must be called before any instantiation of application beans.
     */
    protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
        PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
    }
</code></pre>
<h4 id="PostProcessorRegistrationDelegate-registerBeanPostProcessors"><a href="#PostProcessorRegistrationDelegate-registerBeanPostProcessors" class="headerlink" title="PostProcessorRegistrationDelegate#registerBeanPostProcessors"></a>PostProcessorRegistrationDelegate#registerBeanPostProcessors</h4><ol>
<li>获取所有<code>BeanPostProcessor</code>名称</li>
<li>添加后置处理器<code>BeanPostProcessorChecker</code></li>
<li>遍历<code>BeanPostProcessorName</code>，分如下三种情况：<code>PriorityOrdered</code>、<code>Ordered</code>、<code>其他</code>。</li>
<li>注册<code>priorityOrderedPostProcessors</code>，注册之前按照优先级升序排列</li>
<li>注册<code>orderedPostProcessors。</code>先根据 <code>orderedPostProcessorNames</code>从beanFactory中获取 <code>BeanPostProcessor</code>，然后注册到 <code>orderedPostProcessors</code>  中，如果该processor的类型是 <code>MergedBeanDefinitionPostProcessor</code>  则同时加入到<code>internalPostProcessors</code>中。</li>
<li>和第5步类似，注册<code>nonOrderedPostProcessors</code>。也有加入<code>internalPostProcessors</code>逻辑。</li>
<li>注册<code>internalPostProcessors</code></li>
<li>注册<code>ApplicationListenerDetector</code>处理器，同时将它移动到处理器链的最后。</li>
</ol>
<pre><code class="java">    public static void registerBeanPostProcessors(
            ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

        // Register BeanPostProcessorChecker that logs an info message when
        // a bean is created during BeanPostProcessor instantiation, i.e. when
        // a bean is not eligible for getting processed by all BeanPostProcessors.
        int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
        beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

        // Separate between BeanPostProcessors that implement PriorityOrdered,
        // Ordered, and the rest.
        List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
        List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
        List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
        List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
        for (String ppName : postProcessorNames) {
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
                priorityOrderedPostProcessors.add(pp);
                if (pp instanceof MergedBeanDefinitionPostProcessor) {
                    internalPostProcessors.add(pp);
                }
            }
            else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
                orderedPostProcessorNames.add(ppName);
            }
            else {
                nonOrderedPostProcessorNames.add(ppName);
            }
        }

        // First, register the BeanPostProcessors that implement PriorityOrdered.
        sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
        registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

        // Next, register the BeanPostProcessors that implement Ordered.
        List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size());
        for (String ppName : orderedPostProcessorNames) {
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            orderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        sortPostProcessors(orderedPostProcessors, beanFactory);
        registerBeanPostProcessors(beanFactory, orderedPostProcessors);

        // Now, register all regular BeanPostProcessors.
        List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());
        for (String ppName : nonOrderedPostProcessorNames) {
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            nonOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

        // Finally, re-register all internal BeanPostProcessors.
        sortPostProcessors(internalPostProcessors, beanFactory);
        registerBeanPostProcessors(beanFactory, internalPostProcessors);

        // Re-register post-processor for detecting inner beans as ApplicationListeners,
        // moving it to the end of the processor chain (for picking up proxies etc).
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
    }
</code></pre>
<h3 id="AbstractApplicationContext-initMessageSource"><a href="#AbstractApplicationContext-initMessageSource" class="headerlink" title="AbstractApplicationContext#initMessageSource"></a>AbstractApplicationContext#initMessageSource</h3><ol>
<li>初始化消息源。如果上下文中未定义，则使用父类的实现。</li>
<li>判断<code>beanFactory</code>中是否有名为<code>messageSource</code>的bean</li>
<li>如果有，获取到之后，判断其类型是否为<code>HierarchicalMessageSource</code>则填充其父类的消息源</li>
<li>否则，新建<code>DelegatingMessageSource</code>作为消息源</li>
</ol>
<pre><code class="java">/**
     * Initialize the MessageSource.
     * Use parent&#39;s if none defined in this context.
     */
    protected void initMessageSource() {
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
            this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
            // Make MessageSource aware of parent MessageSource.
            if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) {
                HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
                if (hms.getParentMessageSource() == null) {
                    // Only set parent context as parent MessageSource if no parent MessageSource
                    // registered already.
                    hms.setParentMessageSource(getInternalParentMessageSource());
                }
            }
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);
            }
        }
        else {
            // Use empty MessageSource to be able to accept getMessage calls.
            DelegatingMessageSource dms = new DelegatingMessageSource();
            dms.setParentMessageSource(getInternalParentMessageSource());
            this.messageSource = dms;
            beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;No &#39;&quot; + MESSAGE_SOURCE_BEAN_NAME + &quot;&#39; bean, using [&quot; + this.messageSource + &quot;]&quot;);
            }
        }
    }
</code></pre>
<h3 id="AbstractApplicationContext-initApplicationEventMulticaster"><a href="#AbstractApplicationContext-initApplicationEventMulticaster" class="headerlink" title="AbstractApplicationContext#initApplicationEventMulticaster"></a>AbstractApplicationContext#initApplicationEventMulticaster</h3><ol>
<li>初始化应用事件广播器，如果未定义则默认使用<code>SimpleApplicationEventMulticaster</code></li>
<li>检查<code>beanFactory</code>中是否有名为<code>applicationEventMulticaster</code>的bean对象，如果有，则将其设置为应用上下文的<code>applicationEventMulticaster</code></li>
<li>否则，使用<code>SimpleApplicationEventMulticaster</code>作为应用上下文的<code>applicationEventMulticaster</code></li>
</ol>
<pre><code class="java">    /**
     * Initialize the ApplicationEventMulticaster.
     * Uses SimpleApplicationEventMulticaster if none defined in the context.
     * @see org.springframework.context.event.SimpleApplicationEventMulticaster
     */
    protected void initApplicationEventMulticaster() {
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
            this.applicationEventMulticaster =
                    beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Using ApplicationEventMulticaster [&quot; + this.applicationEventMulticaster + &quot;]&quot;);
            }
        }
        else {
            this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
            beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;No &#39;&quot; + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + &quot;&#39; bean, using &quot; +
                        &quot;[&quot; + this.applicationEventMulticaster.getClass().getSimpleName() + &quot;]&quot;);
            }
        }
    }
</code></pre>
<h3 id="AbstractApplicationContext-onRefresh"><a href="#AbstractApplicationContext-onRefresh" class="headerlink" title="AbstractApplicationContext#onRefresh"></a>AbstractApplicationContext#onRefresh</h3><p>可以重写以添加特定于上下文的刷新工作的模板方法。在初始化特殊bean时调用，然后再实例化singleton。</p>
<p>空实现，由子类重写。</p>
<p><img src="C:\Users\User\AppData\Local\Temp\1697158204211.png" alt="1697158204211"></p>
<img src="./springboot源码之启动流程2/AbstractApplicationContext_onRefresh.png">   

<p>如上五个子类实现中，<code>ServletWebServerApplicationContext</code>和<code>ReactiveWebServerApplicationContext</code>的实现如下。</p>
<h4 id="ServletWebServerApplicationContext-onRefresh"><a href="#ServletWebServerApplicationContext-onRefresh" class="headerlink" title="ServletWebServerApplicationContext#onRefresh#"></a>ServletWebServerApplicationContext#onRefresh#</h4><ol>
<li>调用父类的onRefresh实现，其实是空</li>
<li>调用<code>createWebServer</code>创建web服务</li>
</ol>
<pre><code class="java">    @Override
    protected void onRefresh() {
        super.onRefresh();
        try {
            createWebServer();
        }
        catch (Throwable ex) {
            throw new ApplicationContextException(&quot;Unable to start reactive web server&quot;, ex);
        }
    }
</code></pre>
<h5 id="ServletWebServerApplicationContext-createWebServer"><a href="#ServletWebServerApplicationContext-createWebServer" class="headerlink" title="ServletWebServerApplicationContext#createWebServer"></a>ServletWebServerApplicationContext#createWebServer</h5><ol>
<li>获取 <code>getServletContext</code></li>
<li>判断<code>webServer</code>和<code>servletContext</code></li>
</ol>
<pre><code class="java">    private void createWebServer() {
        WebServer webServer = this.webServer;
        ServletContext servletContext = getServletContext();
        if (webServer == null &amp;&amp; servletContext == null) {
            ServletWebServerFactory factory = getWebServerFactory();
            this.webServer = factory.getWebServer(getSelfInitializer());
            getBeanFactory().registerSingleton(&quot;webServerGracefulShutdown&quot;,
                    new WebServerGracefulShutdownLifecycle(this.webServer));
            getBeanFactory().registerSingleton(&quot;webServerStartStop&quot;,
                    new WebServerStartStopLifecycle(this, this.webServer));
        }
        else if (servletContext != null) {
            try {
                getSelfInitializer().onStartup(servletContext);
            }
            catch (ServletException ex) {
                throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);
            }
        }
        initPropertySources();
    }
</code></pre>
<p>其余三个子类实现则比较简单，仅对主题源做了配置。</p>
<pre><code class="java">    protected void onRefresh() {
        this.themeSource = UiApplicationContextUtils.initThemeSource(this);
    }
</code></pre>
<h3 id="ServletWebServerApplicationContext-registerListeners"><a href="#ServletWebServerApplicationContext-registerListeners" class="headerlink" title="ServletWebServerApplicationContext#registerListeners"></a>ServletWebServerApplicationContext#registerListeners</h3><ol>
<li>注册指定的静态监听器。</li>
</ol>
<pre><code class="java">/**
     * Add beans that implement ApplicationListener as listeners.
     * Doesn&#39;t affect other listeners, which can be added without being beans.
     */
    protected void registerListeners() {
        // 获取手动注册的监听器，添加到广播器中
        for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {
            getApplicationEventMulticaster().addApplicationListener(listener);
        }
        // 获取监听器名称，配置到广播器中
        // 注意， 此处不进行初始化 
        // Do not initialize FactoryBeans here: We need to leave all regular beans
        // uninitialized to let post-processors apply to them!
        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
        for (String listenerBeanName : listenerBeanNames) {
            getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
        }

        // 将 earlyApplicationEvents 中保存的事件 广播到 各监听器
        Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;
        this.earlyApplicationEvents = null;
        if (!CollectionUtils.isEmpty(earlyEventsToProcess)) {
            for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
                getApplicationEventMulticaster().multicastEvent(earlyEvent);
            }
        }
    }
</code></pre>
<h3 id="ServletWebServerApplicationContext-finishBeanFactoryInitialization"><a href="#ServletWebServerApplicationContext-finishBeanFactoryInitialization" class="headerlink" title="ServletWebServerApplicationContext#finishBeanFactoryInitialization"></a>ServletWebServerApplicationContext#finishBeanFactoryInitialization</h3><p>完成bean factory的上下文初始化，初始化所有非懒加载的单例</p>
<p>这部分逻辑很长，单独放在另外一篇文章中： <a href="">springboot源码之启动流程3</a></p>
<pre><code class="java">    /**
     * Finish the initialization of this context&#39;s bean factory,
     * initializing all remaining singleton beans.
     */
    protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        // 初始化 上下文转换服务
        if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
                beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
            beanFactory.setConversionService(
                    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
        }

        // 如果没有BeanFactoryPostProcessor，则注入一个默认的值解析器
        // 主要用于解析注解注入的属性值
        if (!beanFactory.hasEmbeddedValueResolver()) {
            beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
        }

        // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
        // 初始化 LoadTimeWeaverAware 以提前注册 转化器
        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
        for (String weaverAwareName : weaverAwareNames) {
            getBean(weaverAwareName);
        }

        // 不再使用临时的类加载器做类型匹配
        beanFactory.setTempClassLoader(null);

        // 禁止修改所有bean definition，不允许再修改
        beanFactory.freezeConfiguration();

        // 实例化所有非懒加载的单例
        beanFactory.preInstantiateSingletons();
    }
</code></pre>
<h4 id="DefaultListableBeanFactory-preInstantiateSingletons"><a href="#DefaultListableBeanFactory-preInstantiateSingletons" class="headerlink" title="DefaultListableBeanFactory#preInstantiateSingletons"></a>DefaultListableBeanFactory#preInstantiateSingletons</h4><p>确保所有(包含<code>FactoryBeans</code>)非懒加载的单例被初始化</p>
<ol>
<li>遍历所有bean，获取其<code>beanDefinition</code>，如果没有就找其父类的<code>beanDefinition</code>。</li>
<li>针对于<code>beandefinition</code>，其初始化需要保证如下三个条件：<ul>
<li>不是抽象类</li>
<li>是单例对象</li>
<li>非懒加载</li>
</ul>
</li>
<li>获取<code>bean</code></li>
</ol>
<pre><code class="java">    @Override
    public void preInstantiateSingletons() throws BeansException {
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Pre-instantiating singletons in &quot; + this);
        }

        // 对副本进行迭代以允许init方法注册新的bean定义
        // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
        List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);

        // 调用 非懒加载的bean的初始化
        for (String beanName : beanNames) {
            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
            if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
                if (isFactoryBean(beanName)) {
                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                    if (bean instanceof FactoryBean) {
                        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
                        boolean isEagerInit;
                        if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                            isEagerInit = AccessController.doPrivileged(
                                    (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                                    getAccessControlContext());
                        }
                        else {
                            isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                                    ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                        }
                        if (isEagerInit) {
                            getBean(beanName);
                        }
                    }
                }
                else {
                    getBean(beanName);
                }
            }
        }

        // 触发后置初始化回调函数
        for (String beanName : beanNames) {
            Object singletonInstance = getSingleton(beanName);
            if (singletonInstance instanceof SmartInitializingSingleton) {
                SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
                if (System.getSecurityManager() != null) {
                    AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
                        smartSingleton.afterSingletonsInstantiated();
                        return null;
                    }, getAccessControlContext());
                }
                else {
                    smartSingleton.afterSingletonsInstantiated();
                }
            }
        }
    }
</code></pre>
<h3 id="ServletWebServerApplicationContext-finishRefresh"><a href="#ServletWebServerApplicationContext-finishRefresh" class="headerlink" title="ServletWebServerApplicationContext#finishRefresh"></a>ServletWebServerApplicationContext#finishRefresh</h3><p>调用<code>LifecycleProcessor#onRefresh</code>刷新上下文，同时广播<code>ContextRefreshedEvent</code>事件</p>
<pre><code class="java">    /**
     * Finish the refresh of this context, invoking the LifecycleProcessor&#39;s
     * onRefresh() method and publishing the
     * {@link org.springframework.context.event.ContextRefreshedEvent}.
     */
    protected void finishRefresh() {
        // 清除上下文级别的资源缓存(比如扫描的ASM元数据)
        clearResourceCaches();

        // 初始化 LifecycleProcessor
        initLifecycleProcessor();

        // 调用 `LifecycleProcessor.onRefresh
        getLifecycleProcessor().onRefresh();

        // 广播 ContextRefreshedEvent事件
        publishEvent(new ContextRefreshedEvent(this));

        // Participate in LiveBeansView MBean, if active.
        LiveBeansView.registerApplicationContext(this);
    }
</code></pre>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><a href="https://www.jianshu.com/p/577906fa2cc2">1. SpringBoot深入学习（一）– refresh()</a>  </p>
<p><a href="https://lucumt.info/post/spring/spring-core/difference-between-factorybean-and-beanfactory/">2. Spring中BeanFactory和FactoryBean的区别以及使用场景</a></p>
